[
    {
        "id": 1,
        "email": "2714351312@qq.com",
        "title": "基于nodejs如何爬取csdn上自己的文章",
        "content": "> 当你想把自己在csdn上写的文章转为hexo上可以发布的文章或是将文章写入自己的数据库时,可以用到\n\n### 将所有博客数据写入数据库\n\n#### 获取你的文章的分页接口:\n\n在浏览自己的所有文章时,我们不难发现,文章的数据是往下滑动到底时,才会刷新出新的数据,  \n那么此时肯定是发送了一个请求来获取后面的分页数据:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/21270e8d2caa4ed6a7a37c195170ffb8.png)  \n这时,我们再查看他的请求url:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/6fda97b97ad14b6c995b9df837151436.png)  \n尝试查看下他的res.data:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/3898d871599d46e5a6ffc4321e684b93.png)  \n那么,在这个url中,page,size这两个参数可以调整,其他的参数还没有尝试  \n接口为:  \n`https://blog.csdn.net/community/home-api/v1/get-business-list?page=2&size=20&businessType=lately&noMore=false&username=你的用户名`\n\n#### 将接口请求到的数据写入数据库:\n\n这里我使用的是nodejs和mysql,\n\n*   database schema:\n\n    const {\n    \tDataTypes\n    } = require('sequelize')\n    const seq = require('../db/sql')\n    \n    const markdownFile = seq.define('markdownFile', {\n    \t//id会被sequelize自动创建,管理\n    \ttype: {\n    \t\ttype: DataTypes.STRING,\n    \t\tallowNull: true,\n    \t},\n    \tformatTime: {\n    \t\ttype: DataTypes.DATE,\n    \t\tallowNull: true,\n    \t},\n    \ttitle: {\n    \t\ttype: DataTypes.STRING,\n    \t\tallowNull: true,\n    \t},\n    \tdescription: {\n    \t\ttype: DataTypes.TEXT,\n    \t\tallowNull: true,\n    \t},\n    \thasOriginal: {\n    \t\ttype: DataTypes.BOOLEAN,\n    \t\tallowNull: true,\n    \t},\n    \tdiggCount: {\n    \t\ttype: DataTypes.INTEGER,\n    \t\tallowNull: true,\n    \t},\n    \tcommentCount: {\n    \t\ttype: DataTypes.INTEGER,\n    \t\tallowNull: true,\n    \t},\n    \tpostTime: {\n    \t\ttype: DataTypes.DATE,\n    \t\tallowNull: true,\n    \t},\n    \tcreateTime: {\n    \t\ttype: DataTypes.DATE,\n    \t\tallowNull: true,\n    \t},\n    \turl: {\n    \t\ttype: DataTypes.STRING,\n    \t\tallowNull: true,\n    \t},\n    \tarticleType: {\n    \t\ttype: DataTypes.INTEGER,\n    \t\tallowNull: true,\n    \t},\n    \tviewCount: {\n    \t\ttype: DataTypes.INTEGER,\n    \t\tallowNull: true,\n    \t},\n    \trtype: {\n    \t\ttype: DataTypes.STRING,\n    \t\tallowNull: true,\n    \t},\n    \tcontent: {\n    \t\ttype: DataTypes.TEXT,\n    \t\tallowNull: true,\n    \t\tdefault: '暂无内容'\n    \t},\n    \temail: {\n    \t\ttype: DataTypes.STRING,\n    \t\tallowNull: true,\n    \t\tdefault: '拥有者邮箱'\n    \t}\n    });\n    //下面这个是初始化时才开启的\n    \n    /*markdownFile.sync({\n        force: 'true'\n    });*/\n    \n    //下面这个是运行时才开启的\n    module.exports = markdownFile;\n    \n\n这里的schema是按照需求写的,具体需要哪些字段,是看通过接口请求得到的文章数据中,有哪些字段\n\n*   连接mysql的sql.js\n\n这里的sql.js代码按照自己的配置来连接,其中function`test`为连接时测试是否成功\n\n    //本机数据库连接配置\n    const {Sequelize} = require('sequelize')\n    //实例化对象\n    const seq = new Sequelize('markdownfile', 'root', '123456', {\n    // const seq = new Sequelize('markdownfile', 'root','1df4490cbd872e80', {\n        dialect: 'mysql',\n        port: 3306\n    });\n    \n    async function test() {\n        try {\n            await seq.authenticate()\n            console.log('数据库连接成功')\n        } catch (error) {\n            console.error('数据库连接失败:  ', error)\n        }\n    }\n    test();\n    module.exports = seq;\n    \n\n此时,只需要使用`https`包,请求api,并将数据写入数据库  \n下面是需要运行的代码:\n\n    //根据csdn的api接口获取文章列表\n    const markdownFile = require('./model/markdownFile')\n    const {\n    \tcreate\n    } = require('./service/md')\n    \n    const https = require(\"https\");\n    const config = {\n    \turl1: 'https://blog.csdn.net/community/home-api/v1/get-business-list?page=',\n    \turl2: '&size=20&businessType=lately&noMore=false&username=ice_stone_kai',\n    \tpage: {\n    \t\tnum: '1',\n    \t\tsize: '20'\n    \t},\n    \thtml: '',\n    \tjson: {}\n    \n    };\n    //使用http\n    https.get(`${config.url1}10${config.url2}`, res => {\n    \tres.on('data', function (chunk) {\n    \t\tconfig.html += chunk;\n    \t});\n    \tres.on('end', () => {\n    \t\tconfig.json = JSON.parse(config.html);\n    \t\tconsole.log('data:');\n    \t\tconst dataList = config.json.data.list;\n    \t\t\tdataList.forEach(item => {\n    \t\t\t\tcreate(item);\n    \t\t\t});\n    \t})\n    });\n    \n\n其中create为:\n\n    \n    const https = require(\"https\");\n    const markdownFile = require('../model/markdownFile');\n    class md {\n        async create(obj) {\n            // console.log(obj)\n            const {\n                type,\n                formatTime,\n                title,\n                description, hasOriginal,\n                diggCount,\n                commentCount,\n                postTime,\n                createTime,\n                url,\n                articleType,\n                viewCount,\n                rtype,\n                email\n            } = obj;\n            // await md.getData(url)\n            return await markdownFile.create({\n                type,\n                formatTime,\n                title,\n                description, hasOriginal,\n                diggCount,\n                commentCount,\n                postTime,\n                createTime,\n                url,\n                articleType,\n                viewCount,\n                rtype,\n                email\n            })\n        }\n    }\n    module.exports = new md;\n    \n\n##### 数据库创建:\n\n将schema那部分代码的注释取消:\n\n    markdownFile.sync({\n        force: 'true'\n    });\n    \n\n右键,run  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/6fb79af4d37d4d6ab8de58e5aaf329cd.png)  \n进入datagrip查看:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/e63a80372a464632b8f02ec3bf672dfa.png)  \n创建完成之后,刚刚的代码一定要再加上注释,或者把force的部分加上注释:\n\n    /*\n    markdownFile.sync({\n        force: 'true'\n    });\n    */\n    \n\n它的意思是,不管数据库是否存在,都会强制再创建一个新的目标数据库\n\n##### 通过api写入数据库:\n\n这里我们是通过分页的接口来获取数据的,那么就需要修改page的参数来请求不同的分页数据,所以,我们这里page为1开始:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/fc9e7b2002fc4987aeaefacc42ff4262.png)  \n查看数据库:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/3aa0d2c479f948d88def341eed7ed1b7.png)  \n写入了,这里你有多少分页数据就修改page的参数即可  \n我的分页数据有10页,所以这里修改page的参数从1,2,一直到10,  \n别问为什么不用遍历来异步获取数据,不会\n\n##### 将数据库中的单个文章数据写入markdown文件:\n\n此时我们的数据库:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/a003cb9b917d4094925ff2a09ad2516a.png)  \n注意此时数据库中的数据字段并没有文章数据:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/81562add1b7643c9aface0d0b6a8b528.png)\n\n###### 数据库的item获取文章数据:\n\n尝试下面代码,便利查看数据库所有数据:\n\n    const fs = require('fs');\n    const https = require(\"https\");\n    const cheerio = require(\"cheerio\");\n    const TurndownService = require('turndown');\n    const turndownService = new TurndownService();\n    const markdownFile = require('./model/markdownFile');\n    //将数据写入markdown文件\n    \n    markdownFile.findAll({\n    \traw: true  //只显示原始数据\n    }).then(res => {\n    \tres.forEach(item => {\n    \t\tconsole.log(item)\n    \t})\n    }).catch(e => {\n    \tconsole.log(e)\n    });\n    \n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/e6bf70caf7d1480f962a8fcc36ca2163.png)\n\n###### 通过url获取文章数据:\n\n注意这里的代码可能导入的一些库没有写上去\n\n    \n    const cheerio = require(\"cheerio\");\n    readArtivcle('https://blog.csdn.net/ice_stone_kai/article/details/125666593');\n    function readArtivcle(url) {\n    \tlet html = '';\n    \thttps.get(`${url}`, res => {\n    \t\tres.on('data', function (chunk) {\n    \t\t\thtml += chunk;\n    \t\t});\n    \t\tres.on('end', () => {\n    \t\t\tconsole.log('html获取完毕');\n    \t\t\tconst $ = cheerio.load(html);\n    \t\t\tconst ele = $(\"#content_views\");\n    \t\t\tconsole.log('将要写入的数据:---');\n    \t\t\tconsole.log(ele.html());\n    \t\t})\n    \t});\n    }\n    \n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d9f4c0989b5d44babe20b1b68bad96db.png)  \n这里使用`cheerio`来操作网页的dom.\n\n###### html转markdown\n\n此时我们会发现获取的数据��能并不那么理想,我们要写入的,应该是markdown格式的文件,那么就可以使用一些库来将htmlk转markdown:\n\n    function readArtivcle(url, filename, title, description, date) {\n    \tlet html = '';\n    \thttps.get(`${url}`, res => {\n    \t\tres.on('data', function (chunk) {\n    \t\t\thtml += chunk;\n    \t\t});\n    \t\tres.on('end', () => {\n    \t\t\tconsole.log('html获取完毕');\n    \t\t\tconst $ = cheerio.load(html);\n    \t\t\tconst ele = $(\"#content_views\");\n    \t\t\tlet markdown = '';\n    \t\t\ttry {\n    \t\t\t\tmarkdown = turndownService.turndown(ele.html());\n    \t\t\t} catch (e) {\n    \t\t\t\tconsole.log('节点读取错误')\n    \t\t\t}\n    \t\t\tconsole.log('将要写入的数据:---');\n    \t\t\tconsole.log(markdown);\n    \t\t})\n    \t});\n    }\n    \n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/3abc6b5493494140b421a46e23753e00.png)  \n这里就转为了markdown格式的字符串\n\n###### markdown写入文件:\n\n代码:\n\n    readArtivcle('https://blog.csdn.net/ice_stone_kai/article/details/125666593');\n    \n    function readArtivcle(url, filename, title, description, date) {\n    \tlet html = '';\n    \thttps.get(`${url}`, res => {\n    \t\tres.on('data', function (chunk) {\n    \t\t\thtml += chunk;\n    \t\t});\n    \t\tres.on('end', () => {\n    \t\t\tconsole.log('html获取完毕');\n    \t\t\tconst $ = cheerio.load(html);\n    \t\t\tconst ele = $(\"#content_views\");\n    \t\t\tlet markdown = '';\n    \t\t\ttry {\n    \t\t\t\tmarkdown = turndownService.turndown(ele.html());\n    \t\t\t} catch (e) {\n    \t\t\t\tconsole.log('节点读取错误')\n    \t\t\t}\n    \t\t\twriteFileToMarkdown(markdown, 'demo1.md');\n    \t\t})\n    \t});\n    }\n    \n    \n    function writeFileToMarkdown(str, filename) {\n    \tfs.access(`./demo/${filename}`, fs.constants.F_OK, (err) => {\n    \t\tconsole.log(`first judgement: ${filename} ${err ? 'is not exist' : 'is exist'}`);\n    \t\tif (err) {\n    \t\t\tconsole.log(`${filename} is not exist,so I will create it`);\n    \t\t\tfs.writeFile(`./demo/${filename}`, '', (error) => {\n    \t\t\t\t//创建失败\n    \t\t\t\tif (error) {\n    \t\t\t\t\tconsole.log(`file id no's exist,and create error：${error}`)\n    \t\t\t\t}\n    \t\t\t\t//创建成功\n    \t\t\t\tconsole.log(`file id no's exist,but create success！`);\n    \t\t\t\t//自己调用下自己,写入str\n    \t\t\t\twriteFileToMarkdown(str, filename)\n    \t\t\t})\n    \t\t} else {\n    \t\t\tfs.writeFile(`./demo/${filename}`, str, err => {\n    \t\t\t\tif (err) {\n    \t\t\t\t\tconsole.log('file write error');\n    \t\t\t\t\tconsole.log(err)\n    \t\t\t\t} else {\n    \t\t\t\t\tconsole.log('file write success');\n    \t\t\t\t}\n    \t\t\t})\n    \t\t}\n    \t});\n    }\n    \n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/781746da26a64971ae56526326e355dd.png)  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/6a22f8d26157426789e9841acd8af739.png)  \n这里的`writeFileToMarkdown`第一个参数接受需要写入的字符串,第二个参数接受该文件的文件名,这里的文件名需要带文件的扩展名(.md),当文件不存在时,会先创建一次目标文件,然后自己调用一次自己,再写入\n\n那么查看markdown文件:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/7cdf1134d64947349218f550cf9741cc.png)  \n在浏览器中查看原来的网页:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/dd95b1e8618a42ffb81e0dbdce25695b.png)  \n还行,但是打开markdown文件你会发现,它的头部并没有像是hexo博客的那种格式:  \nhexo应该是:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/2aa28d3bc1214dce96ebe5eebd515f81.png)  \n那么我们尝试添加一下:\n\n    const fs = require('fs');\n    const https = require(\"https\");\n    const cheerio = require(\"cheerio\");\n    const TurndownService = require('turndown');\n    const turndownService = new TurndownService();\n    const markdownFile = require('./model/markdownFile');\n    //将数据写入markdown文件\n    \n    markdownFile.findAll({\n    \traw: true  //只显示原始数据\n    }).then(res => {\n    \tres.forEach(item => {\n    \t\tconsole.log(item)\n    \t\tconst date = item.formatTime;\n    \t\tconst title = item.title;\n    \t\tconst name = item.title + \".md\";\n    \t\tconst url = item.url;\n    \t\tconst description = item.description;\n    \n    \t\tsetTimeout(function () {\n    \t\t\treadArtivcle(url, name, title, description,date);\n    \t\t}, 3000);\n    \t})\n    }).catch(e => {\n    \tconsole.log(e)\n    });\n    \n    function readArtivcle(url, filename, title, description, date) {\n    \tlet html = '';\n    \thttps.get(`${url}`, res => {\n    \t\tres.on('data', function (chunk) {\n    \t\t\thtml += chunk;\n    \t\t});\n    \t\tres.on('end', () => {\n    \t\t\tconsole.log('html获取完毕');\n    \t\t\tconst $ = cheerio.load(html);\n    \t\t\tconst ele = $(\"#content_views\");\n    \t\t\tlet markdown = '';\n    \t\t\ttry {\n    \t\t\t\tmarkdown = turndownService.turndown(ele.html());\n    \t\t\t} catch (e) {\n    \t\t\t\tconsole.log('节点读取错误')\n    \t\t\t}\n    \t\t\tconsole.log('将要写入的数据:---');\n    \t\t\tmarkdown = '---  \\n' + markdown;\n    \t\t\tmarkdown = `date:${date}  \\n` + markdown;\n    \t\t\tmarkdown = `categories:  \\n  - ${description}  \\n` + markdown;\n    \t\t\tmarkdown = `author: icestone  \\n` + markdown;\n    \t\t\tmarkdown = `title: ${title}  \\n` + markdown;\n    \t\t\tmarkdown = '---  \\n' + markdown;\n    \t\t\tconsole.log(markdown);\n    \t\t\twriteFileToMarkdown(markdown, filename);\n    \t\t})\n    \t});\n    }\n    \n    \n    function writeFileToMarkdown(str, filename) {\n    \tfs.access(`./markdownFile/${filename}`, fs.constants.F_OK, (err) => {\n    \t\tconsole.log(`first judgement: ${filename} ${err ? 'is not exist' : 'is exist'}`);\n    \t\tif (err) {\n    \t\t\tconsole.log(`${filename} is not exist,so I will create it`);\n    \t\t\tfs.writeFile(`./markdownFile/${filename}`, '', (error) => {\n    \t\t\t\t//创建失败\n    \t\t\t\tif (error) {\n    \t\t\t\t\tconsole.log(`file id no's exist,and create error：${error}`)\n    \t\t\t\t}\n    \t\t\t\t//创建成功\n    \t\t\t\tconsole.log(`file id no's exist,but create success！`);\n    \t\t\t\t//自己调用下自己,写入str\n    \t\t\t\twriteFileToMarkdown(str, filename)\n    \t\t\t})\n    \t\t} else {\n    \t\t\tfs.writeFile(`./markdownFile/${filename}`, str, err => {\n    \t\t\t\tif (err) {\n    \t\t\t\t\tconsole.log('file write error');\n    \t\t\t\t\tconsole.log(err)\n    \t\t\t\t} else {\n    \t\t\t\t\tconsole.log('file write success');\n    \t\t\t\t}\n    \t\t\t})\n    \t\t}\n    \t});\n    }\n    \n\n注意,这里代码跑起来不会停,你估计文章写完了,就把它停了就ok:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/afd268c99ef84d2e999f9481955ac5dd.png)  \n但是,此时把markdown文章放进hexokinase的博客目录下,你会发现,文章的tag可能有些问题:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/feb4275a030a41798d71145b0fb9813a.png)  \n查看hexo中是怎样写的:\n\n    title: jsp_session和cookie\n    author: icestone\n    tags:\n      - jsp\n      - java\n    categories:\n      - jsp下的session和cookie\n    date: 2022-11-15 21:38:00\n    ---\n    \n\n它的头部应该是这样的,那么我们就需要在通过url获取文章页面时,获取tag标签所在的dom节点中的html:\n\n    \tconst tag = $(\".tags-box>a.tag-link\");\n    \tlet tags = 'tags:\\n';\n    \tlet markdown = '';\n    \ttry {\n    \t\tmarkdown = turndownService.turndown(ele.html());\n    \t} catch (e) {\n    \t\tconsole.log('节点读取错误')\n    \t}\n    \ttag.each((item, index) => {\n    \t\tif (tags.indexOf($(index).html())) {\n    \t\ttags +='- '+ $(index).html() + \"\\n\"\n    \t\t}\n    \t});\n    \n\n那么修改之后的代码为:\n\n    const fs = require('fs');\n    const https = require(\"https\");\n    const cheerio = require(\"cheerio\");\n    const TurndownService = require('turndown');\n    const turndownService = new TurndownService();\n    const markdownFile = require('./model/markdownFile');\n    //将数据写入markdown文件\n    \n    markdownFile.findAll({\n    \traw: true  //只显示原始数据\n    }).then(res => {\n    \tres.forEach(item => {\n    \t\t// console.log(item)\n    \t\t// const date = timeTrans(item.formatTime);\n    \t\tconst date = item.formatTime;\n    \t\tconst title = item.title;\n    \t\tconst name = item.title + \".md\";\n    \t\tconst url = item.url;\n    \t\tconst description = item.description;\n    \n    \t\tsetTimeout(function () {\n    \t\t\treadArtivcle(url, name, title, description, date);\n    \t\t}, 3000);\n    \t})\n    }).catch(e => {\n    \tconsole.log(e)\n    });\n    \n    function readArtivcle(url, filename, title, description, date) {\n    \tlet html = '';\n    \thttps.get(`${url}`, res => {\n    \t\tres.on('data', function (chunk) {\n    \t\t\thtml += chunk;\n    \t\t});\n    \t\tres.on('end', () => {\n    \t\t\tconsole.log('html获取完毕');\n    \t\t\tconst $ = cheerio.load(html);\n    \t\t\tconst ele = $(\"#content_views\");\n    \t\t\tconst tag = $(\".tags-box>a.tag-link\");\n    \t\t\tlet tags = 'tags:\\n';\n    \t\t\tlet markdown = '';\n    \t\t\ttry {\n    \t\t\t\tmarkdown = turndownService.turndown(ele.html());\n    \t\t\t} catch (e) {\n    \t\t\t\tconsole.log('节点读取错误')\n    \t\t\t}\n    \t\t\ttag.each((item, index) => {\n    \t\t\t\tif (tags.indexOf($(index).html())) {\n    \t\t\t\t\ttags +='- '+ $(index).html() + \"\\n\"\n    \t\t\t\t}\n    \t\t\t});\n    \t\t\tmarkdown = '---\\n' + markdown;\n    \t\t\tmarkdown = `created: ${date}\\n` + markdown;\n    \t\t\tmarkdown = `categories:  \\n  - ${description}  \\n\\n` + markdown;\n    \t\t\tmarkdown = `${tags}\\n` + markdown;\n    \t\t\tmarkdown = `author: icestone\\n` + markdown;\n    \t\t\tmarkdown = `title: ${title}\\n\\n` + markdown;\n    \t\t\tmarkdown = '---\\n' + markdown;\n    \t\t\twriteFileToMarkdown(markdown, filename);\n    \t\t})\n    \t});\n    }\n    \n    \n    function writeFileToMarkdown(str, filename) {\n    \tfs.access(`./markdownFile/${filename}`, fs.constants.F_OK, (err) => {\n    \t\tconsole.log(`first judgement: ${filename} ${err ? 'is not exist' : 'is exist'}`);\n    \t\tif (err) {\n    \t\t\tconsole.log(`${filename} is not exist,so I will create it`);\n    \t\t\tfs.writeFile(`./markdownFile/${filename}`, '', (error) => {\n    \t\t\t\t//创建失败\n    \t\t\t\tif (error) {\n    \t\t\t\t\tconsole.log(`file id no's exist,and create error：${error}`)\n    \t\t\t\t}\n    \t\t\t\t//创建成功\n    \t\t\t\tconsole.log(`file id no's exist,but create success！`);\n    \t\t\t\t//自己调用下自己,写入str\n    \t\t\t\twriteFileToMarkdown(str, filename)\n    \t\t\t})\n    \t\t} else {\n    \t\t\tfs.writeFile(`./markdownFile/${filename}`, str, err => {\n    \t\t\t\tif (err) {\n    \t\t\t\t\tconsole.log('file write error');\n    \t\t\t\t\tconsole.log(err)\n    \t\t\t\t} else {\n    \t\t\t\t\tconsole.log('file write success');\n    \t\t\t\t}\n    \t\t\t})\n    \t\t}\n    \t});\n    }\n    \n    function timeTrans(time, type) {\n    \tlet date = new Date(new Date(time).getTime() + 8 * 3600 * 1000)\n    \tdate = date.toJSON();\n    \tif (type === 1) {\n    \t\tdate = date.substring(0, 10)\n    \t} else {\n    \t\tdate = date.substring(0, 19).replace('T', ' ')\n    \t}\n    \treturn date\n    }\n    \n\nrun:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/9c5e45e937184fc78be28086da1ba874.png)  \n将一篇markdown文章copy进hexo的目录:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/04df08367f63461abc056569ead39cba.png)  \nhexo clean一下并重启:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/71380f4d49134d0888801881de4722a0.png)  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/364e24219192467c9dbe3a6dd64045a3.png)  \n没有问题\n\n#### 将文章copy进hexo:\n\n一般hexo的文章放在:`hexo文件目录/source/_posts`:\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/07715de79d6b4a9797e5d8d28dece9d3.png)  \nok,没得问题,就是描述那里的文字太长了",
        "states": "0",
        "description": "当你想把自己在csdn上写的文章转为hexo上可以发布的文章或是将文章写入自己的数据库时,可以用到。",
        "praise": "0",
        "view": "233",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/128270130",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "1",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-07-21T03:58:10.000Z",
        "destroyTime": null
    },
    {
        "id": 2,
        "email": "2714351312@qq.com",
        "title": "ubuntu22.4配置nginx和php",
        "content": "实验操作步骤\n\n1.  安装ngix  \n    这里使用命令：  \n    sudo apt install nginx\n\n    2.\ticestone@icestone-nb:~$ sudo apt install nginx\n    3.\t[sudo] icestone 的密码： \n    4.\t正在读取软件包列表... 完成\n    5.\t正在分析软件包的依赖关系树... 完成\n    6.\t正在读取状态信息... 完成                 \n    7.\t将会同时安装下列软件：\n    8.\t  libnginx-mod-http-geoip2 libnginx-mod-http-image-filter libnginx-mod-http-xslt-filter libnginx-mod-mail libnginx-mod-stream libnginx-mod-stream-geoip2 nginx-common nginx-core\n    9.\t下列【新】软件包将被安装：\n    10.\t  libnginx-mod-http-geoip2 libnginx-mod-http-image-filter libnginx-mod-http-xslt-filter libnginx-mod-mail libnginx-mod-stream libnginx-mod-stream-geoip2 nginx nginx-common nginx-core\n    11.\t升级了 0 个软件包，新安装了 9 个软件包，要卸载 0 个软件包，有 2 个软件包未被升级。\n    12.\t需要下载 696 kB 的归档。\n    13.\t解压缩后会消耗 2,395 kB 的额外空间。\n    14.\t您希望继续执行吗？ [Y/n] Y\n    2.调整防火墙：\n    sudo ufw app list\n    15.\ticestone@icestone-nb:~$ sudo ufw allow 'Nginx HTTP'\n    16.\t规则已添加\n    17.\t规则已添加 (v6)\n    18.\ticestone@icestone-nb:~$ sudo ufw allow 'Nginx HTTPS'\n    19.\t规则已添加\n    20.\t规则已添加 (v6)\n    21.\ticestone@icestone-nb:~$ sudo ufw allow 'Nginx Full'\n    22.\t规则已添加\n    23.\t规则已添加 (v6)\n    \n\n查看结果：  \nsudo ufw status\n\n    24.\ticestone@icestone-nb:~$ sudo ufw status\n    25.\t状态： 激活\n    26.\t\n    27.\t至                          动作          来自\n    28.\t-                          --          --\n    29.\t                 ALLOW       Anywhere                  \n    30.\t80/tcp                     ALLOW       Anywhere                  \n    31.\t443/tcp                    ALLOW       Anywhere\n    \n\nsuccess\n\n3.检查web服务：  \nsystemctl status nginx\n\n    32.\ticestone@icestone-nb:~$ systemctl status nginx\n    33.\t● nginx.service - A high performance web server and a reverse proxy server\n    34.\t     Loaded: loaded (/lib/systemd/system/nginx.service; enabled; vendor preset: enabled)\n    35.\t     Active: active (running) since Thu 2022-11-10 23:07:21 CST; 1h 14min ago\n    36.\t       Docs: man:nginx(8)\n    37.\t    Process: 21371 ExecStartPre=/usr/sbin/nginx -t -q -g daemon on; master_process on; (code=exited, status=0/SUCCESS)\n    38.\t    Process: 21374 ExecStart=/usr/sbin/nginx -g daemon on; master_process on; (code=exited, status=0/SUCCESS)\n    \n\nsuccess  \n39\\. 访问;  \nhttp://localhost/  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/7b1f75122ec24acba820172de580fedd.png)\n\n2.开启https：  \n40\\. 修改配置文件  \n这里由于使用的ubuntu22.04  \n修改 /etc/nginx/sites-available/default  \n添加：\n\n    41.\t# 下面是我自己写的配置：\n    42.\tserver{\n    43.\t listen 443 ssl;\n    44.\t listen [::]:443 ssl;\n    45.\t root /app/;\n    46.\t index index.html;\n    47.\t server_name laotie666.xyz www.laotie666.xyz;\n    48.\t}\n    \n\n2.申请一个自签证书：\n\n    49.\ticestone@icestone-nb:/app$ openssl req -new -x509 -nodes -out server.crt -keyout server.key\n    50.\t...+.........+...+......+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*.+..+.+...+..+...+.........+...+..................+....+......+..+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*.....+.....+...+....+..+...+...................\n    \n\n查看当前目录：\n\n    51.\ticestone@icestone-nb:/app$ ll\n    52.\t总用量 20\n    53.\tdrwxrwxrwx  3 root     root     4096 11月 11 02:29 ./\n    54.\tdrwxr-xr-x 25 root     root     4096 11月 11 00:39 ../\n    55.\t-rw-------  1 icestone icestone    0 11月 11 02:27 ca.key\n    56.\tlrwxrwxrwx  1 icestone icestone   20 11月 11 02:26 openssl.cnf -> /etc/ssl/openssl.cnf*\n    57.\t-rw-rw-r--  1 icestone icestone 1363 11月 11 02:29 server.crt\n    58.\t-rw-------  1 icestone icestone 1704 11月 11 02:29 server.key\n    \n\ncrt和key文件生成了，将其配置在nginx的配置中：  \n修改/etc/nginx/sites-available/default：  \n在与原来server上修改\n\n    59.\t sserver {\n    60.\t listen       443 ssl;\n    61.\t index index.html index.htm index.nginx-debian.html;\n    62.\t\n    63.\t server_name icestone.art www.icestone.art;\n    64.\t\n    65.\t location ~ \\.php$ {\n    66.\t   fastcgi_split_path_info ^(.+\\.php)(/.+)$;\n    67.\t   fastcgi_pass unix:/run/php-fpm/www.sock;\n    68.\t   fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\n    69.\t   fastcgi_index index.php;\n    70.\t   include fastcgi_params;\n    71.\t }\n    72.\t ssl_certificate      /app/server.crt;\n    73.\t ssl_certificate_key  /app/server.key;\n    74.\t}\n    \n\n这里icestone.art使我们即将使用的域名，域名在、etc/hosts下直接添加并刷新即可，  \n要注意Linux下回环地址是0.0.0.0  \n75\\. https访问：  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/e62ad455f74e4bb78e6a4893a20f8d3e.png)\n\n点查看证书：  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/490b27bf985e4156a1d60d67f472f63c.png)  \n强制访问：  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/e9ee740031e44d65bf2f07e38ce77bc2.png)  \n76\\. 安装php  \nsudo apt install php libapache2-mod-php\n\n    77.\ticestone@icestone-nb:/app$ sudo apt install php-fpm\n    78.\t正在读取软件包列表... 完成\n    79.\t正在分析软件包的依赖关系树... 完成\n    80.\t正在读取状态信息... 完成                 \n    81.\t将会同时安装下列软件：\n    82.\t  php8.1-fpm\n    \n\n注意这里显示安装的是php8.1-fpm，运行检查：  \nsystemctl status php8.1-fpm\n\n    83.\ticestone@icestone-nb:/app$ systemctl status php8.1-fpm\n    84.\t● php8.1-fpm.service - The PHP 8.1 FastCGI Process Manager\n    85.\t     Loaded: loaded (/lib/systemd/system/php8.1-fpm.service; enabled; vendor preset: enabled)\n    \n\nsuccess  \n配置php运行端口和允许端口：  \n修改 /etc/php/8.1/pool.d/www.conf  \n修改下面三个：\n\n    86.\t;下面这个注释掉\n    87.\t;listen = /run/php/php8.1-fpm.sock\n    88.\t;修改：\n    89.\tlisten = localhost:81\n    90.\tlisten.allowed_clients = 127.0.0.1\n    \n\n修改nginx中监听php的端口;  \n修改 /etc/nginx/sites-available/default  \n主要修改80端口和443端口下启动页面，监听php的端口：\n\n    91.\tserver {\n    92.\t listen 80 default_server;\n    93.\t listen [::]:80 default_server;\n    94.\t index index.php index.html index.htm index.nginx-debian.html;\n    95.\t root /app/www/;\n    96.\t server_name icestone.art www.icestone.art _;\n    97.\t location / {\n    98.\t   try_files $uri $uri/ /index.php$is_args$args;\n    99.\t }\n    100.\t location ~ \\.php$ {\n    101.\t   fastcgi_split_path_info ^(.+\\.php)(/.+)$;\n    102.\t   fastcgi_pass localhost:81;\n    103.\t         fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\n    104.\t   fastcgi_index index.php;\n    105.\t   include fastcgi_params;\n    106.\t }\n    107.\t}\n    108.\t\n    109.\tserver {\n    110.\t listen 443 ssl;\n    111.\t index index.php index.html index.htm index.nginx-debian.html;\n    112.\t root /app/www/;\n    113.\t server_name icestone.art www.icestone.art;\n    114.\t location / {\n    115.\t   try_files $uri $uri/ /index.php$is_args$args;\n    116.\t }\n    117.\t location ~ \\.php$ {\n    118.\t   fastcgi_split_path_info ^(.+\\.php)(/.+)$;\n    119.\t   fastcgi_pass localhost:81;\n    120.\t         fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\n    121.\t   fastcgi_index index.php;\n    122.\t   include fastcgi_params;\n    123.\t }\n    124.\t ssl_certificate      /app/server.crt;\n    125.\t ssl_certificate_key  /app/server.key;\n    126.\t}\n    127.\n    \n\nnginx和php重启，访问浏览器端：  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/4da0667f08c4494ebf97102aee97619e.png)",
        "states": "0",
        "description": "这里icestone.art使我们即将使用的域名，域名在、etc/hosts下直接添加并刷新即可，修改 /etc/nginx/sites-available/default。修改 /etc/nginx/sites-available/default。修改 /etc/php/8.1/pool.d/www.conf。要注意Linux下回环地址是0.0.0.0。这里由于使用的ubuntu22.04。修改nginx中监听php的端口;在与原来server上修改。40.\t修改配置文件。",
        "praise": "0",
        "view": "36",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/127838484",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-07-21T03:58:16.000Z",
        "destroyTime": null
    },
    {
        "id": 4,
        "email": "2714351312@qq.com",
        "title": "宝塔部署codeserver，映射外网",
        "content": "遇到的情况：\n\n云服务器上部署了宝塔面板，有时候在ipad上修改一些代码，所以需要跑一个远程ide\n\n为什么要映射：我的服务器上部署的还有其他一些模板项目，用宝塔部署的，不能停，但是ngix一直在监听一些端口，影响codeserver的使用，所以需要在宝塔上映射一下\n\n1.下载codesrever，\n\n这个我也忘了自己下的是哪个版本，查其他的博客吧\n\n2.解压之后：  \n在宝塔面板的网站中，添加通用项目  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/02c8c7841e8c48ffb034af997253be52.png)  \n可执行文件：  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/efa7394268f0406786151b686ab6fec0.png)  \n这里code-server选的是你下载的压缩包，解压后bin目录下的那个文件，勾选并选择即可  \n下面圈起来的自己填写即可：  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/e6967b8a6c3d4f33bdd0e138527d13f2.png)  \n执行命令不需要更改  \n这里绑定一下自己的域名，例如：`code.xxxx.work`，然后提交，  \n关于项目端口，填默认的8080或者填自己更改的项目端口：  \ncode-server的配置文件在：  \n`~/.config/code-server/config.yaml`这个目录下，可以配置你的密码和项目运行端口，默认端口是8080  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/eaeff4a4e7054e07a50b4ed97a434afa.png)\n\n3.映射：  \n再点击这个，开启映射;  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/a6b4e1f6c05942a48d092ddeec00d4b7.png)\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/c2e5c6997fd54bedbcef718afec12b1c.png)  \n这里开启一下即可，访问的话，直接访问你之前填写的域名即可\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/bf64f6f8129544408577139c88ef06bc.png)",
        "states": "0",
        "description": "为什么要映射：我的服务器上部署的还有其他一些模板项目，用宝塔部署的，不能停，但是ngix一直在监听一些端口，影响codeserver的使用，所以需要在宝塔上映射一下。这里code-server选的是你下载的压缩包，解压后bin目录下的那个文件，勾选并选择即可。这个目录下，可以配置你的密码和项目运行端口，默认端口是8080。这里开启一下即可，访问的话，直接访问你之前填写的域名即可。这个我也忘了自己下的是哪个版本，查其他的博客吧。在宝塔面板的网站中，添加通用项目。再点击这个，开启映射;",
        "praise": "0",
        "view": "32",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/127254835",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "1",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-06-07T11:47:20.000Z",
        "destroyTime": null
    },
    {
        "id": 5,
        "email": "2714351312@qq.com",
        "title": "微信小程序_25,自定义tabBar",
        "content": "案例效果;  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/fcda11780abd4adc96d86ec2a5535223.png)\n\n> 在此案例中,用到的主要知识点如下:\n\n*   自定义组件\n*   Vant组件库\n*   Mobx数据共享\n*   组件样式隔离\n*   组件数据监听器\n*   组件的behaviors\n*   Vant样式覆盖\n\n> 实现步骤\n\n自定义tabBar分为3打步骤,分别是:\n\n1.配置信息  \n2.添加tabBar代码文件  \n3.编写tabBar代码\n\n更详细的,请查看[开发者文档](https://developers.weixin.qq.com/miniprogram/dev/framework/ability/custom-tabbar.html)\n\n> 自定义tabBar配置信息:\n\n1.在 app.json 中的 tabBar 项指定 custom 字段，同时其余 tabBar 相关配置也补充完整。  \napp.json文件中配置`\"custom\":\"true\"`\n\n      \"tabBar\": {\n        \"custom\": true,\n    }\n    \n\n所有 tab 页的 json 里需声明 usingComponents 项，也可以在 app.json 全局开启。\n\n    \"tabBar\": {\n        \"custom\": true,\n        \"color\": \"#000000\",\n        \"selectedColor\": \"#000000\",\n        \"backgroundColor\": \"#000000\",\n        \"usingComponents\": {},\n        \n        \"list\": [{\n          \"pagePath\": \"pages/index/index\",\n          \"text\": \"index\",\n          \"iconPath\": \"/images/index.png\",\n          \"selectedIconPath\": \"/images/indexSelected.png\"\n        }]\n      },\n    \n\n此时自定义数组中的list数据不能删\n\n然后在项目的根目录下创建`custom-tab-bar`文件夹:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/08def617f2e14b14b95153b7473c0cf0.png)  \n然后在该文件夹右键,新建组件,输入index即可创建组件:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/2ab0464effbe4ba0a05804c0ab3aeb20.png)  \n然后就可以看到tabbar区域的内容就是这里刚自定义的组件:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/9467fd5932d241dbb9b9c03dea427785.png)\n\n这里tabbar建议使用vant组件,[vant官网](https://vant-contrib.gitee.io/vant/#/zh-CN/tabbar)\n\n使用vant第一步,注册组件,我这里使用的是1.3版本的vant,  \n在app.json中注册(后面两行是新添加的):\n\n      \"usingComponents\": {\n        \"vantButton\": \"@vant/weapp/button/index\",\n        \"my-numbers\": \"/components/numbers/numbers\",\n        \"van-tabbar\": \"@vant/weapp/tabbar/index\",\n        \"van-tabbar-item\": \"@vant/weapp/tabbar-item/index\"\n      },\n    \n\n然后按照文档cv对应的tabbar代码即可\n\n要注意的是,给的模板代码中,可能有一些初始化数据,或是绑定的方法,这些东西也是要cv过来的\n\n例如我cv的wxml代码:\n\n    <view>\n      <van-tabbar active=\"{{ active }}\" bind:change=\"onChange\">\n        <van-tabbar-item icon=\"home-o\">标签</van-tabbar-item>\n        <van-tabbar-item icon=\"search\">标签</van-tabbar-item>\n        <van-tabbar-item icon=\"friends-o\">标签</van-tabbar-item>\n        <van-tabbar-item icon=\"setting-o\">标签</van-tabbar-item>\n      </van-tabbar>\n    </view>\n    \n\n下面的active,onChange就是cv过来的\n\n    // custom-tab-bar/index.js\n    Component({\n      /**\n       * 组件的属性列表\n       */\n      properties: {\n      },\n      /**\n       * 组件的初始数据\n       */\n      data: {\n        active:0\n      },\n      /**\n       * 组件的方法列表\n       */\n      methods: {\n        onChange(event) {\n          // event.detail 的值为当前选中项的索引\n          this.setData({ active: event.detail });\n        },\n      }\n    })\n    \n\n> 根据自己的需求(上面领导的需求)写出想要的效果:\n\n样式:\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/de78b0c62c9045f79e7f001d9011134e.png)  \n例如想要在未选中时,显示自定义图标,选中时,显示自定义的图标\n\n那么此时还是看官方文档,\n\n文档曰:  \n**自定义图标  \n可以通过 slot 自定义图标，其中 icon slot 代表未选中状态下的图标，icon-active slot 代表选中状态下的图标(下面代码是文档示例代码)**\n\n    <van-tabbar active=\"{{ active }}\" bind:change=\"onChange\">\n      <van-tabbar-item info=\"3\">\n        <image\n          slot=\"icon\"\n          src=\"{{ icon.normal }}\"\n          mode=\"aspectFit\"\n          style=\"width: 30px; height: 18px;\"\n        />\n        <image\n          slot=\"icon-active\"\n          src=\"{{ icon.active }}\"\n          mode=\"aspectFit\"\n          style=\"width: 30px; height: 18px;\"\n        />\n        自定义\n      </van-tabbar-item>\n      <van-tabbar-item icon=\"search\">标签</van-tabbar-item>\n      <van-tabbar-item icon=\"setting-o\">标签</van-tabbar-item>\n    </van-tabbar>\n    \n\n所以,这里如果要自定义的话,可以:\n\n    <view>\n      <van-tabbar active=\"{{ active }}\" bind:change=\"onChange\">\n      <van-tabbar-item info=\"3\">\n        <image slot=\"icon\" src=\"/images/index.png\" mode=\"aspectFit\" style=\"width: 30px; height: 18px;\" />\n        <image slot=\"icon-active\" src=\"/images/indexSelected.png\" mode=\"aspectFit\" style=\"width: 30px; height: 18px;\" />\n        首页\n      </van-tabbar-item>\n    \n        <van-tabbar-item icon=\"home-o\">标签</van-tabbar-item>\n        <van-tabbar-item icon=\"search\">标签</van-tabbar-item>\n        <van-tabbar-item icon=\"friends-o\">标签</van-tabbar-item>\n        <van-tabbar-item icon=\"setting-o\">标签</van-tabbar-item>\n      </van-tabbar>\n    </view>\n    \n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/03286b04e5744cc9a40615e886a94384.png)  \ntabbar区域第一个就是刚刚添加的自定义样式  \n那么此时就可以将tabBar中的list添加到data中,然后在页面上使用遍历来渲染出对应的tabBar:\n\njs:\n\n    // custom-tab-bar/index.js\n    Component({\n      /**\n       * 组件的属性列表\n       */\n      properties: {\n    \n      },\n    \n      /**\n       * 组件的初始数据\n       */\n      data: {\n        active:0,\n        \"list\": [\n          {\n          \"pagePath\": \"pages/index/index\",\n          \"text\": \"index\",\n          \"iconPath\": \"/images/index.png\",\n          \"selectedIconPath\": \"/images/indexSelected.png\"\n        }, {\n          \"pagePath\": \"pages/person/person\",\n          \"text\": \"person\",\n          \"iconPath\": \"/images/person.png\",\n          \"selectedIconPath\": \"/images/personSelected.png\"\n        }, {\n          \"pagePath\": \"pages/mynumber/mynumber\",\n          \"text\": \"numberDemo\",\n          \"iconPath\": \"/images/number.png\",\n          \"selectedIconPath\": \"/images/numberSelected.png\"\n        }]\n      },\n    \n      /**\n       * 组件的方法列表\n       */\n      methods: {\n        onChange(event) {\n          // event.detail 的值为当前选中项的索引\n          this.setData({ active: event.detail });\n        },\n      }\n    })\n    \n\nwxml:\n\n    <view>\n      <van-tabbar active=\"{{ active }}\" bind:change=\"onChange\">\n    \n      <van-tabbar-item wx:for=\"{{list}}\" wx:key=\"index\">\n        <image slot=\"icon\" src=\"{{item.iconPath}}\" mode=\"aspectFit\" style=\"width: 30px; height: 18px;\" />\n        <image slot=\"icon-active\" src=\"{{item.selectedIconPath}}\" mode=\"aspectFit\" style=\"width: 30px; height: 18px;\" />\n        {{item.text}}\n      </van-tabbar-item>\n      </van-tabbar>\n    </view>\n    \n\n效果:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/a17d93a7f44e42e3948db373ece6fa02.png)  \n这里在wxml中可以直接修改icon尺寸的\n\n> 如何渲染徽标以及美化徽标的样式:\n\n在 `<van-tabbar-item wx:for=\"{{list}}\" wx:key=\"index\" >`标签内添加`info=\"2\"`即可:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/9f696618a8b04af99b187515b396c0cc.png)  \n美化:\n\n添加徽标之后,徽标其实是溢出tabBar的,所以此时需要修改icon和底部文字的距离,而这里是需要修改margin-bottom\n\n这里需要使用样式覆盖,将需要的样式类名写在css文件中,在js中开启vant的样式覆盖,否则自定义样式不会生效:\n\n      options:{\n        \"styleIsolation\": \"shared\"\n      },\n    \n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/3b8c4d87b83f40958b57ca8d09fc1e27.png)  \n这里我修改的样式:\n\n    .van-tabbar-item__icon{\n      --tabbar-item-margin-bottom:0;\n    }\n    \n\n> 按需为tabBar的item项设置徽标数值\n\n对于有的item需要渲染info,有的则不需要,可以在data节点中定义info,并在渲染时使用三元表达式来判断`{{item.info? item.info : ''}}`:  \nwxml:\n\n    <view>\n      <van-tabbar active=\"{{ active }}\" bind:change=\"onChange\">\n      <van-tabbar-item wx:for=\"{{list}}\" wx:key=\"index\" info=\"{{item.info? item.info : ''}}\">\n        <image slot=\"icon\" src=\"{{item.iconPath}}\" mode=\"aspectFit\" style=\"width: 40px; height: 20px;\" />\n        <image slot=\"icon-active\" src=\"{{item.selectedIconPath}}\" mode=\"aspectFit\" style=\"width: 40px; height: 20px;\" />\n        {{item.text}}\n      </van-tabbar-item>\n      </van-tabbar>\n    </view>\n    \n\njs:\n\n    // custom-tab-bar/index.js\n    Component({\n      /**\n       * 组件的初始数据\n       */\n      data: {\n        active:0,\n        \"list\": [\n          {\n          \"pagePath\": \"pages/index/index\",\n          \"text\": \"首页\",\n          \"iconPath\": \"/images/index.png\",\n          \"selectedIconPath\": \"/images/indexSelected.png\",\n          \"info\":2\n        }, {\n          \"pagePath\": \"pages/person/person\",\n          \"text\": \"个人\",\n          \"iconPath\": \"/images/person.png\",\n          \"selectedIconPath\": \"/images/personSelected.png\"\n        }, {\n          \"pagePath\": \"pages/mynumber/mynumber\",\n          \"text\": \"nums\",\n          \"iconPath\": \"/images/number.png\",\n          \"selectedIconPath\": \"/images/numberSelected.png\"\n        }]\n      }\n    })\n    \n\n但是将徽标数字写为固定值显然是不合适的,那么此时就可以引用到store中的数据,  \n关于tabbar的绑定store数据\n\n> tabBarr绑定stroe.js:\n\n1.导入,在tabBar的js文件中导入:\n\n    import {storeBindingsBehavior} from 'mobx-miniprogram-bindings'\n    import {store} from '../store/store'\n    \n\n2.tabBar的js文件中添加配置:\n\n    \n    Component({\n      behaviors:[storeBindingsBehavior],\n    })\n    \n\n3.定义对象:  \n下面的`storeBindings`就是需要配置的对象\n\n    Component({\n      behaviors:[storeBindingsBehavior],\n      storeBindings:{\n        store,\n        fields:{\n          sum:'sum'\n        },\n        actions:[\n        ]\n      },\n      options:{\n        \"styleIsolation\": \"shared\"\n      },\n      /**\n       * 组件的属性列表\n       */\n      properties: {\n    \n      },\n      /**\n       * 组件的初始数据\n       */\n      data: {\n        active:0,\n        \"list\": [\n          {\n          \"pagePath\": \"pages/index/index\",\n          \"text\": \"首页\",\n          \"iconPath\": \"/images/index.png\",\n          \"selectedIconPath\": \"/images/indexSelected.png\",\n          \"info\":2\n        }, {\n          \"pagePath\": \"pages/person/person\",\n          \"text\": \"个人\",\n          \"iconPath\": \"/images/person.png\",\n          \"selectedIconPath\": \"/images/personSelected.png\"\n        }, {\n          \"pagePath\": \"pages/mynumber/mynumber\",\n          \"text\": \"nums\",\n          \"iconPath\": \"/images/number.png\",\n          \"selectedIconPath\": \"/images/numberSelected.png\"\n        }]\n      },\n    \n      /**\n       * 组件的方法列表\n       */\n      methods: {\n        onChange(event) {\n          // event.detail 的值为当前选中项的索引\n          this.setData({ active: event.detail });\n        },\n      }\n    })\n    \n\n而这里可以使用数据监听器,来监听sum的变化,变化之后立即更改info的值  \n与`storeBindings`节点平级添加监听器:\n\n      observers: {\n        'sum': function (val) {\n          // console.log(val);\n          this.setData({\n            'list[1].info': val\n          })\n        }\n      },\n    \n\n这里`list[1].info`就是对应item的徽标数值  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/76fdaff606594ebeaab3d4fb47708d63.png)\n\n> 点击之后切换不同的页面;\n\n根据上面的步骤,点击不同的tab是不会切换的  \n而此时,先要完成切换,监听它的点击方法即可,点击事件中,执行`wx.switchTab`,切换到对应的page,例如:\n\n    // custom-tab-bar/index.js\n    import {\n      storeBindingsBehavior\n    } from 'mobx-miniprogram-bindings'\n    import {\n      store\n    } from '../store/store'\n    Component({\n      behaviors: [storeBindingsBehavior],\n      storeBindings: {\n        store,\n        fields: {\n          sum: 'sum'\n        },\n        actions: []\n      },\n      observers: {\n        'sum': function (val) {\n          // console.log(val);\n          this.setData({\n            'list[1].info': val\n          })\n        }\n      },\n      options: {\n        \"styleIsolation\": \"shared\"\n      },\n      /**\n       * 组件的属性列表\n       */\n      properties: {\n      },\n      /**\n       * 组件的初始数据\n       */\n      data: {\n        active: 0,\n        \"list\": [{\n          \"pagePath\": \"/pages/index/index\",\n          \"text\": \"首页\",\n          \"iconPath\": \"/images/index.png\",\n          \"selectedIconPath\": \"/images/indexSelected.png\",\n          \"info\": 2\n        }, {\n          \"pagePath\": \"/pages/person/person\",\n          \"text\": \"个人\",\n          \"iconPath\": \"/images/person.png\",\n          \"selectedIconPath\": \"/images/personSelected.png\"\n        }, {\n          \"pagePath\": \"/pages/mynumber/mynumber\",\n          \"text\": \"nums\",\n          \"iconPath\": \"/images/number.png\",\n          \"selectedIconPath\": \"/images/numberSelected.png\"\n        }]\n      },\n      /**\n       * 组件的方法列表\n       */\n      methods: {\n        onChange(event) {\n          // event.detail 的值为当前选中项的索引\n          this.setData({\n            active: event.detail\n          });\n          wx.switchTab({\n            url: this.data.list[event.detail].pagePath,\n          });\n        },\n      }\n    })\n    \n\n上面的`onChange`就是监听事件,里面的`event.detail`是当前tab的index,通过点击不同的tab,传入不同的index,再通过`wx.switchTab`切换不同的page\n\n**注意:这里的`this.data.list[event.detail].pagePath`改路径必须以`/`开头,具体可以参考`list`中的数组**\n\n> 而此时你点击可能会发现点击时,页面是切换了但是激活的tabBar不对\n\n可以将TabBar的active变量定义在store中:\n\nstore.js:\n\n    // 在这个js文件中专门用来创建store实例对象\n    import {\n      action,\n      observable\n    } from 'mobx-miniprogram'\n    export const store = observable({\n      // 数据字段：\n      num1: 123,\n      num2: 321,\n      step: 2,\n      sum: 0,\n      activeTabBarIndex: 0,\n      // 计算属性,必须加标识符:get(表示当前值是只读的,不能获取当前值):\n      get sum() {\n        return this.num1 + this.num2\n      },\n      // actions函数,用来修改stroe中的数据\n      updateNum1: action(function (step) {\n        this.num1 += step\n      }),\n      updateNum2: action(function (step) {\n        this.num2 += step\n      }),\n      updateActiveTabBarIndex: action(function (index) {\n        this.activeTabBarIndex = index\n      }),\n    })\n    \n\n这里定义了`activeTabBarIndex`作为当前激活的index,并有`updateActiveTabBarIndex`为index更新\n\ntabBar的js:\n\n    // custom-tab-bar/index.js\n    import {\n      storeBindingsBehavior\n    } from 'mobx-miniprogram-bindings'\n    import {\n      store\n    } from '../store/store'\n    Component({\n      behaviors: [storeBindingsBehavior],\n      storeBindings: {\n        store,\n        fields: {\n          sum: 'sum',\n          active: 'activeTabBarIndex'\n        },\n        actions: {\n          updateActive: 'updateActiveTabBarIndex'\n        }\n      },\n      observers: {\n        'sum': function (val) {\n          // console.log(val);\n          this.setData({\n            'list[1].info': val\n          })\n        }\n      },\n      options: {\n        \"styleIsolation\": \"shared\"\n      },\n      /**\n       * 组件的属性列表\n       */\n      properties: {\n      },\n      /**\n       * 组件的初始数据\n       */\n      data: {\n        \"list\": [{\n          \"pagePath\": \"/pages/index/index\",\n          \"text\": \"首页\",\n          \"iconPath\": \"/images/index.png\",\n          \"selectedIconPath\": \"/images/indexSelected.png\",\n          \"info\": 2\n        }, {\n          \"pagePath\": \"/pages/person/person\",\n          \"text\": \"个人\",\n          \"iconPath\": \"/images/person.png\",\n          \"selectedIconPath\": \"/images/personSelected.png\"\n        }, {\n          \"pagePath\": \"/pages/mynumber/mynumber\",\n          \"text\": \"nums\",\n          \"iconPath\": \"/images/number.png\",\n          \"selectedIconPath\": \"/images/numberSelected.png\"\n        }]\n      },\n      /**\n       * 组件的方法列表\n       */\n      methods: {\n        onChange(event) {\n          // event.detail 的值为当前选中项的索引\n          // this.setData({active: event.detail});\n          wx.switchTab({\n            url: this.data.list[event.detail].pagePath,\n          });\n          this.updateActive(event.detail)\n        },\n      }\n    })\n    \n\n这里引入store中的`activeTabBarIndex`和`updateActiveTabBarIndex`,在监听tabBar中item的点击时,更新index\n\ntabBar的wxml:\n\n    <view>\n      <van-tabbar active=\"{{active}}\" bind:change=\"onChange\">\n      <van-tabbar-item wx:for=\"{{list}}\" wx:key=\"index\" info=\"{{item.info? item.info : ''}}\">\n        <image slot=\"icon\" src=\"{{item.iconPath}}\" mode=\"aspectFit\" style=\"width: 40px; height: 20px;\" />\n        <image slot=\"icon-active\" src=\"{{item.selectedIconPath}}\" mode=\"aspectFit\" style=\"width: 40px; height: 20px;\" />\n        {{item.text}}\n      </van-tabbar-item>\n      </van-tabbar>\n    </view>\n    \n\n> 更改激活样式的文字颜色：\n\n在`van-tabbar`中修改`active-color=\"#07c160\"`:\n\n    <view>\n      <van-tabbar active=\"{{active}}\" bind:change=\"onChange\" active-color=\"#07c160\">\n        <van-tabbar-item wx:for=\"{{list}}\" wx:key=\"index\" info=\"{{item.info? item.info : ''}}\">\n          <image slot=\"icon\" src=\"{{item.iconPath}}\" mode=\"aspectFit\" style=\"width: 40px; height: 20px;\" />\n          <image slot=\"icon-active\" src=\"{{item.selectedIconPath}}\" mode=\"aspectFit\" style=\"width: 40px; height: 20px;\" />\n          {{item.text}}\n        </van-tabbar-item>\n      </van-tabbar>\n    </view>",
        "states": "0",
        "description": "添加徽标之后,徽标其实是溢出tabBar的,所以此时需要修改icon和底部文字的距离,而这里是需要修改margin-bottom。对于有的item需要渲染info,有的则不需要,可以在data节点中定义info,并在渲染时使用三元表达式来判断。要注意的是,给的模板代码中,可能有一些初始化数据,或是绑定的方法,这些东西也是要cv过来的。是当前tab的index,通过点击不同的tab,传入不同的index,再通过。而此时,先要完成切换,监听它的点击方法即可,点击事件中,执行。",
        "praise": "0",
        "view": "24",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/126920723",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T09:43:00.000Z",
        "destroyTime": null
    },
    {
        "id": 6,
        "email": "2714351312@qq.com",
        "title": "微信小程序_24,分包预下载",
        "content": "> 什么是分包预下载:\n\n分包预下载指的是:在进入小程序的某个页面时,由框架自动预下载可能需要的分包,从而提升进入后续分包页面时的启动速度\n\n> 配置分包预下载:\n\n预下载分包的行为,会在进入指定页面时触发,在app.json中,使用preloadRule节点定义分包的预下载规则,示例代码如下:  \n在app.json中配置,该节点与`pages`节点平级,\n\n      \"preloadRule\": {\n      //进入下面的页面时执行{}中的配置\n        \"pages/person/person\": {\n        //预加载的页面,这里写的是分包的别名\n          \"packages\": [\"p1\"],\n          //指定在什么网络类型下执行预加载,可以选择 wifi 或是 all ,注意这里没有4g的选项,毕竟加载费流量\n          \"network\": \"all\"\n        }\n      }\n    \n\n> 分包预下载的限制:\n\n同一个分包中的页面享有共同的预下载大小限制2M,例如:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/3613e6cdda0f4d9a9fe0d963259f712c.png)  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/19b1da6b2a04431a9be9cd67ad187ad6.png)",
        "states": "0",
        "description": "分包预下载指的是:在进入小程序的某个页面时,由框架自动预下载可能需要的分包,从而提升进入后续分包页面时的启动速度。在app.json中配置,该节点与。",
        "praise": "0",
        "view": "1",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/126920311",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 7,
        "email": "2714351312@qq.com",
        "title": "微信小程序_23,分包",
        "content": "> 什么是分包:\n\n分包指的是把一个完整的小程序项目,按照需求划分为不同的子包,在构建时,打包成不同的分包,用户在使用时按需进行加载\n\n> 分包的好处:\n\n*   可以优化小程序首次启动的下载时间\n*   在多团队共同开发时可以更好的解耦协作\n\n> 分包前后项目的构成：\n\n分包后小程序项目由1个主包和多个分包资源组成:\n\n*   主包:一般只包含项目的启动页面和TabBar页面,以及所有分包都需要用到的一些公共资源\n*   分包:只包含和当前分包有关的页面和私有资源\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/9bd307cd883f4b0f9f6bbc470aa8799c.png)\n\n> 分包的加载规则:\n\n1.在小程序启动时,默认会下载主包并启动主包内页面\n\n*   tabBar页面需要放到主包中\n\n2.当用户进入分包内某个页面时,客户端会把对应分包下载来,下载完成之后再进行展示\n\n*   非tabBar页面可以按照功能的不同,划分为不同的分包之后,进行按需下载\n\n目前,小程序分包的大小有以下两个限制:\n\n*   整个小程序所有分包大小不超过16M(主包+所有分包)\n*   单个分包/主包大小不能超过2M\n\n> 使用分包\n\n1.配置方法:\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2dcb6e6c6d23498298e865633026172c.png)  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/5586ac3165084219b4548c12cb6a12be.png)  \n同时,还要在app.json的subpackages节点中声明分包的结构\n\n配置自己的分包:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/b3e448eeef0645c384f06703faf721bb.png)  \n在package.json中写下分包的配置,保存后会自动创建  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/b3d1e095ee384f9092ae181e768acf35.png)  \n代码:\n\n    \"subpackages\": [{\n        \"root\": \"pkgA\",\n        \"pages\": [\n          \"pages/cat/cat\",\n          \"pages/dog/dog\"\n        ]\n      },{\n        \"root\": \"pkgB\",\n        \"pages\": [\n          \"pages/apple/apple\"\n        ]\n      }],\n    \n\n在上面示例中,`root`指定的是分包的所在文件夹,`pages`指定的是该分包下的页面\n\n> 为分包起别名:\n\n在app.json中`subpackages`下的对象中使用name节点起别名:\n\n     \"subpackages\": [{\n        \"root\": \"pkgA\",\n        \"name\":\"p1\",\n        \"pages\": [\n          \"pages/cat/cat\",\n          \"pages/dog/dog\"\n        ]\n      },{\n        \"root\": \"pkgB\",\n        \"name\":\"p2\",\n        \"pages\": [\n          \"pages/apple/apple\"\n        ]\n      }],\n    \n\n> 如何知道每个分包的体积:\n\n详情里面可以看到  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/8a4ecae9ff3c4505a73ec803ff922238.png)\n\n> 打包原则:\n\n1.小程序会按subpackages的配置进行分包,subpackages之外的目录将打包到主包中  \n2.主包也可以用自己的pages(即最外层的pages字段)  \n3.tabBar页面必须在主包内  \n4.分包之间不能互相嵌套\n\n> 引用原则:\n\n1.主包无法引用分包内的私有资源  \n2.分包之间不能互相引用私有资源  \n3.分包可以引用主包内的公共资源\n\n> 独立分包:\n\n独立分包本质上也是主包,只不过它比较特殊,可以独立于主包和其他分包而单独运行\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/60480bf72d054083850deb5e99de12b7.png)\n\n独立分包和普通分包的区别:是否依赖于主包才能运行\n\n*   普通分包必须依赖于主包才能运行\n*   独立分包可以在不下载主包的情况下,独立运行\n\n> 独立分包的应用场景:\n\n开发者可以按需,将某些具有一定功能性的页面配置到独立分包中,原因如下:\n\n*   当小程序从普通的分包页面启动时,需要首先下载主包\n*   而独立分包不依赖主包即可运行.可以很大程度上提升分包页面的启动速度\n\n注意:一个小程序可以有多个独立分包\n\n独立分包的配置方法:\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/aa7a534751d949008fe9a950bfcd6b04.png)  \n独立分包和普通分包的区别就在于它有没有`\"independent\": true`节点,例如下面的pkgB就是一耳光独立分包:\n\n      \"subpackages\": [{\n        \"root\": \"pkgA\",\n        \"name\":\"p1\",\n        \"pages\": [\n          \"pages/cat/cat\",\n          \"pages/dog/dog\"\n        ]\n      },{\n        \"root\": \"pkgB\",\n        \"name\":\"p2\",\n        \"pages\": [\n          \"pages/apple/apple\"\n        ],\n        \"independent\": true\n      }],\n    \n\n> 独立分包的引用原则:\n\n独立分包和普通分包以及主包之间,是相互隔绝的,不能相互引用彼此的资源,例如:\n\n1.主包无法引用独立分包内的私有资源  \n2.独立分包之间,不能相互引用  \n3.独立分包和普通分包之间,不能相互引用私有资源  \n4.特别注意:独立分包中不能引用主包内的公共资源",
        "states": "0",
        "description": "分包指的是把一个完整的小程序项目,按照需求划分为不同的子包,在构建时,打包成不同的分包,用户在使用时按需进行加载。2.当用户进入分包内某个页面时,客户端会把对应分包下载来,下载完成之后再进行展示。同时,还要在app.json的subpackages节点中声明分包的结构。在package.json中写下分包的配置,保存后会自动创建。1.在小程序启动时,默认会下载主包并启动主包内页面。指定的是分包的所在文件夹,指定的是该分包下的页面。在app.json中。",
        "praise": "0",
        "view": "1",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/126841814",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-05-02T05:34:10.000Z",
        "destroyTime": null
    },
    {
        "id": 8,
        "email": "2714351312@qq.com",
        "title": "微信小程序_21,使用npm包,api promise化",
        "content": "### 基于回调函数的异步api的缺点:\n\n默认情况下,小程序官方提供的异步api都是基于回调函数实现的,例如,网络请求的API需要按照如下的方式调用:\n\n        wx.request({\n          url: 'url',\n          data:{},\n          success:()=>{},//请求成功的回调\n          fail:()=>{},//请求失败的回调函数\n          complete:()=>{}//请求完成的回调函数\n        })\n    \n\n#### 实现api promise化:\n\n在小程序中,实现api promise化主要依赖于miniprograme-api-promise这个第三方包,它的安装和使用步骤如下:\n\n    npm install --save miniprogram-api-promise@1.0.4\n    \n\n> 注意,小程序是无法直接读取node\\_modules目录下的包文件的,所以需要构建,构建npm会把引入的包copy到`miniprogram_npm`目录下,在你新引入包2时,最好将原来的`miniprogram_npm`给删除:\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2355dc3eea7c4772aee2781336d66144.png)  \n在小程序入口文件中(app.js),只需调用一次promisifyAll()方法,即可实现异步api的promise化\n\n    import {promisifyAll} from 'miniprogram-api-promise'\n    //定义一个空对象\n    const wxp=wx.p={}\n    // promise all wx's api\n    //对象是引用数据类型,所以指向的是同一个对象\n    promisifyAll(wx,wxp)\n    \n\n##### 调用promise化之后的异步API\n\n      async getinfo () {\n        const {\n          data: res\n        } = await wx.p.request({\n          method:'GET',\n          url: 'https://www.escook.cn/api/get',\n          data: {\n            name: 'zs',\n            age: 30\n          }\n        })\n        console.log(res);\n      },",
        "states": "0",
        "description": "在小程序入口文件中(app.js),只需调用一次promisifyAll()方法,即可实现异步api的promise化。注意,小程序是无法直接读取node_modules目录下的包文件的,所以需要构建,构建npm会把引入的包copy到。目录下,在你新引入包2时,最好将原来的。",
        "praise": "0",
        "view": "6",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/126791414",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 9,
        "email": "2714351312@qq.com",
        "title": "微信小程序_22,全局数据共享",
        "content": "> 什么是全局数据共享:\n\n全局数据共享(又叫做:状态管理),是为了解决组件之间数据共享的问题  \n开发中常用的全局数据共享方案有:Vuex,Redux,Mobx等\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8f22df59fca44fffab1a9cf1c910ad9a.png)\n\n> 小程序中的全局数据共享方案:\n\n在小程序中,可使用mobx-miniprogram配合mobx-miniprogram-bindings实现全局数据共享,其中:\n\n*   `mobx-miniprogram`用来创建Store示例对象\n*   `mobx-miniprogram-bindings`用来把Store中的共享数据或方法,绑定到组件或页面中使用\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/19786cb2a7fb4a688e26da6c65888a4e.png)\n\n> 安装Mobx相关的包:\n\n    npm i --save mobx-miniprogram@4.13.2 mobx-miniprogram-bindings@1.2.1\n    \n\n注意:安装完相关的包之后,记得删除miniprogram\\_npm目录后.重新构建npm\n\n> 使用:\n\n在项目目录下创建stroe文件夹,并创建对应的js文件:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/6a0de692eb4d47dc9e620a0f5bac4a39.png)  \n在js文件中导出store:\n\n    // 在这个js文件中专门用来创建store实例对象\n    import {observable} from 'mobx-miniprogram'\n    \n    export const store=observable({})\n    \n\n> 创建Mobx的stroe实例:\n\n    // 在这个js文件中专门用来创建store实例对象\n    import {\n      action,\n      observable\n    } from 'mobx-miniprogram'\n    \n    export const store = observable({\n      // 数据字段：\n      num1: 123,\n      num2: 321,\n      step: 2,\n      // 计算属性：\n      get sum() {\n        return this.num1 + this.num2\n      },\n      // actions\n      updateNum1: action(function () {\n        this.num1 += step\n      }),\n      updateNum2: action(function () {\n        this.num2 += step\n      }),\n    })\n    \n\n> 将store中的成员绑定到页面中:\n\n在页面的js中:\n\n    //页面的监听js文件\n    import {\n      createStoreBindings\n    } from 'mobx-miniprogram-bindings'\n    import {\n      store\n    } from '../../store/store'\n    \n    \n    Page({\n      onLoad: function () {\n        // 监听页面加载\n        this.storeBindings = createStoreBindings(this, {\n          store,\n          fields: ['num1', 'num2', 'sum'],\n          actions: ['updateNum1', 'updateNum2']\n        })\n      },\n      onUnload: function () {\n        // 生命周期函数,监听页面卸载\n        this.storeBindings.destroyStoreBindings()\n      },\n    })\n    \n\n此时可以看下数据是否已经计算:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/a0bb846b85ab400db18a2a593c7ca984.png)  \n将store中的fun绑定到页面中:\n\n    <view>{{num1}}+{{num2}}={{sum}}</view>\n    <vantButton type=\"primary\" bindtap=\"btnHandler1\" data-step=\"{{1}}\">num1+1</vantButton>\n    <vantButton type=\"primary\" bindtap=\"btnHandler1\" data-step=\"{{-1}}\">num1-1</vantButton>\n    \n\n    // index.js\n    // 获取应用实例\n    const app = getApp()\n    //页面的监听js文件\n    import {\n      createStoreBindings\n    } from 'mobx-miniprogram-bindings'\n    import {\n      store\n    } from '../../store/store'\n    \n    Page({\n      onLoad: function () {\n        // 监听页面加载\n        this.storeBindings = createStoreBindings(this, {\n          store,\n          fields: ['num1', 'num2', 'sum'],\n          actions: ['updateNum1', 'updateNum2']\n        })\n      },\n      btnHandler1(e) {\n        this.updateNum1(e.target.dataset.step)\n      },\n      onUnload: function () {\n        // 生命周期函数,监听页面卸载\n        this.storeBindings.destroyStoreBindings()\n      },\n    })\n    \n\nstore.js中有不同的写法,示例可以查看下面:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/8ef29f4d85a8435b97d77679e255f3bc.png)  \n在组件中引入store时,可以映射store中对应的对象或者变量名,如下面的`behaviors`,`storeBindings`和`actions`:\n\n    // pages/mynumber/mynumber.js\n    import {\n      storeBindingsBehavior\n    } from \"mobx-miniprogram-bindings\"\n    import {\n      store\n    } from \"../../store/store\"\n    Component({\n      behaviors: [storeBindingsBehavior],\n      storeBindings:{\n        // 数据源\n        store,\n        fields:{\n          // 映射名:'组件中的变量名',可以简写\n          num1:'num1',\n          num2:'num2',\n          sum:'sum'\n        },\n        //store中的function需要在actions下映射,这里也可以简写的\n        actions:{\n            updateNum1:'updateNum1'\n        }\n      },\n    })",
        "states": "0",
        "description": "注意:安装完相关的包之后,记得删除miniprogram_npm目录后.重新构建npm。在组件中引入store时,可以映射store中对应的对象或者变量名,如下面的。全局数据共享(又叫做:状态管理),是为了解决组件之间数据共享的问题。开发中常用的全局数据共享方案有:Vuex,Redux,Mobx等。",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/126805662",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "1",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 10,
        "email": "2714351312@qq.com",
        "title": "微信小程序_20,使用第三方npm包",
        "content": "> 小程序对npm的支持和限制:\n\n目前下程序中已经支持使用npm安装第三方包,从而提高小程序的开发效率,但是,小程序中使用npm包有如下三个限制:\n\n1.不支持依赖于node.js内置库的包  \n2.不支持依赖于浏览器内置对象的包  \n3.不支持依赖于c++插件的包\n\n总结:虽然npm上的包千千万,但是能供小程序使用的包却’为数不多’\n\n> 什么是Vant Weapp\n\nVant Weapp是有赞前端团队开源的一套小程序UI组件库,助理开发者快速搭建小程序应用,他所使用的是MIT开源协议,对商业使用比较友好\n\n> 安装Vant组件库:\n\n在小程序项目中,安装Vant组件库主要分为如下3步:  \n1.通过npm安装(建议制定版本@1.3.3)  \n2.构建npm包  \n3.修改app.json\n\n在有package.json的目录中安装,如果没有package.json,那么初始化一下(`npm init -y`)  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/b01a4bb017fa4d728a339b78b204e788.png)\n\n    npm i @vant/weapp@1.3.3 -S --production\n    \n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/3c34e3bb39ae4130ba61148bd7c6e995.png)\n\n2.构建npm:\n\n在微信开发者工具->工具->构建npm\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/7ab9841ca8b3404c93edf2c3159e3e9b.png)\n\n3.关闭小程序默认样式:\n\n把小程序配置中的style给去除\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/60fc23012fb44522ade74253116a4d22.png)\n\n> 使用Vant组件库:\n\n安装完Vant之后,可以在app.json的usingComponents节点引入需要的组件,即可在wxml中直接使用组件,示例代码如下:  \napp.json中引入组件:\n\n      \"usingComponents\": {\n        \"vantButton\":\"@vant/weapp/button/index\"\n      }\n    \n\n页面中使用:\n\n    <!--页面的.wxml结构-->\n    <vantButton type=\"primary\">这是一个按钮</vantButton>\n    \n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/f5d4874b393a46478d0ec58d37fb436d.png)\n\n> 定制全局主题样式:\n\nVant Weapp使用css变量来实现定制主题,关于css变量的基本使用,请参考MDN文档:  \n如下面两个按钮,第二个太红了,想要修改它的颜色:\n\n    <vantButton round  type=\"primary\">这是一个按钮</vantButton>\n    <vantButton round  type=\"danger\">这是一个按钮</vantButton>\n    \n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/5570539844c04a238dcea95ca538f9be.png)  \n那么就需要修改样式:\n\n在app.wxss中,写入css变量,即可对全局生效,需要写在wxss中的page节点下:\n\n    page {\n      /* 定制警告按钮的背景颜色和边框颜色 */\n      --button-danger-background-color: rgb(240, 128, 128);\n      --button-danger-border-color: rgb(0, 0, 0);\n    }\n    \n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/654ac17091864c22bda3ff379879eb27.png)  \n**为什么要使用page节点:**  \n为元素定义css变量时,需要为元素的根节点定义,而page就是小程序的根节点\n\n**为什么定义的变量名是这个:**  \n各个元素的变量官方提供的有变量名",
        "states": "0",
        "description": "Vant Weapp是有赞前端团队开源的一套小程序UI组件库,助理开发者快速搭建小程序应用,他所使用的是MIT开源协议,对商业使用比较友好。在有package.json的目录中安装,如果没有package.json,那么初始化一下(为元素定义css变量时,需要为元素的根节点定义,而page就是小程序的根节点。总结:虽然npm上的包千千万,但是能供小程序使用的包却’为数不多’1.不支持依赖于node.js内置库的包。把小程序配置中的style给去除。各个元素的变量官方提供的有变量名。",
        "praise": "0",
        "view": "4",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/125902408",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 11,
        "email": "2714351312@qq.com",
        "title": "移动端适配,华为浏览器底色无法正常显示",
        "content": null,
        "states": "0",
        "description": "第一个是不显示背景色的,第二个是正常样式,这里是只有在手机端的华为浏览器出问题。解决看看代码中颜色的值写的是几个f,我写的是。",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/126079747",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 12,
        "email": "2714351312@qq.com",
        "title": "css自定义属性",
        "content": null,
        "states": "0",
        "description": "要注意,定义这个自定义变量的所属,是限制该变量的作用范围,还是很方便的,虽然我一般不用css,只用less。",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/125903083",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 13,
        "email": "2714351312@qq.com",
        "title": "微信小程序_19,自定义组件-behaviors",
        "content": "> 什么是behaviors:\n\nbehaviors是小程序中,用于实现组件间代码共享的特性,类似于vue的mixins\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/35bdecb9cf6a4b20a7c27d1056474dcc.png)\n\n> behaviors的工作方式\n\n每个behaviors可以包含一组属性,数据,生命周期函数和方法,组件引用它时,它的属性,数据和方法会被合并到组件中\n\n每个组件可以引用多个behavior,behavior也可以引用其他的behavior\n\n> 创建behavior:\n\n调用behavior(Object object)方法即可一个共享的behavior实例对象,供所有的组件使用:  \n在下面创建对应文件夹和js文件:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/735e87e67b734b128589822034867395.png)\n\n    module.exports = Behavior({\n      // 私有数据节点\n      data: {},\n      // 属性节点\n      properties: {},\n      // 事件处理函数和自定义方法节点\n      methods: {}\n    })\n    \n\n> 导入并使用behaviors:\n\n在组件中,使用require()方法导入需要的behavior,挂载后即可访问behavior中的数据或方法,示例代码如下:\n\n    // components/myTest1/myTest1.js\n    const myBehavior = require('../../behaviors/myBehavior1')\n    \n    Component({\n      behaviors: [myBehavior],\n    })\n    \n\nbehaviors挂载时,传入的是数组\n\n> 使用：\n\n例如这里在behavior中定义了一个data:\n\n    module.exports = Behavior({\n      // 私有数据节点\n      data: {\n        username: 'zs'\n      },\n      // 属性节点\n      properties: {},\n      // 事件处理函数和自定义方法节点\n      methods: {}\n    })\n    \n\n在引用了该behavior的组件的wxml中可以直接使用:\n\n    <text>\n      behaviors共享数据:{{username}}\n    </text>\n    \n\n> behavior中所有可用节点:\n\n可用的节点\n\n类型\n\n是否必填\n\n描述\n\nproperties\n\nObject Map\n\n否\n\n通组件的属性\n\ndata\n\nObject\n\n否\n\n同组件的数据\n\nmethods\n\nObject\n\n否\n\n同自定义组件的方法\n\nbehaviors\n\nString Array\n\n否\n\n引入其它的behavior\n\ncreated\n\nFunction\n\n否\n\n生命周期函���\n\nattached\n\nFunction\n\n否\n\n生命周期函数\n\nready\n\nFunction\n\n否\n\n生命周期函数\n\nmoved\n\nFunction\n\n否\n\n生命周期函数\n\ndetached\n\nFunction\n\n否\n\n生命周期函数\n\n其中最常用的有:`properties`,`data`,`methods`,`behaviors`\n\n> behaviors中同名字段的覆盖和组合规则:\n\n组件和它引用的behavior中可以包含同名的字段,此时可以参考如下3种同名时的处理规则:\n\n1.同名的数据字段(data)  \n2.同名的属性(properties)或方法(methods)  \n3.同名的生命周期函数\n\n关于详细的覆盖和组合规则,查看微信官方文档\n\n比如在组件的data节点定义一个username为ls,在behavior的data中也定义一个username为ls,那么此时它会优先使用组件中的data",
        "states": "0",
        "description": "比如在组件的data节点定义一个username为ls,在behavior的data中也定义一个username为ls,那么此时它会优先使用组件中的data。每个behaviors可以包含一组属性,数据,生命周期函数和方法,组件引用它时,它的属性,数据和方法会被合并到组件中。behaviors是小程序中,用于实现组件间代码共享的特性,类似于vue的mixins。每个组件可以引用多个behavior,behavior也可以引用其他的behavior。behaviors挂载时,传入的是数组。...",
        "praise": "0",
        "view": "1",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/125861802",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T09:49:13.000Z",
        "destroyTime": null
    },
    {
        "id": 14,
        "email": "2714351312@qq.com",
        "title": "微信小程序_18,父子组件之间的通信",
        "content": "> 父子组件之间通信的三种方式:\n\n1.属性绑定:  \n\\*用于父组件向子组件指定属性设置数据，仅能设置json兼容的数据\n\n2.事件绑定:\n\n*   用于子组件向父组件传递数据,可以传递任意数据\n\n3.获取组件实例:\n\n*   父组件还可以通过this.selectComponent()获取子组件实例对象\n*   这样就可以直接访问子组件的任意数据和方法\n\n* * *\n\n> 属性绑定\n\n属性绑定用于实现父向子传值,而且只能传递普通类型的数据,无法将方法传递给子组件,父组件的示例代码如下:\n\n父组件WXML中\n\n    <myTest1 count=\"{{count}}\">\n    </myTest1>\n    \n\n父组件的js中:\n\n    Page({\n      data: {\n        count: 0\n      }\n    })\n    \n\n子组件的WXML:\n\n    <text>\n    子组件中,count的值为:{{count}}\n    </text>\n    \n\n子组件的js:\n\n    // components/myTest1/myTest1.js\n    Component({\n      /**\n       * 组件的属性列表\n       */\n      properties: {\n        count: Number\n      }\n    })\n    \n\nrun,这里圈出来的才是:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/e6d5678f182b402f87f5804c9ccdd290.png)\n\n那么此时我们在子组件中,添加一个button,点击button,子组件中的count自增+1:  \n子组件的wxml:\n\n    <button bindtap=\"addCount\" type=\"primary\">\n    +1\n    </button>\n    <text>\n    子组件中,count的值为:{{count}}\n    </text>\n    \n\n子组件的.js:\n\n    // components/myTest1/myTest1.js\n    Component({\n      /**\n       * 组件的属性列表\n       */\n      properties: {\n        count: Number\n      },\n        methods: {\n    \t  addCount() {\n       \t\t this.setData({\n             count: this.properties.count + 1\n               })\n            },\n         }\n    })\n    \n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/7ce52a07e0a64b9d86ea31e9dae9a89d.png)  \n这里点button,但是组件中的count并不会自加,因为界面上展示的count是来自父组件的值,这里就需要用到子组件向父组件传值,事件绑定\n\n> 事件绑定:\n\n事件绑定用于实现子向传值,可以传递任何类型的数据,使用步骤如下:\n\n1.在父组件的js中,定义一个函数,这个函数即将通过自定义事件的形式,传递给子组件  \n2.在父组件的WXML中,通过自定义事件的形式,将步骤1中定义的函数引用,传递给子组件  \n3.在子组件的js中,通过调用`this.triggerEvent('自定义事件',{/*参数对象*/})`,将数据发送到父组件  \n4.在父组件的js中,通过e.datail获取到子组件传递过来的数据\n\n1.在父组件中写自定义函数:\n\n    Page({\n      syncCount(){\n        console.log('syncCount');\n      }\n    })\n    \n\n2.父组件中wxml通过自定义事件,将步骤1中定义的函数引用,传递给子组件:\n\n    <!-- 使用bind：自定义事件名称(推荐,结构清晰) -->\n    <myTest1 count=\"{{count}}\" bind:sync=\"syncCount\">\n    </myTest1>\n    <!-- 或在bind后面直接写上自定义事件名称 -->\n    <myTest1 count=\"{{count}}\" bindsync=\"syncCount\">\n    </myTest1>\n    \n\n3.在子组件的js中,通过调用`this.triggerEvent('自定义事件',{/*参数对象*/})`,将数据发送到父组件  \n子组件的wxml代码:\n\n    <button bindtap=\"addCount\" type=\"primary\">\n    +1\n    </button>\n    <text>\n    子组件中,count的值为:{{count}}\n    </text>\n    \n\n子组件的js:\n\n    // components/myTest1/myTest1.js\n    Component({\n      methods: {\n        addCount() {\n          this.setData({\n            count: this.properties.count + 1\n          })\n          this.triggerEvent('sync', {\n            value: this.properties.count\n          })\n        },\n      }\n    })\n    \n\n4.在父组件的js中,通过e.detail获取到子组件传递过来的数据:  \n父组件的js:\n\n    Page({\n      syncCount(e) {\n        console.log('syncCount');\n        this.setData({\n          count: e.detail.value\n        })\n      },\n    })\n    \n\nrun:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/055b9df7723f4f30a34b65d404cae7aa.png)\n\n* * *\n\n或者也可以通过下面的方法:\n\n> 获取组件实例:\n\n可在父组件里调用this.selectComponent(‘id或class选择器’),获取子组件的实例对象,从而直接访问子组件的任意数据和方法,调用时需要传入一个选择器,例如this.selectComponent(‘.my-component’)\n\n父组件的WXML:\n\n    <myTest2 class=\"myTest2\" count=\"{{count}}\" bind:sync=\"syncCount\">\n    </myTest2>\n    \n    <button bindtap=\"addCountMysTest2\" type=\"primary\">\n      +1\n    </button>\n    \n\n父组件js:\n\n    // pages/person/person.js\n    Page({\n      addCountMysTest2() {\n        // 切记下面传入的是标签选择器，否则返回的是null\n        const child = this.selectComponent('.myTest2')\n        // 调用子组件的setData方法\n        child.setData({\n          count: child.properties.count + 1\n        })\n        // 调用子组件的addCount方法\n        // child.addCount()\n      },\n    })\n    \n\n子组件wxml:\n\n    <text>\n      子组件中,count的值为:{{count}}\n    </text>\n    \n\n子组件的js:\n\n    // components/myTest2/myTest2.js\n    Component({\n      /**\n       * 组件的属性列表\n       */\n      properties: {\n        count: Number\n      },\n      /**\n       * 组件的方法列表\n       */\n      methods: {\n        addCount() {\n          this.setData({\n            count: this.properties.count + 1\n          })\n          this.triggerEvent('sync', {\n            value: this.properties.count\n          })\n        },\n      }\n    })",
        "states": "0",
        "description": "这里点button,但是组件中的count并不会自加,因为界面上展示的count是来自父组件的值,这里就需要用到子组件向父组件传值,事件绑定。2.在父组件的WXML中,通过自定义事件的形式,将步骤1中定义的函数引用,传递给子组件。1.在父组件的js中,定义一个函数,这个函数即将通过自定义事件的形式,传递给子组件。4.在父组件的js中,通过e.datail获取到子组件传递过来的数据。3.在子组件的js中,通过调用。3.在子组件的js中,通过调用。,将数据发送到父组件。,将数据发送到父组件。......",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/125825726",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 15,
        "email": "2714351312@qq.com",
        "title": "微信小程序_17,插槽",
        "content": null,
        "states": "0",
        "description": "在自定义组件的WXML结构中,可以提供一个节点(插槽),用于承载组件使用者提供的WXML结构。在小程序1中,默认每个自定义组件中只允许使用一个进行占位,这种个数上的限制叫做单个插槽。",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/125823114",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 16,
        "email": "2714351312@qq.com",
        "title": "微信小程序_16,组件的生命周期",
        "content": null,
        "states": "0",
        "description": "2.在组件完全初始化完毕,刚进入页面节点树后,attached生命周期函数会被触发。有时,自定义组件的行为依赖于页面状态的变化,此时就需要用到组件所在页面的生命周期。这里就是组件监听了页面的状态,在每次进入页面时,生成一个随机的RGb值,1.组件实例刚被创建好的时候,created生命周期函数会被触发。3.在组件离开页面节点树后,detached生命周期函数会被触发。新旧两种方式都存在时,会优先使用新的,往后不建议使用旧的方式了。...",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/125814290",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 17,
        "email": "2714351312@qq.com",
        "title": "微信小程序_15,纯数据字段",
        "content": null,
        "states": "0",
        "description": "例如某些情况下,某些data中的字段既不会展示在界面上,也不会传递给其他组件,仅在当前组件内部使用,带有这种特性的data字段适合被设置为纯数据字段。概念纯数据字段指的是那些不用于界面渲染的data字段。好处纯数据字段有助于提升页面更新的性能。...",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/125785876",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "1",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 18,
        "email": "2714351312@qq.com",
        "title": "从0开始安装苹果cms及其资源采集和页面部分代码",
        "content": "> 最近写代码时,上面要我写移动端页面并适配苹果cms,最近才接触,记录一下\n\n安装环境:  \ndeepin(本篇是在虚拟机里装的,服务器端我也这样装的)  \n宝塔面板(Linux面板7.9.3)\n\n1.安装宝塔面板(抄宝塔官网的,Ubuntu/Deepin安装脚本)\n\n    wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh && sudo bash install.sh ed8484bec\n    \n\n安装成功:\n\n    =========================================================\n    Congratulations! Installed successfully!\n    ==================================================================\n    外网面板地址: http://58.19.75.102:8888/6770e84b\n    内网面板地址: http://192.168.198.***:8888/6770e84b\n    username: jj5q13gx\n    password: 214asdasdasb\n    If you cannot access the panel,\n    release the following panel port [8888] in the security group\n    若无法访问面板，请检查防火墙/安全组是否有放行面板[8888]端口\n    \n\n这里我不晓得那些是用得上的,里面推荐的几个我都装了,但苹果cms必须用的有php和mysql,  \n然后安装运行环境,我这里安装的有:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/8385def9815b4ee894532e0b8b9f1467.png)  \n2.下载苹果cms:\n\n[github下载地址](https://github.com/magicblack/maccms_down)\n\n我下载的是:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/d93796730959447d9f2999d6f8e6b3ad.png)  \n3.宝塔上添加网站并把苹果cms文件拷贝进网站跟目录:  \n这里域名我填的是虚拟机deepin的ip地址  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/ff9c1e35fd744a3eb49cc0844e214791.png)  \n然后提交,\n\n上传文件,圈起来的这里是我们的网站目录:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/2cb5ff4853ef4a7ab801b66f2fc76333.png)  \n进入网站目录并上传苹果cms压缩文件,我这里上传的是已经解压的文件,该目录下之前存在的一些默认文件不用删:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/2d12dcf2135b4f109842b087b2eda594.png)\n\n4.进入苹果cms后台:\n\n然后进入:`你的域名/install.php`:\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/7156a57bba774b9da155081beb854b3e.png)\n\n确定之后,进入下面的页面:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/60fc3a6d897c4b088a834c1e2f2a4035.png)  \n看看自己有什么没有安装,红色就是没有安装的,这里`fileinfo`我知道是php那边缺东西没安装:\n\n进入 软件商店->已安装->php->安装扩展->安装fileinfo  \n然后回去苹果cms的页面刷新看看,如果还是红色的,那等一会php中的fileinfo安装完  \n这里的`always_populate_raw_post_data`报错,我搜的是说php版本过低,这里之前我云服务器端用的是php7.1.这里我也换一个,在软件商店里安装即可,这里我7.1安装失败了,安装的是8.0的\n\n你可以在网站->PHP版本里面更换PHP的版本:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/11db9643b228415a91da6e07b4fee67b.png)  \n然后在php面板安装fileinfo,再回到苹果cms页面刷新看看\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a7dc076b837c4b23aeff860bd770d496.png)  \n麻了,php8.0安装fileinfo老是没用,deepin安装个php还贼慢,  \n麻了,php7.4版本还是不行,等我换个centos虚拟机,  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/fe8853b2473641f684ed643cd434584d.png)  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/cc3e6695f96e4b799a2063b7eb3979d9.png)\n\n### 换好了虚拟机\n\n这里的环境是centos7,php7.1,php安装了fileinfo之后:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/9eb5b96a48bc4ef6b41cc1389596bc19.png)  \n下一步,\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/820116efaafd4402b36658eca19a99f8.png)\n\n这里我的数据库名称是cms,需要在宝塔面板->数据库->添加数据库  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/1a1bd2b9eac04e4ebb42e2714a3fceca.png)  \n然后提交,回到苹果cms页面:测试数据库成功之后,设置管理员账号,.密码,立即执行安装,  \n要注意这里管理员密码不能太短,我这里这是的admin,admin123\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a5029131d1d047e49e9bbba011cb75fa.png)\n\n然后是:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/a97d47ec920046ebabc2fec34f3c6cd1.png)  \n在宝塔中修改:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/3a07f76c87d34a52b241117268965acb.png)  \n将这个文件改个名,但是后缀当然不要改,以后进入admin后台就用`域名/你修改的文件名.php`进入即可\n\n如图,我这里修改为test,那么进入admin是:  \n`http://192.168.198.131/test.php`\n\n登录之后就可以进入后台:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/1f39ba0c21834061a51f7b3eec305703.png)\n\n然后进入你在面板中创建的网站域名:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/5291f3b1213c4863880dd385880e64b5.png)  \n这里要注意,如果你在面板中的网站域名前面有www,那么你要进入的url前面也是要有www的,如果没有,那么进入时也不要加,这里我直接指向的是ip\n\n苹果cms默认是没有主题的,需要自己添加,这里我以一个免费主题为例,添加一下:\n\n我这里下载的是免费模板,解压后,在tamplte目录下将该文件夹上传,圈起来的是我下载的压缩包:\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ec821721299d4eaea58912491e00c392.png)  \n把文件上传到你网站目录的tamplate目录下:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/526ef5a831484d7a8b4b26ae7bd30afc.png)  \n上传之后就是这样:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/e634323ea3c0471cada27e7e19a2294f.png)  \n然后进入你的苹果cms后台管理 -> 系统 -> 网站参数配置  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/231a5076334f4d15aa6c920d706fad9c.png)\n\n将��站模板改为你想要使用的模板,并保存  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/e807794b90da461bbc0fbca9247bd10b.png)  \n然后回到网站页面:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/aaf6076ec7404c1c921b49e3b27c64a4.png)  \n此时网站数据是空的,所以没有数据展示,需要你自己手动采集资源:\n\n#### 资源采集:\n\n进入cms后台管理界面,采集,自定义接口,添加:  \n这里我用的是随便搜索的一个接口:\n\n    https://api.tiankongapi.com/api.php/provide/vod/at/xml/ \n    \n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/159c53a6cf10428d93fce9aabcc06396.png)\n\n同步图片是将你采集的数据的图片一起同步,方便数据后续在主页的展示,然后点击保存\n\n下面就是资源采集与绑定了:\n\n下面可以选择采集不同的时间段资源:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/824456e1e1e1499688534d5a7b20a512.png)  \n我这边时间还挺长的,这里只采集当天试试:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/d0dd2490dbf443f1ad30a45b0ee730f9.png)  \n上面显示 `分类未绑定，跳过err`的,则是你没有为该分类的影视资源绑定分类,需要在采集完之后,手动绑定:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/b68cec0e4cbd4a0bbdb051ef098b96ca.png)  \n在上面就可以进行绑定了,看心情吧,目前我还不知道为什么只有分类四,后台应该能改,只不过目前开发中我没遇到需要改分类名的情况\n\n手动绑完分类:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/9f9fcecdda4c4215b929ae29cdf5b0e8.png)  \n然后采全部:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/d0dbb8f6222e403e833909798c4ee0e2.png)  \n它又跑一遍:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/9f1c2477631a40558029ebc5adb72737.png)  \n采集完之后,回到你的网站:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/2a9dcdfa73ff4993b04c5a8549a63dce.png)  \n它的后端标签说明文档在网站目录下,这里圈起来的就是  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/4eed2a3bef634c4588232c790a306763.png)\n\n但最近上面是要求写一个移动端的页面,刚开始以为是后台给个接口来写,  \n但实际上是前后端结合的项目,前端中也要写php代码  \n这里用到的代码大都是需要自己测试或者从其他模板copy的\n\n> 获取某一类型的视频列表:\n\n    {maccms:vod num=\"12\" type=\"'.$vo1['type_id'].'\" order=\"desc\" by=\"time\"}\n    <li>\n        <div class=\"imageCover\">\n            <a href=\"{:mac_url_vod_detail($vo)}\" title=\"{$vo.vod_name}\"\n               style=\"background: url({:mac_url_img($vo.vod_pic)}) no-repeat; background-position: 50% 50%; background-size: cover;\"\n               class=\"coverImg\">\n            </a>\n        </div>\n        <div class=\"text\">\n            <p class=\"name\">\n                {$vo.vod_name}\n            </p>\n            <p class=\"introduce\">\n                {$vo.vod_blurb}\n            </p>\n        </div>\n    </li>\n    {/maccms:vod}\n    \n\n这里我并没有传入类型id的(就是`type=\"'.$vo1['type_id'].'\"`部分代码),这里应该是默认返回了第一种分类的视频数据,这里传入指定id返回指定类型的视频列表数据:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/c52e4eb1252d49ce985bb5629fc4983b.png)\n\n> 循环遍历获取所有视频类型的列表:\n\n    {maccms:type ids=\"parent\" order=\"asc\" by=\"sort\" id=\"vo1\" key=\"key1\" flag=\"vod\"}\n    <div class=\"collections\">\n        <h3>{$vo1.type_name}</h3>\n        <ul>\n            {maccms:vod num=\"12\" type=\"'.$vo1['type_id'].'\" order=\"desc\" by=\"time\"}\n            <li>\n                <div class=\"imageCover\">\n                    <a href=\"{:mac_url_vod_detail($vo)}\" title=\"{$vo.vod_name}\"\n                       style=\"background: url({:mac_url_img($vo.vod_pic)}) no-repeat; background-position: 50% 50%; background-size: cover;\"\n                       class=\"coverImg\">\n                    </a>\n                </div>\n                <div class=\"text\">\n                    <p class=\"name\">\n                        {$vo.vod_name}\n                    </p>\n                    <p class=\"introduce\">\n                        {$vo.vod_blurb}\n                    </p>\n                </div>\n            </li>\n            {/maccms:vod}\n        </ul>\n    </div>\n    {/maccms:type}\n    \n\n运行:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/f6f111d724f0436ba0a78fa6ab2eb949.png)  \n上面的标签中:\n\n*   `{$vo.vod_name}`当前遍历$vo的name,这里是获取对象中的视频名字\n*   `{$vo.vod_blurb}`视频描述\n*   `{:mac_url_img($vo.vod_pic)}`视频的封面图片\n*   `{maccms:vod num=\"12\" type=\"'.$vo1['type_id'].'\" order=\"desc\" by=\"time\"}{/maccms:vod}`这是一对标签,遍历指定type的分类资源,num指定其返回数据条数,order指定其是倒叙还是顺序,by指定的是排序方式(关于排序的指定,说明文档中有详细说明)\n*   `{:mac_url_vod_detail($vo)}`这里是在a标签的href属性中,指定的是$vo的详情页\n\n> 获取首页推荐视频的数据:\n\n        <!--index页面的swiper-->\n        <div class=\"swiperContent\">\n            <div class=\"swiper-container\">\n                <div class=\"swiper-wrapper\">\n                    <!--\n                    这里的推荐等级不同,推荐的视频也是不同的,level为这里的推荐等级,可以为1,2,3,4,5\n                    也可以设置为all\n                    -->\n                    {maccms:vod level=\"all\" order=\"desc\" }\n                    <div class=\"swiper-slide\">\n                        <a href=\"{:mac_url_vod_detail($vo)}\" title=\"{$vo.vod_name}\"\n                           style=\"background: url({:mac_url_img($vo.vod_pic)}) no-repeat; background-position: 50% 50%; background-size: cover;\"\n                           class=\"videoCover\">\n                        </a>\n                    </div>\n                    {/maccms:vod}\n                </div>\n            </div>\n        </div>\n    \n\n上面的代码中:\n\n*   `level`指定的是推荐等级,我这里选的是all,就是所有,一般有1~9这几个等级\n*   `order`指定排序方式\n\n要注意这里必须先在苹果cms后台设置你的推荐视频,这里才会有数据否则是空的:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/6315e7ab9f5644a1b9998f67b08530e0.png)  \n关于如何设置推荐视频,网上教程有很多,这里不再做赘述:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/74f877d377c84bae9e5f8bdcae4d498d.png)  \n视频->视频数据->勾选你想要设置为推荐的视频,->推荐->选择推荐等级->保存\n\n通过查询,下面可以看到我设置的推荐视频有:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/efae33278c704d8086a439e9b2b63404.png)  \n刷新:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/796bdda61204459e893af330c6466192.png)\n\n**写这个页面中麻烦的就是需要自己找对应数据的标签,下面是我忘了在哪找的一些苹果cms标签,可以参考下**\n\n    order排列顺序desc倒序，asc正序\n    by排序依据\n    start从第几条开始\n    num获取条数\n    ids指定1,2,3一组ID；\n    type指定获取分类数据 all所有；1,2,3指定；\n    class指定某扩展分类 支持多个 动作,喜剧\n    tag指定tag 支持多个  aaa,xxx\n    level指定推荐值 支持多个  1,2\n    area指定地区 支持多个  大陆,香港\n    lang指定语言 支持多个  国语,粤语\n    year指定年代 支持多个 2002,2003\n    state资源类别 支持多个 高清版,剧场版,抢先版\n    version资源版本 支持多个 正片,预告片\n    weekday更新周期 支持多个  一,二,三\n    rel指定关联数据 1,2,3 或 变形金刚\n    timeadd添加时间 一天前 -1 day，一周前-1 week，一月前-1 month，一小时前-1 hour\n    timehits点击时间 一天前 -1 day，一周前-1 week，一月前-1 month，一小时前-1 hour\n    time更新时间 一天前 -1 day，一周前-1 week，一月前-1 month，一小时前-1 hour\n    hitsmonth月点击量 大于一千 gt 1000, 小于一千 lt 1000，区间一千二千之间 between 1000,2000\n    hitsweek周点击量 大于一千 gt 1000, 小于一千 lt 1000，区间一千二千之间 between 1000,2000\n    hitsday日点击量 大于一千 gt 1000, 小于一千 lt 1000，区间一千二千之间 between 1000,2000\n    hits总点击量 大于一千 gt 1000, 小于一千 lt 1000，区间一千二千之间 between 1000,2000\n    paging是否分页yes\n    pageurl分页地址\n    \n    {maccms:vod num=\"10\" paging=\"no\" type=\"all\" order=\"asc\" by=\"sort\"}\n       内部同下方，{$obj.改为{$vo.开头即可\n    {/maccms:vod}\n    =======视频内容页独有标签=======\n    {$obj.vod_id} 视频id\n    {$obj.type_id} 分类id\n    {$obj.type_id_1} 一级分类id\n    {$obj.type} 视频分类对象，二级属性可参考分类\n    {$obj.type_1} 一级分类对象，二级属性可参考分类\n    {$obj.group_id} 用户组id\n    {$obj.vod_name} 视频名\n    {$obj.vod_sub} 副标题\n    {$obj.vod_en} 别名\n    {$obj.vod_status} 状态0未审1已审\n    {$obj.vod_letter} 首字母\n    {$obj.vod_color} 颜色\n    {$obj.vod_tag} tags\n    {$obj.vod_class} 扩展分类\n    {$obj.vod_pic} 图片\n    {$obj.vod_pic_thumb} 缩略图\n    {$obj.vod_pic_slide} 幻灯图\n    {$obj.vod_actor} 主演\n    {$obj.vod_director} 导演\n    {$obj.vod_writer}编剧\n    {$obj.vod_blurb} 简介\n    {$obj.vod_remarks} 备注\n    {$obj.vod_pubdate}上映日期\n    {$obj.vod_total} 总集数\n    {$obj.vod_serial} 连载数\n    {$obj.vod_tv} 上映电视台\n    {$obj.vod_weekday} 节目周期\n    {$obj.vod_area} 地区\n    {$obj.vod_lang} 语言\n    {$obj.vod_year} 年代\n    {$obj.vod_version} 版本-dvd,hd,720p\n    {$obj.vod_state} 资源类别-正片,预告片,花絮\n    {$obj.vod_author} 编辑人员\n    {$obj.vod_jumpurl} 跳转url\n    {$obj.vod_tpl} 独立模板\n    {$obj.vod_tpl_play} 独立播放页模板\n    {$obj.vod_tpl_down} 独立下载页模板\n    {$obj.vod_isend} 是否完结\n    {$obj.vod_lock} 锁定1\n    {$obj.vod_level} 推荐级别\n    {$obj.vod_points_play} 点播付费\n    {$obj.vod_points_down} 下载付费\n    {$obj.vod_hits} 总点击量\n    {$obj.vod_hits_day} 日点击量\n    {$obj.vod_hits_week} 周点击量\n    {$obj.vod_hits_month} 月点击量\n    {$obj.vod_duration} 时长\n    {$obj.vod_up} 顶数\n    {$obj.vod_down} 踩数\n    {$obj.vod_score} 平均分\n    {$obj.vod_score_all} 总评分\n    {$obj.vod_score_num} 评分次数\n    {$obj.vod_time} 更新时间\n    {$obj.vod_time_add} 添加时间\n    {$obj.vod_time_hits} 点击时间\n    {$obj.vod_time_make} 生成时间\n    {$obj.vod_trysee} 试看时长分\n    {$obj.vod_reurl} 来源地址\n    {$obj.vod_rel_vod} 关联视频ids\n    {$obj.vod_rel_art} 关联文章ids\n    {$obj.vod_content} 详细介绍\n    {$obj.vod_play_from} 播放组\n    {$obj.vod_play_server} 播放服务器组\n    {$obj.vod_play_note} 播放备注\n    {$obj.vod_play_url} 播放地址\n    {$obj.vod_down_from} 下载租\n    {$obj.vod_down_server} 下载服务器组\n    {$obj.vod_down_note} 下载备注\n    {$obj.vod_down_url} 下载地址\n    {:mac_url_vod_detail($obj)}  视频详情页链接\n    {:mac_url_vod_play($obj,['sid'=>1,'nid'=>1])}   视频播放页链接\n    {:mac_url_vod_down($obj,['sid'=>1,'nid'=>1])}   视频下载页链接",
        "states": "0",
        "description": "最近写代码时,上面要我写移动端页面并适配苹果cms,最近才接触,记录一下安装环境deepin(本篇是在虚拟机里装的,服务器端我也这样装的)宝塔面板(Linux面板7.9.3)1.安装宝塔面板(抄宝塔官网的,Ubuntu/Deepin安装脚本)这里我不晓得那些是用得上的,里面推荐的几个我都装了,但苹果cms必须用的有php和mysql,然后安装运行环境,我这里安装的有我下载的是3.宝塔上添加网站并把苹果cms文件拷贝进网站跟目录这里域名我填的是虚拟机deepin的ip地址。...",
        "praise": "0",
        "view": "3",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/125795307",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 19,
        "email": "2714351312@qq.com",
        "title": "微信小程序_14,组件的创建与引用",
        "content": "> 目标:\n\n*   能够知道如何自定义小程序组件\n*   能够知道小程序组件中behaviors的作用\n*   能够知道如何安装和配置vant-weapp组件库\n*   能够知道如何使用MobX实现全局数据共享\n*   能够知道如何对小程序的API进行Promise化\n\n* * *\n\n> 组件的创建与引用\n\n1.在项目的根目录中,鼠标右键,创建components->test文件夹  \n2.在新建的components->test文件夹上,鼠标右键,点击\"新建component\"  \n3.键入组件的名称之后回车,会自动生成组件对应的4个文件,后缀分别为.js,.json,.wxml和.wxss\n\n如图:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/65d1129206f64cc88f161928e83db372.png)\n\n> 引用组件:\n\n组件的引用方式分为\"局部引用\"和\"全局引用\",顾名思义:\n\n*   局部引用:组件只能在当前页面被引用的页面内使用\n*   全局引用:组件可以在每个小程序页面中使用\n\n> 局部引用:  \n> 在页面的.json配置文件中引用组件的方式,叫做\"局部引用\",示例代码如下:\n\n    {\n      \"usingComponents\": {\n        \"my-test1\":\"/components/test/test\"\n      }\n    }\n    \n\n然后就可以在WXML中引用:\n\n    <my-test1></my-test1>\n    \n\n> 全局引用:  \n> 在app.json全局配置文件中引用组件的方式,叫做\"全局引用\",示例代码如下:  \n> 在app.json节点下,和pages平级添加如下代码:\n\n      \"usingComponents\": {\n        \"my-test1\": \"/components/test/test\"\n      }\n    \n\nWXML:\n\n    <!--全局组价:-->\n    <my-test1></my-test1>\n    \n\n然后就可以使用了\n\n> 全局引用和局部引用的应用场景:\n\n根据组件的使用频率和范围,来选择合适的引用方式:\n\n*   如果某个组件在多个页面中经常被用到,建议进行\"全局引用\"\n*   如果某个组件只在特定的页面中被引用到,建议进行\"局部引用\"\n\n> 组件和页面的区别:\n\n从表面上看,组件和页面都是由,js,.json,.wxml,和.wxss这四个文件组成,但是,组件和页面的.js与.json文件有明显的不同:\n\n*   组件的.json文件中需要声明\"component\":true属性\n*   组件的.js文件中调用的是Component()函数\n*   组件的事件处理函数需要定义到methods节点中\n\n> 样式:\n\n组件样式隔离:\n\n默认情况下,自定义组件的样式只对当前组件生效,不会影响到组件之外的UI结构,如图所示:\n\n*   组件A的样式不会影响组件C的样式\n*   组件A的样式不会影响小程序页面的样式\n*   小程序页面的样式不会影响组件A和C的样式\n\n好处:  \n1.防止外界的样式影响组件内部的样式  \n2.防止组件的样式破坏外界的样式\n\n> 组将样式隔离的注意点:\n\n*   app.wxss中全局样式对组件无效\n*   只有class选择器会有样式隔离效果,id选择器,标签选择器不受样式隔离的影响\n\n建议:在组件和引用组件的页面中建议使用class选择器,不要使用id,属性,标签选择器!\n\n> 修改组件的样式隔离选项:\n\n默认情况下,自定义组件的样式隔离特性能够防止组件内部样式互相干扰的问题,但有时,我们希望在外界能够控制组件内部的样式,此时,可以通过stylesolation修改组件的样式隔离选项,用法如下:\n\n    // components/test/test.js\n    Component({\n      options: {\n        // 下面是默认的，启用默认隔离\n        styleIsolation: 'isolated'\n      },\n    })\n    \n\nstyleIsolation的可选值:\n\n可选值\n\n默认值\n\n描述\n\nislated\n\n是\n\n表示启用样式隔离,在自定义组件内外,使用class指定的样式将不会相互影响\n\napply-shared\n\n否\n\n表示页面wxss样式将影响到自定义组件,但自定义组件wxss中指定的样式不会影响页面\n\nshared\n\n否\n\n表示页面wxss样式将影响到自定义组件,自定义组件wxss中指定的样式也会影响页面和其他设置了apply-shared的自定义组件\n\n> 自定义组件中的数据,方法和属性:\n\n1.data数据:\n\n在小程序中,用于组件模板渲染和私有数据,需要定义在data节点中,示例如下:\n\n    // components/test/test.js\n    Component({\n      /**\n       * 组件的属性列表\n       */\n      properties: {\n      },\n      /**\n       * 组件的初始数据\n       */\n      data: {\n        count: 0\n      },\n    })\n    \n\n2.methods方法:\n\n在小程序组件中,事件处理函数和自定义方法需要定义到methods节点中,示例代码如下:\n\n    // components/test/test.js\n    Component({\n      methods: {\n        // 事件处理函数\n        addCount() {\n          this.setData({\n            count: this.data.count + 1\n          })\n          // 通过this直接调用自定义方法\n          this._showCount();\n        },\n        // 自定义方法建议以_开头\n        _showCount() {\n          wx.showToast({\n            title: 'count的值为: ' + this.data.count,\n            icon: 'none'\n          })\n        }\n      },\n      /**\n       * 组件的属性列表\n       */\n      properties: {\n    \n      },\n      /**\n       * 组件的初始数据\n       */\n      data: {\n        count: 0\n      },\n    })\n    \n\n3.properties属性:\n\n在小程序中,properties是组件的对外属性,用来接收外界传递到组件中的数据,示例代码如下:\n\n组件的wxml:\n\n    <text class=\"fontcolor\">\n      test组件:\n    </text>\n    count的值是:{{count}}\n    <button bindtap=\"addCount\" type=\"primary\">count自加1并显示</button>\n    \n\n在组件的.js文件中编写:\n\n      /**\n       * 组件的属性列表\n       */\n      properties: {\n        // 完整定义属性的方式（当需要指定属性默认值时，建议使用此方式）\n        max: {\n          // 属性值的数据类型\n          type: Number,\n          // 属性默认值\n          vlaue: 10\n        },\n        // 简化自定义属性的方式(不需要指定属性默认值时,可以使用简化方式)\n        // max: Number\n      },\n    \n\n在引用组件的wxml中引用:\n\n    <my-test1 max='11'></my-test1>\n    \n\n4.data和properties的区别:\n\n在小程序的组件中,properties属性和data数据的用法相同,他们都是可读可写的,只不过:\n\n*   data更倾向于存储组件的私有数据\n*   propertier更倾向于存储外界传递到组件中的数据\n\n    \n    // components/test/test.js\n    Component({\n      properties: {\n      /**\n       * 组件的方法列表\n       */\n      methods: {\n        _showInfo() {\n          console.log(this.data);\n          console.log(this.properties);\n          console.log(this.properties === this.data);\n        },\n      },\n    })\n    \n\n5.使用setData修改properties的值:\n\n由于data数据和properties属性在本质上没有任何区别,因此properties属性的值也可以用于页面渲染,或使用setData为properties的属性重新赋值,示例代码如下:\n\n    // components/test/test.js\n    Component({\n      /**\n       * 组件的初始数据\n       */\n      data: {\n        count: 0\n      },\n    \n      /**\n       * 组件的属性列表\n       */\n      properties: {\n        // 完整定义属性的方式（当需要指定属性默认值时，建议使用此方式）\n        max: {\n          // 属性值的数据类型\n          type: Number,\n          // 属性默认值\n          vlaue: 10\n        },\n        // 简化自定义属性的方式(不需要指定属性默认值时,可以使用简化方式)\n        // max: Number\n      },\n    \n      /**\n       * 组件的方法列表\n       */\n    \n      methods: {\n        // 事件处理函数\n        addCount() {\n          if (this.data.count >= this.properties.max) return\n          this.setData({\n            count: this.data.count + 1\n          })\n          // 通过this直接调用自定义方法\n          this._showCount();\n        },\n        // 自定义方法建议以_开头\n        _showCount() {\n          wx.showToast({\n            title: 'count的值为: ' + this.data.count,\n            icon: 'none'\n          })\n        },\n        _showInfo() {\n          console.log(this.data);\n          console.log(this.properties);\n          console.log(this.properties === this.data);\n        },\n        change() {\n          this.setData({\n            max: this.properties.max + 1\n          })\n        }\n      },\n    })\n    \n    \n\n这里是change函数修改properties中的max(限制count的最大值),max自增一个,count的最大值就自增一个\n\n> 自定义组件-数据监听器\n\n1.什么是数据监听器:\n\n数据监听器用于监听和相应任何属性和数据字段的变化,从而执行特定的操作,它的作用类似于vue中的watch侦听器,在小程序组件中,数据监听器的基本语法格式如下:\n\n    Component({\n      /**\n       * 组件的初始数据\n       */\n      data: {\n        count: 0\n      },\n    \n      /**\n       * 组件的属性列表\n       */\n      properties: {\n        // 完整定义属性的方式（当需要指定属性默认值时，建议使用此方式）\n        max: {\n          // 属性值的数据类型\n          type: Number,\n          // 属性默认值\n          vlaue: 10\n        },\n      },\n      observers: {\n        'max,count': function (max, count) {\n          console.log(\"max监听的值是: \" + max);\n          console.log(\"count监听的值是: \" + count);\n        },\n        'count': function (a) {\n          console.log('count单独监听的值是: ' + a);\n        }\n      }\n    })\n    \n\n2.数据监听器的基本用法:\n\n组件的UI结构如下:\n\n    <view>\n      {{n1}}+{{n2}}={{sum}}\n    </view>\n    <button size=\"mini\" bindtap=\"addN1\">\n      n1自增\n    </button>\n    <button size=\"mini\" bindtap=\"addN2\">\n      n2自增\n    </button>\n    \n\njs代码如下:\n\n    // components/numsAdd/numsAdd.js\n    Component({\n      /**\n       * 组件的属性列表\n       */\n      properties: {\n    \n      },\n    \n      /**\n       * 组件的初始数据\n       */\n      data: {\n        n1: 0,\n        n2: 0,\n        sum: 0\n      },\n    \n      /**\n       * 组件的方法列表\n       */\n      methods: {\n        addN1() {\n          this.setData({\n            n1: this.data.n1 + 1\n          })\n        },\n        addN2() {\n          this.setData({\n            n2: this.data.n2 + 1\n          })\n        },\n      },\n      // 数据监听节点\n      observers: {\n        'n1 , n2': function (n1, n2) {\n          this.setData({\n            sum: n1 + n2\n          })\n        },\n      },\n    })\n    \n\n运行:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/013fabe79b5c4bf68b3681702dec8b0e.png)\n\n> 案例:\n\n三个按钮,合起来控制RGB的三个数值,自增,自增到最大时,遍不再自增:\n\nWXML:\n\n    \n    <view class=\"randomColor\" style=\"background-color: rgb({{fullColor}});\"></view>\n    <text>\n      {{rgb.r}},{{rgb.g}},{{rgb.b}}\n      当前RGB值:{{fullColor}}\n    </text>\n    <button size=\"mini\" type=\"primary\" bindtap=\"rAdd\">R+1</button>\n    <button size=\"mini\" type=\"primary\" bindtap=\"gAdd\">G+1</button>\n    <button size=\"mini\" type=\"primary\" bindtap=\"bAdd\">B+1</button>\n    \n\n.js:\n\n    // components/numsAdd/numsAdd.js\n    Component({\n      /**\n       * 组件的属性列表\n       */\n      /**\n       * 组件的初始数据\n       */\n      data: {\n        n1: 0,\n        n2: 0,\n        sum: 0,\n        user: {\n          name: \"张三\",\n          age: 21,\n          school: \"武汉轻工小学\"\n        },\n        rgb: {\n          r: 0,\n          g: 0,\n          b: 0,\n        },\n        fullColor: '0,0,0' //根据rgb对象的三个属性,动态计算fullColor的值\n      },\n    \n      /**\n       * 组件的方法列表\n       */\n      methods: {\n        addN1() {\n          this.setData({\n            n1: this.data.n1 + 1\n          })\n        },\n        addN2() {\n          this.setData({\n            n2: this.data.n2 + 1\n          })\n        },\n        // 修改对象属性:\n        changeName() {\n          this.setData({\n            user: {\n              name: \"张三改了名字\",\n              age: 22\n            }\n          })\n        },\n        rAdd() {\n          this.setData({\n            'rgb.r': this.data.rgb.r + 5 > 255 ? 255 : this.data.rgb.r + 5\n          })\n        },\n        gAdd() {\n          this.setData({\n            'rgb.g': this.data.rgb.g + 5 > 255 ? 255 : this.data.rgb.g + 5\n          })\n        },\n        bAdd() {\n          this.setData({\n            'rgb.b': this.data.rgb.b + 5 > 255 ? 255 : this.data.rgb.b + 5\n          })\n        },\n      },\n      // 数据监听节点\n      observers: {\n        'n1 , n2': function (n1, n2) {\n          this.setData({\n            sum: n1 + n2\n          })\n        },\n        'user.name': function (name) {\n          console.log('user中的name属性更改了');\n        },\n        'rgb.r,rgb.g,rgb.b': function (r, g, b) {\n          this.setData({\n            fullColor: `${r},${g},${b}`\n          })\n        }\n    \n        // '对象.属性A,对象.属性B':function(属性A的新值,属性B的新值){}\n        // 对象触发此监听器的三种情况：\n        // [为属性A赋值]使用setData设置this.data.对象.属性A 时触发\n        // [为属性B赋值]使用setData设置this.data.对象.属性B 时触发\n        // [直接为对象赋值]使用setData设置this.data.对象 时触发\n      },\n    })\n    \n\n这里也就用了对象属性的监听,运行(圈起来的才是这部分的代码):\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/fdd268854e164a939bbe84a4fe6c6311.png)\n\n* * *\n\n3.监听对象属性的变化:\n\n数据监听器支持监听对象中单个或多个属性的变化,示例语法如下:\n\n      // 数据监听节点\n      observers: {\n        'n1 , n2': function (n1, n2) {\n          this.setData({\n            sum: n1 + n2\n          })\n        },\n        'user.name': function (name) {\n          console.log('user中的name属性更改了');\n        }\n      },\n    \n\n> 监听对象中所有属性的变化\n\n如果某个对象中需要被监听的属性太多,为了方便,可以使用通配符`**`来监听对象中所有属性的变化,示例代码如下:\n\n不使用`**`来监听:\n\n      observers: {\n        'rgb.r,rgb.g,rgb.b': function (r, g, b) {\n          this.setData({\n            fullColor: `${r},${g},${b}`\n          })\n        }\n    \n        // '对象.属性A,对象.属性B':function(属性A的新值,属性B的新值){}\n        // 对象触发此监听器的三种情况：\n        // [为属性A赋值]使用setData设置this.data.对象.属性A 时触发\n        // [为属性B赋值]使用setData设置this.data.对象.属性B 时触发\n        // [直接为对象赋值]使用setData设置this.data.对象 时触发\n      },\n    \n\n使用`**`监听:\n\n        'rgb.**': function (obj) {\n          this.setData({\n            fullColor: `${obj.r},${obj.g},${obj.b}`\n          })\n        }\n    \n\n* * *",
        "states": "0",
        "description": "1.在项目的根目录中,鼠标右键,创建components->test文件夹2.在新建的components->test文件夹上,鼠标右键,点击\"新建component\"3.键入组件的名称之后回车,会自动生成组件对应的4个文件,后缀分别为.js,.json,.wxml和.wxss如图:组件的引用方式分为\"局部引用\"和\"全局引用\",顾名思义:然后就可以在WXML中引用:WXML:然后就可以使用了根据组件的使用频率和范围,来选择合适的引用方式:从表面上看,组件和页面都是由,js,.json,.wx",
        "praise": "0",
        "view": "3",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/125684855",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 20,
        "email": "2714351312@qq.com",
        "title": "微信小程序_13,本地生活案例",
        "content": "> 列表页面的api接口:\n\n以分页的形式,加载指定分类下商铺列表的数据\n\n1.接口地址:\n\n*   https://www/escook.cn/categories/:cate\\_id/shops\n*   URL地址中的:cate\\_id是动态参数,表示分类的id\n\n2.请求方式:\n\n*   GET请求\n\n3.请求参数:\n\n*   \\_page表示请求第几页的数据\n*   \\_limit表示请求第几条数据\n\n> 演示页面效果以及主要功能:\n\n*   页面导航并传参\n*   上拉触底时加载下一页数据\n*   下拉刷新列表数据\n\n> 判断是否还有下一页数据:\n\n如果下面的公示成立,则证明没有下一页数据了\n\n页码值\\*每页显示多少条数据>=总数据条数\n\npage\\*pageSize>=total\n\n案例1:总共有77条数据,如果每页显示10条数据,则总共分为8页,其中第八页只有七条数据\n\npage(7)\\*pageSize(10)>=total(77)",
        "states": "0",
        "description": "以分页的形式,加载指定分类下商铺列表的数据1.接口地址:2.请求方式:3.请求参数:如果下面的公示成立,则证明没有下一页数据了页码值*每页显示多少条数据>=总数据条数page*pageSize>=total案例1:总共有77条数据,如果每页显示10条数据,则总共分为8页,其中第八页只有七条数据page(7)*pageSize(10)>=total(77)...",
        "praise": "0",
        "view": "3",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/125681513",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 23,
        "email": "2714351312@qq.com",
        "title": "微信小程序_10,页面事件",
        "content": "#### 什么是下拉刷新:\n\n下拉刷新是移动端的专有名词,指的是通过手指在屏幕上的下拉滑动操作,从而重新加载页面数据的行为\n\n> 启用下拉刷新:\n\n1.全局开启下拉刷新\n\n*   在app.json的window节点中,将`enablePullDownRefresh`设置为true\n*   在实际开发中不推荐,只推荐在需要开启下拉刷新的页面单独配置\n\n2.局部开启下拉刷新\n\n*   在页面的.json配置文件中,将`enablePullDownRefresh`设置为true\n\n实际开发中推荐使用第二种方式\n\n局部开启:\n\n      \"enablePullDownRefresh\": true\n    \n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/7af6427acd6047d5a42c45934a1863c6.png)\n\n> 配置下拉刷新窗口的样式:\n\n在全局或页面的.json配置文件中,通过backgroundColor和backgroundTextStyle来配置下来刷新窗口的样式,其中:\n\n*   background用来配置下拉刷新窗口的背景颜色,仅支持16进制的颜色值\n*   backgroundTextStyle永磊配置下拉刷新loading的样式,仅支持dark和light\n\n    {\n     \"usingComponents\": {},\n     \"enablePullDownRefresh\": true,\n     \"backgroundColor\": \"#efefef\",\n     \"backgroundTextStyle\": \"dark\"\n    }\n    \n\n> 在页面的.js文件中,通过onPullDownRefreash()函数即可监听当前页面的下拉刷新事件\n\n如下面的例子中,button控制count的自增,下拉重置count为0(页面中不必要的代码没有copy)  \nWXML:\n\n    <text>\n    下拉刷新后,下面的数字自增1:\n    </text>\n    {{count}}\n    <button bindtap=\"countAdd\">count自加</button>\n    \n\n.js:\n\n      countAdd() {\n        this.setData({\n          count: this.data.count + 1\n        })\n      },\n      /**\n       * 页面的初始数据\n       */\n      data: {\n        count: 0\n      },\n        /**\n       * 页面相关事件处理函数--监听用户下拉动作\n       */\n      onPullDownRefresh() {\n        console.log('下拉刷新');\n        this.setData({\n          count: 0\n        })\n      },\n    \n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/167b746da4b547c4ad3d4ff5a88e254a.png)\n\n> 停止下拉刷新效果:\n\n当你下拉刷新时,其中的function会立即执行,但是下拉刷新的效果不会立即停止,需要等几秒\n\n当处理完下拉刷新后,下拉刷新的loading效果会一直显示,不会主动消失,所以需要手动隐藏loading效果,此时,调用wx.stopPullDownRefresh()可以停止当前页面的下拉刷新,示例:\n\nWXML:\n\n    <text>\n    下拉刷新后,下面的数字自增1:\n    </text>\n    {{count}}\n    <button bindtap=\"countAdd\">count自加</button>\n    \n\n.js:\n\n      countAdd() {\n        this.setData({\n          count: this.data.count + 1\n        })\n      },\n      /**\n       * 页面的初始数据\n       */\n      data: {\n        count: 0\n      },\n        /**\n       * 页面相关事件处理函数--监听用户下拉动作\n       */\n      onPullDownRefresh() {\n        console.log('下拉刷新');\n        this.setData({\n          count: 0\n        })\n        wx.stopPullDownRefresh()\n      },\n    \n\n> 什么是上拉触底:\n\n上拉触底是移动端的专有名词,通过手指在屏幕上的上拉滑动操作,从而加载更多数据的行为\n\n监听上拉触底事件:\n\n在页面的.js文件中,通过onReachBottom()函数即可监听当前页面的上拉触底事件,示例代码如下:\n\nWXML:\n\n    <text>\n      {{status}}\n    </text>\n    <view class=\"box\">\n    </view>\n    \n\n.js:\n\n      /**\n       * 页面上拉触底事件的处理函数\n       */\n      onReachBottom() {\n        this.setData({\n          status: '你触发了上拉触底function'\n        })\n        console.log('你触发了上拉触底function');\n      },\n    \n\n要注意,这里只有页面长度超出当前页面height的100%才能触发上拉触底事件,  \nrun:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/29c28462ae6140ffbc2d77fe693c7223.png)  \n此时在PC端可以查看到你的debug:\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ced4c002a9d945f4a0af284f42b64d5d.png)\n\n配置上拉触底的距离:\n\n上拉触底距离就是触发上拉触底事件时,滚动条距离页面底部的距离\n\n可以在全局或页面的.json配置文件中,通过onReachBottomDistance属性来配置上拉触底的距离\n\n小程序默认的触底距离是50px,在实际开发中,可以根据自己的需求修改这个默认值\n\n例如:\n\n      \"onReachBottomDistance\": 150\n    \n\n> 案例效果展示\n\n案例的实现步骤  \n1.定义获取随机颜色的方法  \n2.在页面加载时,获取初始数据  \n3.渲染UI结构并美化页面效果  \n4.在上拉触底时调用并获取随机颜色的方法  \n5.添加loading提示效果  \n6.对上拉触底进行节流处理\n\n案例代码:  \nWXML:\n\n    <!-- <text>\n      随机颜色\n    </text>\n    <text>\n      渲染UI结构:\n    </text> -->\n    \n    <view wx:for=\"{{colorList}}\" wx:key=\"index\" class=\"num-item\" style=\"background-color: rgba({{item}});\">\n      {{item}}\n    </view>\n    \n\n.js:\n\n    // pages/randomColor/randomColor.js\n    Page({\n    \n      /**\n       * 页面的初始数据\n       */\n      data: {\n        // 随机颜色的列表\n        colorList: [],\n        isloading: false\n      },\n      // 获取随机颜色的方法\n      getColors() {\n        this.setData({\n          isloading: true\n        })\n    \n        wx.showLoading({\n          title: \"数据加载中...\"\n        });\n        wx.request({\n          url: 'https://www.escook.cn/api/color',\n          method: 'GET',\n          success: ({\n            data: res\n          }) => {\n            this.setData({\n              colorList: [...this.data.colorList, ...res.data]\n            })\n          },\n          // 不论失败与否都会执行下面这个函数\n          complete: () => {\n            // loading需要自己手动关闭\n            wx.hideLoading();\n            this.setData({\n              isloading: false\n            })\n          }\n        })\n      },\n      /**\n       * 生命周期函数--监听页面加载\n       */\n      onLoad(options) {\n        this.getColors()\n      },\n    \n      /**\n       * 生命周期函数--监听页面初次渲染完成\n       */\n      onReady() {\n    \n      },\n    \n      /**\n       * 生命周期函数--监听页面显示\n       */\n      onShow() {\n    \n      },\n    \n      /**\n       * 生命周期函数--监听页面隐藏\n       */\n      onHide() {\n    \n      },\n    \n      /**\n       * 生命周期函数--监听页面卸载\n       */\n      onUnload() {\n    \n      },\n    \n      /**\n       * 页面相关事件处理函数--监听用户下拉动作\n       */\n      onPullDownRefresh() {\n    \n      },\n    \n      /**\n       * 页面上拉触底事件的处理函数\n       */\n      onReachBottom() {\n        console.log('触发上拉触底了');\n        if (this.data.isloading) {\n          return\n        } else {\n          this.getColors();\n        }\n      },\n    \n      /**\n       * 用户点击右上角分享\n       */\n      onShareAppMessage() {\n     \n      }\n    })\n    \n\n.css:\n\n    /* pages/randomColor/randomColor.wxss */\n    .num-item {\n      border: 1rpx solid #efefef;\n      border-radius: 8rpx;\n      line-height: 200rpx;\n      text-align: center;\n      margin: 15rpx;\n      text-align: center;\n      text-shadow: 0rpx 0rpx 5rpx #fff;\n      box-shadow: 2rpx 2rpx 7rpx rgb(0, 0, 0);\n    }",
        "states": "0",
        "description": "下拉刷新是移动端的专有名词,指的是通过手指在屏幕上的下拉滑动操作,从而重新加载页面数据的行为1.全局开启下拉刷新2.局部开启下拉刷新实际开发中推荐使用第二种方式局部开启:在全局或页面的.json配置文件中,通过backgroundColor和backgroundTextStyle来配置下来刷新窗口的样式,其中:如下面的例子中,button控制count的自增,下拉重置count为0(页面中不必要的代码没有copy)WXML:.js:当你下拉刷新时,其中的function会立即执行,但是下拉刷新的",
        "praise": "0",
        "view": "12",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/125603205",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T08:10:19.000Z",
        "destroyTime": null
    },
    {
        "id": 24,
        "email": "2714351312@qq.com",
        "title": "微信小程序开发中的上拉触底的节流处理",
        "content": "如下图,往下面拖动时,会触发`getColors`函数,获取颜色数据并使`colorList`自增,但是你在数据没有返回之前多次触发上拉触底,那么就会多次request\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/4246274f392b4683a212350e9a02abb2.png)\n\n> 处理:\n\n1.在data中定义idloading节流阀\n\n*   false表示当前没有进行任何数据请求\n*   true表示当前正在进行和数据请求\n\n2.在getColors()方法中修改isloading节流阀的值\n\n*   在刚调用getColors时将节流阀设置为true\n*   在网络请求的complete回调函数中,将节流阀重置为false\n\n3.在onReachBottom中判断节流阀的值,从而对数据请求进行节流控制\n\n*   如果节流阀的值为true,则阻止当前请求\n*   如果节流阀的值为false,则发起数据请求\n\n示例:\n\n.js:\n\n    // pages/randomColor/randomColor.js\n    Page({\n      /**\n       * 页面的初始数据\n       */\n      data: {\n        // 随机颜色的列表\n        colorList: [],\n        isloading: false\n      },\n      // 获取随机颜色的方法\n      getColors() {\n        this.setData({\n          isloading: true\n        })\n        wx.showLoading({\n          title: \"数据加载中...\"\n        });\n        wx.request({\n          url: 'https://www.escook.cn/api/color',\n          method: 'GET',\n          success: ({\n            data: res\n          }) => {\n            this.setData({\n              colorList: [...this.data.colorList, ...res.data]\n            })\n          },\n          // 不论失败与否都会执行下面这个函数\n          complete: () => {\n            // loading需要自己手动关闭\n            wx.hideLoading();\n            this.setData({\n              isloading: false\n            })\n          }\n        })\n      },\n      /**\n       * 生命周期函数--监听页面加载\n       */\n      onLoad(options) {\n        this.getColors()\n      },\n      /**\n       * 页面上拉触底事件的处理函数\n       */\n      onReachBottom() {\n        console.log('触发上拉触底了');\n        if (this.data.isloading) {\n          return\n        } else {\n          this.getColors();\n        }\n      },\n    \n\n触发上拉触底会判断一下`isloading`的值,如果为true,则不请求,如果为false,则请求",
        "states": "0",
        "description": "如下图,往下面拖动时,会触发函数,获取颜色数据并使自增,但是你在数据没有返回之前多次触发上拉触底,那么就会多次request1.在data中定义idloading节流阀2.在getColors()方法中修改isloading节流阀的值3.在onReachBottom中判断节流阀的值,从而对数据请求进行节流控制示例:.js:触发上拉触底会判断一下的值,如果为true,则不请求,如果为false,则请求...",
        "praise": "0",
        "view": "12",
        "audit": "1",
        "tag1": "微信小程序",
        "tag2": "note",
        "tag3": "demo",
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/125662148",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-06-02T17:33:50.000Z",
        "destroyTime": null
    },
    {
        "id": 25,
        "email": "2714351312@qq.com",
        "title": "微信小程序_9,视图与逻辑",
        "content": null,
        "states": "0",
        "description": "页面导航指的是页面之间的互相跳转,例如:浏览器中实现页面导航的方式有如下两种1.链接2.location.href1.声明式导航:2.编程式导航:tabBar页面指的是被配置为tabBar的页面在使用组件跳转到指定的tabBar页面时,需要指定url属性和open-type属性,其中:注意,这里tabBar配置的页面是需要在中的节点下配置了的页面才会进行跳转!导航到非tabBar页面:非tabBar页面指的是没有被配置为tabBar的页面在使用组件跳转到非tabBar页面时,则需要指定ur",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/125435859",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 26,
        "email": "2714351312@qq.com",
        "title": "微信小程序_8,项目练习,本地生活",
        "content": "#### 1.首页效果以及实现步骤:\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/83c604caa43d478782804aa31631606a.png)  \n1.新建项目并梳理项目结构  \n2.配置导航栏效果  \n3.配置tabBar效果  \n4.实现轮播图效果  \n5.实现九宫格效果  \n6.实现图片布局\n\ndemo:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/e44c68067b8f4473ad27efa3a82f352a.png)\n\n[项目demo文件](https://github.com/bilibili-niang/weixinprogrames/tree/main/miniprogram-1)",
        "states": "0",
        "description": "1.新建项目并梳理项目结构2.配置导航栏效果3.配置tabBar效果4.实现轮播图效果5.实现九宫格效果6.实现图片布局demo:项目demo文件",
        "praise": "0",
        "view": "2",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/125379668",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "2",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-06-08T14:05:50.000Z",
        "destroyTime": null
    },
    {
        "id": 27,
        "email": "2714351312@qq.com",
        "title": "微信小程序_7,网络数据请求",
        "content": null,
        "states": "0",
        "description": "出于安全性方面的考虑,小程序官方对数据接口的请求做出了如下两个限制:1.只能请求HTTPS类型的接口2.必须将接口的域名添加到信任列表添加到信任列表:需求描述:假设在自己的微信小程序中,希望请求域名下的接口配置步骤:登录微信小程序管理后台->开发->开发设置->服务器域名->修改request合法域名注意事项:1.域名只支持https协议2.域名不能使用IP地址或localhost3.域名必须经过ICP备案4.服务器域名一个月内最多可申请5次修改下面这里是有问题的,实际上是每个月只能修改五",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/125359589",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "1",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 28,
        "email": "2714351312@qq.com",
        "title": "微信小程序_6,页面配置",
        "content": null,
        "states": "0",
        "description": "小程序中,每个页面都有自己的.json配置文件,用来对当前页面的窗口外观,页面效果等进行配置小程序中,app.json中的window节点,可以全局配置小程序中每个页面的窗口表现如果某些小程序页面想要拥有特殊的窗口表现,此时\"页面级别的.json配置文件\"就可以实现这种需求.注意:当页面配置与全局配置冲突时,根据就近原则,最终的效果以页面配置为准例如:index的WXML:person的WXML:......",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/125359011",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 29,
        "email": "2714351312@qq.com",
        "title": "微信小程序_5,全局配置",
        "content": null,
        "states": "0",
        "description": "1.pages了解window节点常用的配置项:app.json->window->navigationBarTitleTextapp.json->window->navigationBarBackgroundColor修改导航栏文字颜色:app.json->window->navigationBarTextStyle注意这里的可选值只有black/white概念:下拉刷新是移动端的专有名词,指的是通过手指在屏幕上的下拉滑动操作,从而重新加载页面数据的行为app.json->window->ena",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/125357493",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 31,
        "email": "2714351312@qq.com",
        "title": "微信小程序_3,WXML模板语法",
        "content": null,
        "states": "0",
        "description": "事件是渲染层到逻辑层的通讯方式,通过事件可以将用户在渲染层产生的行为,反馈到逻辑层进行业务的处理当事件出回调触发的时候,会受到一个事件对象event,它的详细属性如下表所示:在开发中,用的比较多的是:,target是触发该事件的源头组件,而currentTarget则是当前事件所绑定的组件,举例如下:点击内部的按钮,点击事件以冒泡的方式向外扩散,也会触发外层view的tap事件处理函数在小程序中,不存在HTML中的onclick鼠标点击事件,而是通过tap事件来响应用户的触摸行为1.通过bindtap",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/125323347",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 32,
        "email": "2714351312@qq.com",
        "title": "微信小程序_2小程序-模板及其配置",
        "content": null,
        "states": "0",
        "description": "微信小程序一些语法格式",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/125287199",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 33,
        "email": "2714351312@qq.com",
        "title": "微信小程序_1,基础配置及其开发工具",
        "content": null,
        "states": "0",
        "description": "微信小程序开发,学习,",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/125246607",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "3",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 34,
        "email": "2714351312@qq.com",
        "title": "22年五月毕设",
        "content": null,
        "states": "0",
        "description": "又一份学术垃圾,哈哈哈",
        "praise": "0",
        "view": "4",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/125137313",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-07-05T01:15:36.000Z",
        "destroyTime": null
    },
    {
        "id": 35,
        "email": "2714351312@qq.com",
        "title": "崩坏三入坑指北",
        "content": null,
        "states": "0",
        "description": "崩坏三入坑",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/125024383",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 36,
        "email": "2714351312@qq.com",
        "title": "koa写入mysql数据库,有插入语句却没写入的问题",
        "content": null,
        "states": "0",
        "description": "注意这里fileData的数据很长post:后端:但是数据库中没有该数据如有同样问题,可以看下自己的表结构:我是这里的问题,解决:停掉nodemon,modele更改为:\tfileData: {\t\t//这里需要很长的数据长度\t\ttype: DataTypes.TEXT,\t\tallowNull: true,\t\tcomment: '文章的内容'\t},强制同步一遍,注意同步后表中的数据会丢失:markdownFile.sync({force:true})当然你也可以在表",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/124752429",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 37,
        "email": "2714351312@qq.com",
        "title": "koa中上传文件对于不支持的文件格式返回错误信息",
        "content": null,
        "states": "0",
        "description": "我这里使用的是koa-body来接受文件:const koa = require('koa')//user路由// const userRouter = require('../router/user.route')//商品路由// const goodsRouter = require('../router/goods.route')const router = require('../router')const koaBody = require('koa-body')const ko",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/124548615",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 38,
        "email": "2714351312@qq.com",
        "title": "08_让koa支持文件上传",
        "content": null,
        "states": "0",
        "description": "在koaBody中开启:const koa = require('koa')const router = require('../router')const koaBody = require('koa-body')const app = new koa()const errHandler\t= require('./errHadnler')const path = require('path')app.use(koaBody({\tmultipart: true,\tformidable:",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/124527882",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 39,
        "email": "2714351312@qq.com",
        "title": "UnhandledPromiseRejectionWarning报错send()的处理",
        "content": null,
        "states": "0",
        "description": "先看报错:(node:24460) UnhandledPromiseRejectionWarning: TypeError: Cannot read property 'send' of undefined    at getAllUser (file:///G:/MarkDownNote/vue/example_code/apiTest/controler/user_ctrl.js:6:6)       at processTicksAndRejections (internal/process/t",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/124122187",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "1",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 40,
        "email": "2714351312@qq.com",
        "title": "js的eventloop",
        "content": null,
        "states": "0",
        "description": "javascript是一门单线程语言,同时只能做一件事单线程执行任务队列的问题:如果前一个任务非常耗时,则后续的任务就不得不一直等待,从而导致程序假死的问题同步任务和异步任务:为了防止某个耗时任务导致程序假死,javascript把等待的任务分为了两类:同步任务又叫非耗时任务,指的是在主线程上排队执行的那些任务只有前一个任务执行完毕,才能执行后一个任务异步任务又叫做耗时任务,异步任务由javascript委托给宿主环境进行同步任务和异步任务的执行..",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/124086325",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 41,
        "email": "2714351312@qq.com",
        "title": "async/await",
        "content": null,
        "states": "0",
        "description": "什么是async,await?async/await是es8引入的新语法,用来简化Promise异步操作,在async/await出现之前,开发者之前只能通过链式.then()方法处理Promise异步操作,示例代码如下:console.log('promise保证读取顺序：')thenfs.readFile('./text/11.txt', 'utf8')\t.catch((err) =&gt; {\t\tconsole.log(err)\t})\t.then((r1) =&gt; {\t\tcon.",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/124065231",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 42,
        "email": "2714351312@qq.com",
        "title": "promise封装读取文件",
        "content": null,
        "states": "0",
        "description": "方法封装要求:1.方法名称要定义为:getFile2.方法接受一个形参fpath,表示要读取的文件的路径3.方法的返回值为Promise实例对象获取.then()的两个实参:通过.then()指定的成功和失败的回调函数,可以在function的形参中进行接受,示例代码如下:调用resolve和reject回调函数:Promise异步操作的结果,可以调用resolve或reject回调函数进行处理,实例代码如下:getFile方法的基本定义:import fs from .",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/124063401",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 43,
        "email": "2714351312@qq.com",
        "title": "Promise.all()和Promise.race()",
        "content": null,
        "states": "0",
        "description": "promise.all()Promise.all()方法会发起并行的promise异步操作，等所有的异步操作全部结束，才会执行下一步的.then()操作(等待机制)，实例代码：import thenfs from 'then-fs'const promises = [\tthenfs.readFile('./text/1.txt', 'utf8'),\tthenfs.readFile('./text/2.txt', 'utf8'),\tthenfs.readFile('./text/3.txt'.",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/124062297",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 44,
        "email": "2714351312@qq.com",
        "title": "mongodb$pull数组更新操作符",
        "content": "> `mycode`:\n\n    db.person.insert([\n    {name:'zs', books:[{name:'html', price:66}, {name:'js', price:88}], tags:['html', 'js', ['1', '2']]},\n    {name:'ls', books:[{name:'vue', price:99}, {name:'node', price:199}], tags:['a', 'b', 'ab', 'c', 'ac']}\n    ])\n    \n\n    db.person.find()\n    \n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a37f474edfee45c7843a3e97d8ee4a40.png)\n\ndb.person.updateOne({name:‘zs’},{$pull:{tags:‘js’}})  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/0c1ca9bea58e4e0d88a0f8e4323171f5.png)\n\n//也可以是使用正则表达式:\n\n    db.person.updateOne({name:'ls'},{$pull:{tags:/^a/}})\n    \n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/26d693ef957846c096e4bb3ae133c4fc.png)\n\n// 注意点: 如果要删除的元素是一个数组, 那么必须一模一样才能删除\n\n    db.person.updateOne({name:'zs'},{$pull:{tags:[\"2\",\"1\"]}})\n    \n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/3c85ec1553e54db3b29948c98262a026.png)\n\n    db.person.updateOne({name:'zs'},{$pull:{tags:[\"1\",\"2\"]}})\n    \n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/138c1385996d44d5b2e5290695c06284.png)\n\n// 注意点: 如果要删除的元素是一个文档, 那么不用一模一样也可以删除\n\n    db.person.updateOne({name:'zs'},{$pull:{books:{price:66,name:'html'}}})\n    \n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/5df64888b69e4e6a8b40be14cbc04c92.png)\n\n//只要有一个匹配的就会把整个文档删掉\n\n    db.person.updateOne({name:'zs'},{$pull:{books:{name:'js'}}})\n    \n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/795a7f4f6ffd40e4a3b70d525fb4a412.png)\n\n> `teacher's code`;\n\n1.$pull数组更新操作符  \nKaTeX parse error: Expected '}', got 'EOF' at end of input: …字段中删除特定元素 格式: {pull: {:<value|condition>, …}}\n\n2.示例  \ndb.person.insert(\\[  \n{name:‘zs’, books:\\[{name:‘html’, price:66}, {name:‘js’, price:88}\\], tags:\\[‘html’, ‘js’, \\[‘1’, ‘2’\\]\\]},  \n{name:‘ls’, books:\\[{name:‘vue’, price:99}, {name:‘node’, price:199}\\], tags:\\[‘a’, ‘b’, ‘ab’, ‘c’, ‘ac’\\]}  \n\\])  \n删除特定元素  \n根据条件删除元素  \ndb.person.update({name:‘zs’}, {KaTeX parse error: Expected 'EOF', got '}' at position 17: …ull:{tags:'js'}}̲) db.person.upd…pull:{tags:/^a/}})\n\n3.注意点  \n// 注意点: 如果要删除的元素是一个数组, 那么必须一模一样才能删除  \ndb.person.update({name:‘zs’}, {KaTeX parse error: Expected 'EOF', got '}' at position 23: …ags:\\['2', '1'\\]}}̲) db.person.upd…pull:{tags:\\[‘1’, ‘2’\\]}})  \n// 注意点: 如果要删除的元素是一个文档, 那么不用一模一样也可以删除  \ndb.person.update({name:‘zs’}, {KaTeX parse error: Expected 'EOF', got '}' at position 37: …, name:'html'}}}̲) db.person.upd…pull:{books:{name:‘js’}}})",
        "states": "0",
        "description": "mycode:db.person.insert([{name:'zs', books:[{name:'html', price:66}, {name:'js', price:88}], tags:['html', 'js', ['1', '2']]},{name:'ls', books:[{name:'vue', price:99}, {name:'node', price:199}], tags:['a', 'b', 'ab', 'c', 'ac']}])db.person.find().",
        "praise": "0",
        "view": "15",
        "audit": "1",
        "tag1": "mongodb",
        "tag2": "demo",
        "tag3": "nodejs",
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/123216390",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-06-02T17:33:53.000Z",
        "destroyTime": null
    },
    {
        "id": 45,
        "email": "2714351312@qq.com",
        "title": "then-fs的使用",
        "content": "*   由于nodejs官方提供的fs模块仅支持以回调函数的方式读取文件,不支持promise的回调方式,因此,需要先运行如下命令,安装then-fs这个第三方包,从而支持我们基于promise的方式读取文件内容:\n    \n*   调用then-fs提供的readFile()方法,可以异步地读取文件的内容,它的返回值是Promise的实例对象,因此可以调用.then()方法为每一个Promise异步操作指定成功和失败之后的回调函数\n    \n\n> 基于then-fs读取文件内容:\n\n由于nodejs官方提供的fs模块仅支持以回调函数的方式读取文件,不支持promise的回调方式,因此,需要先运行如下命令,安装then-fs这个第三方包,从而支持我们基于promise的方式读取文件内容:\n\n    npm i then-fs\n    \n\n> then-fs的基本使用:\n\n调用then-fs提供的readFile()方法,可以异步地读取文件的内容,它的返回值是Promise的实例对象,因此可以调用.then()方法为每一个Promise异步操作指定成功和失败之后的回调函数,示例代码如下:\n\n    import thenfs from 'then-fs'\n    \n    thenfs.readFile('./text/1.txt', 'utf8').then((r1) => {\n    \tconsole.log(r1)\n    })\n    thenfs.readFile('./text/2.txt', 'utf8').then((r2) => {\n    \tconsole.log(r2)\n    })\n    thenfs.readFile('./text/3.txt', 'utf8').then((r3) => {\n    \tconsole.log(r3)\n    })\n    \n\n> .then()方法的特性：\n\n如果上一个.then()方法中返回了一个新的Promise实例对象，则可以通过下一个.then()继续进行处理，通过.then()方法的链式调用，就解决了回调地狱的问题\n\n    import thenfs from 'then-fs'\n    \n    thenfs.readFile('./text/1.txt', 'utf8')\n    \t.then((r1) => {\n    \t\tconsole.log(r1)\n    \t\treturn thenfs.readFile('./text/2.txt', 'utf8')\n    \t})\n    \t.then((r2) => {\n    \t\tconsole.log(r2)\n    \t\treturn thenfs.readFile('./text/3.txt', 'utf8')\n    \t})\n    \t.then((r3) => {\n    \t\tconsole.log(r3)\n    \t})\n    \n    \n\n> 通过.catch捕获错误：\n\n在promise的链式调用中如果发生了错误，可以使用Promise.prototype.catch方法进行捕获和处理\n\n    thenfs.readFile('./text/11.txt', 'utf8')\n    \t.then((r1) => {\n    \t\tconsole.log(r1)\n    \t\treturn thenfs.readFile('./text/2.txt', 'utf8')\n    \t})\n    \t.then((r2) => {\n    \t\tconsole.log(r2)\n    \t\treturn thenfs.readFile('./text/3.txt', 'utf8')\n    \t})\n    \t.then((r3) => {\n    \t\tconsole.log(r3)\n    \t})\n    \t.catch((err) => {\n    \t\tconsole.log(err)\n    \t})\n    \n\nrun:\n\n    \"C:\\Program Files\\nodejs\\node.exe\" G:\\MarkDownNote\\vue\\example_code\\4_then-fs读取.js\n    promise保证读取顺序：\n    [Error: ENOENT: no such file or directory, open 'G:\\MarkDownNote\\vue\\example_code\\text\\11.txt'] {\n      errno: -4058,\n      code: 'ENOENT',\n      syscall: 'open',\n      path: 'G:\\\\MarkDownNote\\\\vue\\\\example_code\\\\text\\\\11.txt'\n    }\n    \n    进程已结束,退出代码0\n    \n\n注意上面是报错后就不再继续往后执行\n\n*   如果不希望前面的错误导致后续的.then()无法正常执行，则可以将.catch的调用提前，实例代码如下：\n\n    thenfs.readFile('./text/11.txt', 'utf8')\n    .catch((err) => {\n    console.log(err)\n    })\n    .then((r1) => {\n    console.log(r1)\n    return thenfs.readFile('./text/2.txt', 'utf8')\n    })\n    .then((r2) => {\n    console.log(r2)\n    return thenfs.readFile('./text/3.txt', 'utf8')\n    })\n    .then((r3) => {\n    console.log(r3)\n    })\n    \n\nrun:\n\n    \"C:\\Program Files\\nodejs\\node.exe\" G:\\MarkDownNote\\vue\\example_code\\4_then-fs读取.js\n    promise保证读取顺序：\n    [Error: ENOENT: no such file or directory, open 'G:\\MarkDownNote\\vue\\example_code\\text\\11.txt'] {\n      errno: -4058,\n      code: 'ENOENT',\n      syscall: 'open',\n      path: 'G:\\\\MarkDownNote\\\\vue\\\\example_code\\\\text\\\\11.txt'\n    }\n    undefined\n    2.txt的内容\n    3.txt的内容\n    \n    进程已结束,退出代码0\n    \n\n上面是报错后继续往后执行",
        "states": "0",
        "description": "由于nodejs官方提供的fs模块仅支持以回调函数的方式读取文件,不支持promise的回调方式,因此,需要先运行如下命令,安装then-fs这个第三方包,从而支持我们基于promise的方式读取文件内容:调用then-fs提供的readFile()方法,可以异步地读取文件的内容,它的返回值是Promise的实例对象,因此可以调用.then()方法为每一个Promise异步操作指定成功和失败之后的回调函数读取文件:import thenfs from 'then-fs'thenfs.r..",
        "praise": "0",
        "view": "10",
        "audit": "1",
        "tag1": "javacsript",
        "tag2": "note",
        "tag3": "demo",
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/124059986",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "3",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-06-02T17:33:56.000Z",
        "destroyTime": null
    },
    {
        "id": 46,
        "email": "2714351312@qq.com",
        "title": "mongodb删除文档",
        "content": "> `mycode`:\n\n    db.person.insert([\n    {name:'zs', age:18},\n    {name:'zs', age:19},\n    {name:'ls', age:20},\n    {name:'ls', age:21},\n    {name:'ww', age:22},\n    {name:'zl', age:23},\n    ])\n    \n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/3ef3b2019881465885a931123fb43172.png)\n\n*   //注意点:和update方法不同,remove默认会删除满足条件的所有数据\n\n    db.person.remove({name:'zs'})\n    \n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/b22fb165dca14eaea0ff0357930c2c92.png)\n\n*   //删除第一个满足条件的数据:\n\n    db.person.remove({name:'ls'},{justOne:true})\n    \n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/4f1945919e9b4393ab988196b2abd3cb.png)\n\n*   //删除所有文档:\n\n    db.person.remove({})\n    \n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/6bfbc64aac824fecb9dd7f6b5cfd4621.png)\n\n> `teacher's code`:\n\n*   1.删除文档  \n    db..remove(, )  \n    : 删除筛选条件  \n    : 删除额外配置\n    \n*   2.示例\n    \n\n    db.person.insert([\n    {name:'zs', age:18},\n    {name:'zs', age:19},\n    {name:'ls', age:20},\n    {name:'ls', age:21},\n    {name:'ww', age:22},\n    {name:'zl', age:23},\n    ])\n    \n\n*   2.示例\n*   2.1删除所有满足条件  \n    注意点: 和update方法不同, remove方法默认就会删除所有满足条件的数据\n\n    db.person.remove({name:'zs'})\n    \n\n*   2.2删除第一个满足条件\n\n    db.person.remove({name:'ls'},{justOne:true})\n    \n\n*   2.3删除所有文档\n\n    db.person.remove({})",
        "states": "0",
        "description": "mycode:db.person.insert([{name:'zs', age:18},{name:'zs', age:19},{name:'ls', age:20},{name:'ls', age:21},{name:'ww', age:22},{name:'zl', age:23},])//注意点:和update方法不同,remove默认会删除满足条件的所有数据db.person.remove({name:'zs'})//删除第一个满足条件的数据:db.pe.",
        "praise": "0",
        "view": "3",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/123216446",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-07-07T02:02:23.000Z",
        "destroyTime": null
    },
    {
        "id": 47,
        "email": "2714351312@qq.com",
        "title": "mongodb数组更新操作符$push",
        "content": null,
        "states": "0",
        "description": "/*1.$push数组更新操作符KaTeX parse error: Expected '}', got 'EOF' at end of input: …不去重)格式     : {push: {:, …}}*/show databases;db.person.find()db.person.updateOne({name:'zs'},{$push:{tags:'react'}})再次执行:db.person.updateOne({name:'zs'},{$push:{tags:'",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/123216380",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 48,
        "email": "2714351312@qq.com",
        "title": "mongodb数组更新操作符$addToSet",
        "content": null,
        "states": "0",
        "description": "mycode://example:db.person.insert([{name:'zs', books:[{name:'html', price:66}, {name:'js', price:88}], tags:['html', 'js']},{name:'ls', books:[{name:'vue', price:99}, {name:'node', price:199}], tags:['vue', 'node']}])//在name为zs的字段中的tags增添一个vuedb..",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/123216351",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "5",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 49,
        "email": "2714351312@qq.com",
        "title": "mongodb更新操作符$min,$max",
        "content": null,
        "states": "0",
        "description": "mycodedb.person.deleteOne({name:'lnj'})db.person.insertOne({name:'zs',age:18})//$min是用min指定的值和原来的值比较,看谁小,留下下的数值db.person.updateOne({'name':'zs'},{$min:{age:5}})//$max是用max指定的值和原来的值比较,看谁大,留下大的数值db.person.updateOne({'name':'zs'},{$max:{age:33}})/.",
        "praise": "0",
        "view": "12",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/123216323",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 50,
        "email": "2714351312@qq.com",
        "title": "mongodb更新操作符$inc,$mul",
        "content": null,
        "states": "0",
        "description": "mycodedb.person.insertOne({name:'lnj',age:33})db.person.find()db.person.updateOne({name:'lnj'},{$inc:{age:-3}})db.person.updateOne({name:'lnj'},{$inc:{age:+5}})//乘5db.person.updateOne({name:'lnj'},{$mul:{age:5}})//除2db.person.updateOne({name:'.",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/123216296",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "1",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 51,
        "email": "2714351312@qq.com",
        "title": "mongodb更新操作符$rename",
        "content": null,
        "states": "0",
        "description": "mycode:db.person.find()//对zs的字段名修改为了mynamedb.person.update({name:'zs'},{$rename:{name:'myname'}})//注意:如果修改的是文档字段中的字段,那么取值必须写上层级关系db.person.update({name:'ww'},{$rename:{'book.name':'book.bookname'}})//如果要操作的字段不存在,那么不会进行任何操作//注意:如果重命名之后的名称已经存在,那么之.",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/123216270",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 52,
        "email": "2714351312@qq.com",
        "title": "mongodb更新操作符$unset",
        "content": null,
        "states": "0",
        "description": "mycodedb.person.find()//这里要删除ls的score字段,随便给一个值即可db.person.update({‘name’:‘ls’},{$unset:{‘score’:’’}})//注意:如果使用unset删除某一个字段,那么后面赋值为任何内容都不重要//删除文档字段中的字段db.person.update({name:‘ww’},{$unset:{‘book.price’:’’}})//删除数组字段中的元素,//这里删除中间的元素并不会修改它的长度,只会填为nu.",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/123216247",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "1",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 53,
        "email": "2714351312@qq.com",
        "title": "mongodb更新操作符",
        "content": null,
        "states": "0",
        "description": "mycode:db.person.insert([{name:'zs', age:18},{name:'ls', age:19},{name:'ww', age:20},{name:'zs', age:21},])db.person.find()db.person.update({name:'ww'},{age:90})//更新部分字段而不是覆盖db.person.update({name:'ww'},{$set:{age:55}})// 更新所有:db.person.up.",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/123216232",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 54,
        "email": "2714351312@qq.com",
        "title": "mongodb统计函数",
        "content": null,
        "states": "0",
        "description": "统计函数cursor.count(): 统计集合中文档的个数applySkipLimit默认为false, 表示忽略skip和limit2.示例db.person.find().count()// 注意点: count函数可以接收一个applySkipLimit参数, 通过这个参数可以告诉MongoDB在统计的时候是否需要忽略Skip和Limit//      默认情况下applySkipLimit的取值是false, 表示忽略Skip和Limitdb.person.find().skip",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/123216169",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "0",
        "diggCount": "0",
        "articleType": "2",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 55,
        "email": "2714351312@qq.com",
        "title": "mongodb更新操作",
        "content": "##### 更新文档\n\n> MongoDB中有三个常用的更新方法: save()/update()/findAndmodify()\n\n###### save方法\n\nsave用于往集合里添加一个新文档或者覆盖文档  \n当没有指定文档\\_id的时候就是新增  \n当指定了集合中已经存在的\\_id的时候就是覆盖\n\n###### 示例\n\n    db.person.insert([\n    {name:'zs', age:18},\n    {name:'ls', age:19},\n    {name:'ww', age:20},\n    {name:'zs', age:21},\n    ])\n    \n\n###### update方法\n\n    db.collection.update(<filter>, <update>, <options>)\n    <filter>: 筛选条件\n    <update>: 新的内容\n    <options>: 额外配置\n    \n\n###### 通过update覆盖满足条件数据\n\n默认情况下如果没有使用更新操作符, 那么就会使用指定的内容覆盖符合条件的内容  \n例如:\n\n    db.person.update({name:'ww'},{age:90},{})\n    \n\n在第二个对象中并未指定它的name,那么就会空出来:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/f5a4917e4b494c4d8574f9fb98d6822f.png)\n\n###### 示例:\n\ndb.person.update({name:‘lnj’}, {name:‘zs’})\n\n###### 注意点:\n\n> update方法默认情况下就是覆盖\n\n//如果不想覆盖, 而是想单纯的更新, 那么就必须在第二个参数中使用’更新操作符’  \ndb.person.update({name:‘ww’},{score: 99.9},{})\n\n> update方法默认只会更新满足条件的第一个文档\n\n//如果想更新所有满足条件的文档, 那么就必须指定第三个参数  \ndb.person.update({name:‘zs’}, {name:‘zs’, age:55}, {})\n\n> 注意点: 如果在使用update方法的时候, 在第二个参数中指定了\\_id, 那么就必须保证指定的\\_id和被更新的文档的\\_id的取值一致  \n> //否则就无法更新, 否则就会报错\n\n// 开发技巧: 在企业开发中如果需要使用update方法, 那么就不要指定\\_id  \ndb.person.update({name:‘zs’}, {\\_id:1, name:‘zs’, age:55}, {})  \ndb.person.update({name:‘zs’}, {\\_id:ObjectId(“5e9007350718cb6e37ab4515”), name:‘zs’, age:88}, {})\n\n> 注意点: 如果想更新所有满足条件的文档, 我们可以指定第三个参数的取值multi:true  \n> // 注意点: 如果指定了multi:true, 那么就必须在第二个参数中使用’更新操作符’  \n> db.person.update({name:‘zs’}, {name:‘zs’, age:55}, {multi:true})\n\n    show databases;\n    use usser;\n    \n    show collections;\n    db.person.find()\n    \n    db.person.remove()\n    \n    db.person.insert([\n    {name:'zs', age:18},\n    {name:'ls', age:19},\n    {name:'ww', age:20},\n    {name:'zs', age:21},\n    ])\n    \n\n//save已被启用  \ndb.person.save({age:666,name:‘it6666’})  \ndb.person.insertOne({age:666,name:‘it6666’})  \ndb.person.update({\\_id:ObjectId(“61d130de0ea303199c46109f”)},{score:39.6})\n\n> 注意这里在java的driver中会有问题(比如DG的mongodb驱动就是java的,会报错)\n\n//update默认就是覆盖,如果不想覆盖,而是单纯��更新部分数据,那么就需要使用更新操作符:  \ndb.person.update({name:‘ww’},{age:90},{})\n\n//更新数据中的连个zs的age,但是update默认只会更新第一个  \ndb.person.update({name:‘zs’},{name:‘zs’,age:50})  \n//如果想更新满足条件的所有文档,那么必须指定第三个参数:\n\n> 如果在使用update的时候,在第二个参数中指定了\\_id,那么就必须保证指定的\\_id和被更新的文档的\\_id的取值一致\n\n//否则就会报错\n\n    db.person.update({name:'zs'},{_id:1,name:'zs',age:50})\n    \n\n// 开发技巧: 在企业开发中如果需要使用update方法, 那么就不要指定\\_id\n\n> 如果指定了multi为true,那么就必须在第二个参数中使用更新操作符,否则是覆盖,会报错\n\n//db.person.update({name:‘zs’},{name:‘zs’,age:50},{multi:true})  \n`err`:\n\n    WriteResult({\n        \"nMatched\" : 0,\n        \"nUpserted\" : 0,\n        \"nModified\" : 0,\n        \"writeError\" : {\n            \"code\" : 9,\n            \"errmsg\" : \"multi update is not supported for replacement-style update\"\n        }\n    })",
        "states": "0",
        "description": "更新文档MongoDB中有三个常用的更新方法: save()/update()/findAndmodify()save方法save用于往集合里添加一个新文档或者覆盖文档当没有指定文档_id的时候就是新增当指定了集合中已经存在的_id的时候就是覆盖示例db.person.insert([{name:'zs', age:18},{name:'ls', age:19},{name:'ww', age:20},{name:'zs', age:21},])update方法db.col",
        "praise": "0",
        "view": "2",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/123216202",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "0",
        "diggCount": "0",
        "articleType": "2",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-05-08T02:13:59.000Z",
        "destroyTime": null
    },
    {
        "id": 56,
        "email": "2714351312@qq.com",
        "title": "mongodb分页方法",
        "content": null,
        "states": "0",
        "description": "分页方法cursor.limit(<number>): 取多少个文档cursor.s",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/122850731",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-04-27T07:57:47.000Z",
        "destroyTime": null
    },
    {
        "id": 57,
        "email": "2714351312@qq.com",
        "title": "mongodb排序函数",
        "content": "#### 排序函数\n\n    cursor.sort({field: ordering, ...}): 按照指定规则排序\n    ordering为1表示升序排序\n    ordering为-1表示降序排序\n    \n\n###### 示例\n\n// 注意点: 默认情况下find方法只会返回100个文档\n\n    db.person.find()\n    db.person.insert({name:'itzb', age:15})\n    db.person.find().limit(101)\n    db.person.find().sort({age:1})\n    db.person.find().sort({age:-1})\n    \n\n###### 注意点\n\n3.1find方法默认只会取出100个文档  \n3.2sort函数永远在分页函数之前执行\n\n    db.person.find().skip(5).limit(5)\n    db.person.find().skip(5).limit(5).sort({age:-1})\n    \n\n> code:\n\n    show databases;\n    use usser;\n    show collections;\n    \n    db.person.find()\n    \n    db.person.insertOne({name:'itzb',age:12})\n    \n    //注意:默认情况下find方法只会返回100个文档\n    //返回指定数量:\n    db.person.find().limit(500)\n    //指定年龄升序\n    db.person.find().sort({age:1}).limit(200)\n    //指定年龄降序\n    db.person.find().sort({age:-1}).limit(200)\n    \n\n**_注意:sort函数如果和limit,skip一起使用的时候,无论sort写在前面还是后面,都会先执行sort函数_**",
        "states": "0",
        "description": "排序函数```shellcursor.sort({field: ordering, ..",
        "praise": "0",
        "view": "2",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/122850746",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:47.000Z",
        "updatedAt": "2023-05-08T02:13:52.000Z",
        "destroyTime": null
    },
    {
        "id": 58,
        "email": "2714351312@qq.com",
        "title": "mongodb的文档游标",
        "content": "#### 文档游标\n\n###### 为什么学习前端都要学习MongoDB?\n\n> 因为MongoDB原生就支持JavaScript, 也就是我们可以直接在MongoDB中混入JS代码\n\n###### 什么是文档游标\n\n我们执行find方法后, find方法其实是有返回值的, find方法会返回一个文档游标(相当于C语言指针)\n\n###### 文档游标常用方法\n\nhasNext(): 是否还有下一个文档  \nnext(): 取出下一个文档  \nforEach(): 依次取出所有文档\n\n###### 文档游标注意:\n\n默认情况下通过文档游标遍历完所有文档后, 系统会在10分钟后自动关闭当前游标  \n如果不想自动关闭, 我们可以通过noCursorTimeout函数来保持游标一直有效:\n\n    var cursor = db.person.find().noCursorTimeout()\n    \n\n如果想手动关闭游标, 我们也可以通过close函数来手动关闭游标\n\n    cursor.close()\n    \n\n###### 示例:\n\n    // 需求: 往person集合中插入100个文档\n    var arr =[];\n    for(var i = 0; i < 100; i++){\n      arr.push({name:'it'+i, age:18+i});\n    }\n    db.person.insertMany(arr)\n    \n    \n    var cursor = db.person.find().noCursorTimeout()\n    //cursor[0]\n    //cursor[1]\n    while(cursor.hasNext()){\n       printjson(cursor.next())\n    }\n    \n    cursor.forEach(printjson)\n    cursor.close()\n    */\n    \n    //需求,往person集合中插入个文档:\n    //db.person.insertOne({})\n    //db.person.insertMany({})\n    /*var arr=[];\n    for(var i=0;i<100;i++){\n        arr.push({name:'it'+i,age:18+i});\n    }\n    db.person.insertMany(arr)*/\n    \n    //我们在执行find之后会有一个返回值的,它会返回一个文档游标(相当于c与语言的指针)\n    var cursor=db.person.find()\n    cursor[10]\n    \n    /*while(cursor.hasNext()){\n        printjson(cursor.next())\n    }*/\n    \n    //forEach,会对查询到的所有文档进行遍历,这里是遍历并打印所有\n    //cursor.forEach(printjson)",
        "states": "0",
        "description": "文档游标, 为什么学习前端都要学习MongoDB?> 因为MongoDB原生",
        "praise": "0",
        "view": "2",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/122850714",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-08T02:13:39.000Z",
        "destroyTime": null
    },
    {
        "id": 59,
        "email": "2714351312@qq.com",
        "title": "mongodb运算操作符",
        "content": null,
        "states": "0",
        "description": "运算操作符1.运算操作符{ &lt;field&gt;: { $regex: /pattern/, $options: '&lt;options&gt;' } }{ &lt;field&gt;: { $regex: /pattern/&lt;options&gt; } }查询满足正则的文档示例db.person.insert([{name:'zs', age:18},{name:'ls', age:19},{name:'ww', age:17},{name:'Zsf', age:18}",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/122850706",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 60,
        "email": "2714351312@qq.com",
        "title": "mongodb数组操作符",
        "content": null,
        "states": "0",
        "description": "数组操作符/*$all      : 匹配数组中包含所有指定查询值的文档{&lt;field&gt;: {$all: [&lt;value1&gt;, &lt;value2&gt;, ...]}}$elemMatch: 匹配数组中至少有一个能完全匹配所有的查询条件的文档{&lt;field&gt;: {$elemMatch: {&lt;query1&gt;, &lt;query2&gt;, ...}}}2.示例查询tags中同时拥有html和js的文档db.person.insert([",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/122850664",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 61,
        "email": "2714351312@qq.com",
        "title": "mongodb的字段操作符",
        "content": "//字段操作服符\n\n    db.person.remove()\n    \n    db.person.insert([\n    {name:'zs', age:17, gender:'男'},\n    {name:'ls', age:18},\n    {name:'ww', age:19},\n    {name:'it666', age:20, gender:'女'}\n    ])\n    \n    //需求:要求查询出所有拥有gender属性的文档:\n    db.person.find({gender:{$exists:true}})\n    //查询出所有男性:\n    \n    //应用场景:配合$ne/$nor/$not来清理数据\n    db.person.find({gender:{$ne:'男'}})\n    //查询出不是男且字段不为空的人:\n    db.person.find({gender:{$ne:'男',$exists:true}})\n    \n    db.person.insert([\n    {name:'itzb', age:'88'},\n    {name:'lnj', age:'999'}\n    ])\n    \n    db.person.find()\n    \n    //查出所有年龄为字符串的文档\n    db.person.find({age:{$type:'string'}})",
        "states": "0",
        "description": "//字段操作服符db.person.remove()db.person.insert([{name:'zs', age:17, gender:'男'},{name:'ls', age:18},{name:'ww', age:19},{name:'it666', age:20, gender:'女'}])//需求:要求查询出所有拥有gender属性的文档:db.person.find({gender:{$exists:true}})//查询出所有男性://应用场景:配合$ne/$n",
        "praise": "0",
        "view": "5",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/122850655",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 62,
        "email": "2714351312@qq.com",
        "title": "mongodb逻辑操作符",
        "content": null,
        "states": "0",
        "description": "//逻辑操作符:/*$not: 匹配条件不成立的文档{&lt;field&gt;: {$not: {&lt;expression&gt;}}}$and: 匹配条件全部成立的文档{&lt;field&gt;: {$and: [{&lt;expression1&gt;}, {&lt;expression2&gt;}, ...}]}$or : 匹配至少一个条件成立的文档{&lt;field&gt;: {$or: [{&lt;expression1&gt;}, {&lt;expression2&gt;",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/122850645",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 63,
        "email": "2714351312@qq.com",
        "title": "mongodb比较操作符笔记",
        "content": "#### 比较操作符\n\n    //和MySQL一样, MongodDB中也支持很多比较操作符\n    //$eq: 等于 / $ne: 不等于\n    //$gt: 大于 / $gte: 大于等于\n    //$lt: 小于 / $lte: 小于等于\n    \n    /*\n    2.使用格式\n    db.<collection>.find(\n        {<field>: {$<operator>: <value>}},\n        <projection>\n    )\n    */\n    show databases;\n    \n    use usser\n    \n    db.person.remove()\n    db.person.insert([{name:'zs', age:17, gender:'男'},{name:'ls', age:18},{name:'ww', age:19}])\n    db.person.find()\n    \n    //查询zs\n    db.person.find({name:'zs'})//默认情况下就是按照相等来判断\n    \n    db.person.find({name:{$eq:'zs'}})//或者明确告诉它要相等的字段\n    \n    db.person.find({age:{$gte:'18'}})//大于等于\n    \n    db.person.find({age:{$lt:'18'}})//小于\n    \n    db.person.find({age:{$ne:'18'}})//不等于\n    \n    //注意点:在做不等于判断的时候,没有需要判断的字段,也算作是不等于\n    db.person.find({gender:{$ne:'女'}})//不等于\n    \n\n#### 其它比较操作符\n\n    /*\n    $in: 匹配和任意指定值相等的文档\n    $nin:匹配和任意指定值都不相等的文档\n    */\n    \n    /*\n    2.使用格式\n    db.<collection>.find(\n        {<field>: {$<operator>: [<value1>, <value2>, ...]}},\n        <projection>\n    )\n    */\n    \n    db.person.find()\n    \n    //name为zs或者ls的字段\n    db.person.find({name:{$in:['zs','ls']}})\n    \n    //匹配name不为zs或者ls的人\n    db.person.find({name:{$nin:['zs','ls']}})\n    \n    //注意:和$neq一样,如果没有需要判断的字段,也算满足条件\n    db.person.find({gender:{$nin:['男','女']}})",
        "states": "0",
        "description": "比较操作符//和MySQL一样, MongodDB中也支持很多比较操作符//$eq: 等于 / $ne: 不等于//$gt: 大于 / $gte: 大于等于//$lt: 小于 / $lte: 小于等于/*2.使用格式db.&lt;collection&gt;.find(    {&lt;field&gt;: {$&lt;operator&gt;: &lt;value&gt;}},    &lt;projection&gt;)*/show databases;use usser",
        "praise": "0",
        "view": "2",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/122850633",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-08T02:14:10.000Z",
        "destroyTime": null
    },
    {
        "id": 64,
        "email": "2714351312@qq.com",
        "title": "指定mongodb允许所有端口访问",
        "content": null,
        "states": "0",
        "description": "mongod  --bind_ip_all",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/122850606",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "0",
        "diggCount": "0",
        "articleType": "2",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 65,
        "email": "2714351312@qq.com",
        "title": "mongodb的条件查询笔记",
        "content": null,
        "states": "0",
        "description": "show databases;use usserdb.person.remove({})//删掉所有db.person.insert([{name:'zs', age:17, gender:'男'},{name:'ls', age:18},{name:'ww', age:19}])db.person.insert([{name:'zs', age:16, gender:'男'},{name:'zs', age:18},{name:'zs', age:19}])db.person.find()",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/122850611",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 66,
        "email": "2714351312@qq.com",
        "title": "关于js中的判断数组为空的问题",
        "content": null,
        "states": "0",
        "description": "如果你在查询一个文档,它啥都没存,但是doc就是返回了一个[]:        User.find({email: userEmail}, {avatar: 1}, function (err, doc) {            let usericon = doc[0].avatar;            markdownFile.find({}, {                markdownId: 1            }, function (err, doc) {     ",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/122850554",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 67,
        "email": "2714351312@qq.com",
        "title": "关于mongodb的可视化工具:nosql manager for mongodb",
        "content": null,
        "states": "0",
        "description": "在shell(mongodb自带的shell)中指定使用一个数据库:use user好像这个工具没啥好说的,就挺好用,就是界面不然jetbrains的DG关于数据插入:插入有insertOne和savedb.person.insertOne({document})在插入时mongodb会有写入的安全级别,这个安全级别越高,写入越不容易出错,但同时,它消耗的内存会更多insertOne和save在保存插入数据的时候,如果要保存的数据库不存在,那么就会新建一个insertOne和sa.",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/122850550",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 68,
        "email": "2714351312@qq.com",
        "title": "uniapp使用android studio进行调试的配置",
        "content": null,
        "states": "0",
        "description": "adb路径（一般安装android studio后的默认路径是这个）：C:\\Users\\Administrator\\AppData\\Local\\Android\\Sdk\\platform-tools\\adb.exeandroid studio的模拟器端口：5554注意这里仅仅指android studio在uniapp中的配置，每种模拟器的端口是不同的配置之后，你还需要启动android studio中的模拟器（在android studio中启动），否则uniapp是检测不到模拟器的...",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/121866820",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "2",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 69,
        "email": "2714351312@qq.com",
        "title": "安卓布局，GridLayout",
        "content": null,
        "states": "0",
        "description": "布局代码：&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;GridLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    android:layout_width=\"match_parent\"    android:layout_height=\"match_parent\"&gt;    &lt;Button        android:layout_width=\"",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/121866796",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 70,
        "email": "2714351312@qq.com",
        "title": "关于使用hexo搭建博客并实现实时编写markdown的思路",
        "content": null,
        "states": "0",
        "description": "这里只是提供一个思路我这边使用的是阿里云主机跑的hexohexo在80端口使用,域名绑定主机并备案(国内主机需备案)使用的就是:hexo s --debug -p 80关于后端的文章编写使用的是 hexo-admin我的网站: www.icestone.work搭建个人博客方便管理,自定义化程度更高,无广告,可以做到自己对网站上的文章是比较了解的随着文章愈来愈多,现在已经有360篇了,在网站上浏览还好,但是使用hexo-admin查看时就需要加载几秒,甚至是十秒,这就很不爽了文章的编辑界.",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/121024478",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 71,
        "email": "2714351312@qq.com",
        "title": "使用vscode连接阿里云服务器报错: ssh: Could not resolve hostname Name or service not known",
        "content": null,
        "states": "0",
        "description": "ssh: Could not resolve hostname Name or service not knownvscode配置里面你把那个hostname不写试试连接Host 公网ip    Port 22    User root找了半夜问题,轻松跳过",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/120916290",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "4",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 72,
        "email": "2714351312@qq.com",
        "title": "ListView练习_购物商城",
        "content": null,
        "states": "0",
        "description": "ps:用的时候记者改包名,要不然跑不了,对着红色的包名按下。(如果你用的是android studio)即可。",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/120722019",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "6",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 73,
        "email": "2714351312@qq.com",
        "title": "android开发,加法,上课写的demo",
        "content": "> [个人blog网站](http://www.icestone.top/)\n\n> 前言:写错了思路,没按照老师的要求写,但是可以用  \n> ps:文章排版可能会出错,毕竟是用别人的框架  \n> ps:用的时候记着改一下包名\n\n`MainActivity.java`:\n\n    package com.example.calculate;\n    \n    import androidx.appcompat.app.AlertDialog;\n    import androidx.appcompat.app.AppCompatActivity;\n    \n    import android.annotation.SuppressLint;\n    import android.content.DialogInterface;\n    import android.os.Bundle;\n    import android.view.View;\n    import android.widget.Button;\n    import android.widget.EditText;\n    import android.widget.TextView;\n    \n    public class MainActivity extends AppCompatActivity implements View.OnClickListener {\n    \n        //    创建对象，此时还是空的\n        Button SubmitButton;\n        //    随机数计算的按钮\n        Button random;\n        //    创建第一，二个数字的空对象\n        EditText num1, num2;\n        //        给数据并核算的两个数字id：\n        TextView num3, num4;\n    \n        @Override\n        protected void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n            setContentView(R.layout.activity_main);\n            SubmitButton = findViewById(R.id.submitButton);\n    //        一键生成随机数\n            random = findViewById(R.id.randomNum);\n            SubmitButton.setOnClickListener(this);\n            random.setOnClickListener(new mClick());\n            num1 = findViewById(R.id.firstNum);\n            num2 = findViewById(R.id.secondNum);\n        }\n    \n        //自定义方法\n        class mClick implements View.OnClickListener {\n            public void onClick(View v) {\n    //生成随机数：\n                int num1 = (int) ((Math.random() * 100));\n                int num2 = (int) ((Math.random() * 100));\n                //            弹出对话框\n    //        生命对象\n                AlertDialog dialog;\n                AlertDialog.Builder builder;\n                builder = new AlertDialog.Builder(MainActivity.this)\n                        .setTitle(\"相加的计算结果\")\n                        .setIcon(R.mipmap.ic_launcher)\n                        .setMessage(num1 + \" + \" + num2 + \" = \" + (num1 + num2))\n                        .setPositiveButton(\"确定\", new DialogInterface.OnClickListener() {\n                            @Override\n                            public void onClick(DialogInterface dialog, int which) {\n                                dialog.dismiss();//关闭对话框\n                                MainActivity.this.finish();//关闭MainActivity\n                            }\n                        })\n                        .setNegativeButton(\"取消\", new DialogInterface.OnClickListener() {\n                            @Override\n                            public void onClick(DialogInterface dialog, int which) {\n                                dialog.dismiss();\n                            }\n                        });\n                dialog = builder.create();\n                dialog.show();\n    \n            }\n        }\n    \n        @Override\n        public void onClick(View view) {\n    /*        AlertDialog.Builder builder = new AlertDialog.Builder(this);\n            builder.setTitle(\"test标题\");\n            builder.setIcon(R.drawable.ic_launcher_background);\n            builder.setMessage(\"测试对话框弹出文字\");\n            builder.setCancelable(true);*/\n    \n    \n    //获取输入的数据\n            int one = Integer.parseInt(num1.getText().toString());\n            int two = Integer.parseInt(num2.getText().toString());\n    \n    \n            //            弹出对话框\n    //        生命对象\n            AlertDialog dialog;\n            AlertDialog.Builder builder;\n            builder = new AlertDialog.Builder(MainActivity.this)\n                    .setTitle(\"相加的计算结果\")\n                    .setIcon(R.mipmap.ic_launcher)\n                    .setMessage(one + \" + \" + two + \" = \" + (one + two))\n                    .setPositiveButton(\"确定\", new DialogInterface.OnClickListener() {\n                        @Override\n                        public void onClick(DialogInterface dialog, int which) {\n                            dialog.dismiss();//关闭对话框\n                            MainActivity.this.finish();//关闭MainActivity\n                        }\n                    })\n                    .setNegativeButton(\"取消\", new DialogInterface.OnClickListener() {\n                        @Override\n                        public void onClick(DialogInterface dialog, int which) {\n                            dialog.dismiss();\n                        }\n                    });\n            dialog = builder.create();\n            dialog.show();\n        }\n    }\n    \n\n`activity_main.xml`:\n\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n        xmlns:tools=\"http://schemas.android.com/tools\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\"\n        tools:context=\".MainActivity\">\n    \n        <LinearLayout\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\">\n    \n            <TextView\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"wrap_content\"\n                android:text=\"两数字相加，自己输入的版本\"></TextView>\n        </LinearLayout>\n    \n        <LinearLayout\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:orientation=\"horizontal\">\n    \n    \n            <TextView\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"wrap_content\"\n                android:text=\"请输入数字\"\n                android:textColor=\"@color/black\" />\n    \n            <EditText\n                android:id=\"@+id/firstNum\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"wrap_content\"\n                android:hint=\"请输入第一个数字\" />\n        </LinearLayout>\n    \n        <LinearLayout\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:orientation=\"horizontal\">\n    \n            <TextView\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"wrap_content\"\n                android:text=\"请输入数字\"\n                android:textColor=\"@color/black\" />\n    \n            <EditText\n                android:id=\"@+id/secondNum\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"wrap_content\"\n                android:hint=\"请输入第二个数字\" />\n        </LinearLayout>\n    \n        <Button\n            android:id=\"@+id/submitButton\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:background=\"#ECD4D4\"\n            android:text=\"提交数据\" />\n    \n        <LinearLayout\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\">\n    \n            <Button\n                android:id=\"@+id/randomNum\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"wrap_content\"\n                android:text=\"两个数相加，随机数版本的按钮\"></Button>\n        </LinearLayout>\n    </LinearLayout>\n    \n\n> 说明:  \n> 两个版本,上面的是输入数字点 提交数据 跳出结果\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ca9b9ef0ae8c494fb72311ca1a2237b1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAaWNlc3RvbmVfa2Fp,size_10,color_FFFFFF,t_70,g_se,x_16)\n\n下面是自己在后台出现随机数,点击出现弹窗",
        "states": "0",
        "description": "个人blog网站前言:写错了思路,没按照老师的要求写,但是可以用ps:文章排版可能会出错,毕竟是用别人的框架ps:用的时候记着改一下包名MainActivity.java:package com.example.calculate;import androidx.appcompat.app.AlertDialog;import androidx.appcompat.app.AppCompatActivity;import android.annotation.SuppressLi.",
        "praise": "0",
        "view": "55",
        "audit": "1",
        "tag1": "android",
        "tag2": "note",
        "tag3": "傻逼安卓",
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/120692859",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-06-02T18:37:36.000Z",
        "destroyTime": null
    },
    {
        "id": 74,
        "email": "2714351312@qq.com",
        "title": "使用displsy:flex + overflow:hidden时子元素被压缩",
        "content": null,
        "states": "0",
        "description": "博客地址以下结构就很可能会发生子元素被压缩:  .ul {    display: flex;    overflow: hidden;    li {      display: flex;     }    }效果:[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-VMv2unYs-1632367338486)(/images/pasted-15.png)]此时我的目的是做一个轮播图,想让ul在div中使用关键帧播放,做到这个效果而且元素不.",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/120431468",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 75,
        "email": "2714351312@qq.com",
        "title": "02_使用jq实现进入和离开动画",
        "content": null,
        "states": "0",
        "description": "前言:csdn上写博文无法上传本地视频,上传到哔哩哔哩又嫌麻烦,查看效果请移步我的博客创建进入时的动画:这一步很简单index.html:&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;title&gt;test3&lt;/title&gt;    &lt;link rel=\"stylesheet\" type=\"text/less\" .",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/120317213",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 76,
        "email": "2714351312@qq.com",
        "title": "找出数组中不重复的一个数",
        "content": null,
        "states": "0",
        "description": "只出现一次的数字给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？示例 1:输入: [2,2,1]输出: 1作者：力扣 (LeetCode)链接：https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x21ib6/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/119841649",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "1",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 77,
        "email": "2714351312@qq.com",
        "title": "给定一个整数数组，判断是否存在重复元素。",
        "content": null,
        "states": "0",
        "description": "存在重复元素给定一个整数数组，判断是否存在重复元素。如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。示例 1:输入: [1,2,3,1]输出: true作者：力扣 (LeetCode)链接：https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x248f5/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注.",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/119814154",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "1",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 78,
        "email": "2714351312@qq.com",
        "title": "旋转数组(右旋转,js实现,unshift,splicec实现)",
        "content": null,
        "states": "0",
        "description": "旋转数组(右旋转)给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。示例 1:输入: nums = [1,2,3,4,5,6,7], k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]V向右旋转 3 步: [5,6,7,1,2,3,4]作者：力扣 (LeetCode)链接：https://leetcode-cn.com/leetbook/read/top-i.",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/119795748",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 79,
        "email": "2714351312@qq.com",
        "title": "给定一个数组 prices计算其利润最大",
        "content": null,
        "states": "0",
        "description": "前言:新手菜鸡的笔记题目:给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。示例:示例 1:输入: prices = [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 .",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/119745945",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 80,
        "email": "2714351312@qq.com",
        "title": "有序数组原地删除重复出现的元素问题(js)",
        "content": null,
        "states": "0",
        "description": "前提:我是老菜鸡了原题:给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。示例:输入：nums = [1,1,2]输出：2, nums = [1,2]解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。题目来源:作者：力扣 (LeetCode).",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/119720652",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 81,
        "email": "2714351312@qq.com",
        "title": "ndoejs中中间件的使用",
        "content": "### 中间件的概念:\n\n用以封装,处理http请求的细节,让我们去处理业务逻辑而不是底层的一些繁琐细节\n\n### nodejs中的中间件工作:\n\n例如下面的代码:\n\n    var router = require('./router')\n    var express = require('express')\n    var bodyParser = require('body-parser')\n    var app = express()\n    var fs = require('fs')\n    app.use('/node_modules/', express.static('./node_modules/'))\n    app.use('/public/', express.static('./public/'))\n    app.engine('html', require('express-art-template'))\n    app.use(bodyParser.urlencoded({ extended: false }))\n    app.use(bodyParser.json())\n    app.use(router)\n    app.listen(3000, function() {\n        console.log(\"running at 3000\");\n    })\n    \n\n其中的`use`,`engine`就是内置的一些中间件,它对传入的目录/文件/等等,进行处理并返回方法\n\n#### 中间件的分类:\n\n#### 应用程序级别中间件:\n\n    var express = require('express')\n    var app = express()\n    \n    // 中间件:处理请求,本质就是个处理函数\n    \n    // 在express中对中间件有很多分类\n    \n    // 不关心请求路径和请求方法的中间件\n    // 也就是说任何请求都会进入这个中间件\n    // 中间件本身是一个方法,该方法接受三个参数\n    // Request请求对象\n    // Response响应对象\n    // next下一个中间件\n    \n    // 这里如果中间件中没有next(),那么是不会进入下一个中间件\n    /* app.use(function (req, res, next) {\n        console.log('1')\n        next()\n    })\n    \n    app.use(function (req, res, next) {\n        console.log('2')\n        next()\n    }) */\n    \n    /* app.use(function (req, res, next) {\n        console.log('first next')\n        next()\n    })\n    */\n    // 关心请求路径的中间件:\n    // 所有以/a开头的,都会请求过来\n    // 但是此时在下面得的中间件中输出req.url时,它是不包含/a的,处理时会自动去除\n    /* app.use('/a', function (req, res) {\n        // console.log('is running at port 3000');\n        console.log(req.url);\n        res.send('/a路径请求')\n    })\n    \n    app.use(function (req, res, next) {\n        console.log('second next 第二次,没有匹配的')\n        next()\n    }) */\n    \n    // 以/b开头的会进来\n    /* app.use('/b', function (req, res) {\n        // console.log('is running at port 3000');\n        console.log(req.url);\n        res.send('/b路径请求')\n    }) */\n    // 上面的是应用程序级别的中间件\n    app.listen(3000, function () {\n        console.log('app is running at port 3000');\n    })\n    \n\n> 其中有几种匹配方式:\n\n    // 万能匹配的模式\n    app.use(function (req, res, next) {\n        console.log('万能匹配的模式')\n        next()\n    })\n    // 匹配开头的:\n    // 只有以 /a 开头的才会进来:\n    app.use('/a', function (req, res) {\n        // console.log('is running at port 3000');\n        console.log(req.url);\n        res.send('/a路径请求')\n    })\n    \n\n> 要注意其中传入的参数:`next`\n\n一个中间件中传入了`next`参数,并且在其中调用了`next()`\n\n那么在执行完该中间件之后,会调用下一个`匹配`的中间件:\n\n    app.use(function (req, res, next) {\n        console.log('first next')\n        next()\n    })\n    app.use('/a', function (req, res) {\n        // console.log('is running at port 3000');\n        console.log(req.url);\n        res.send('/a路径请求')\n    })\n    app.use(function (req, res, next) {\n        console.log('second next 第二次,没有匹配的')\n    })\n    \n\n在上面中,第一个中间件被调用之后:\n\n*   如果路径是以`/a`开头的,那么会调用第二个中间件,而不会去调用第三个中间件\n*   如果路径并不是以`/a`开头的,那么它之后会去调用第三个中间件,而不是去调用第二个\n\n#### 路由器级别中间件\n\n    // 除了上面的中间件之外,还有一种最常用的\n    // 严格匹配请求方法和请求路径的中间件:\n    // app.get('/')\n    // app.post('/')\n    \n    // 下面的是路由器级别的中间件\n    app.get('/', function (req, res, next) {\n        console.log('/');\n    })\n    \n    app.get('/a', function (req, res, next) {\n        console.log('/a');\n    })\n    \n\n> 上面这些中间件是只有以指定字符串开头的才会进入该中间件",
        "states": "0",
        "description": "中间件的概念:用以封装,处理http请求的细节,让我们去处理业务逻辑而不是底层的一些繁琐细节nodejs中的中间件工作:例如下面的代码:var router = require('./router')var express = require('express')var bodyParser = require('body-parser')var app = express()var fs = require('fs')app.use('/node_modules/', express.s",
        "praise": "0",
        "view": "5",
        "audit": "1",
        "tag1": "nodejs",
        "tag2": "middleware",
        "tag3": "javascript",
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/119383031",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-06T07:53:54.000Z",
        "destroyTime": null
    },
    {
        "id": 82,
        "email": "2714351312@qq.com",
        "title": "nodejs后端使用art-template",
        "content": "> 前言: 写这些东西是我怕要用的时候忘了怎么用\n\n* * *\n\n> 为什么要使用两种渲染?\n\n*   服务端渲染\n    *   说白了就是在服务端使用模板引擎\n    *   模板引擎再造诞生于服务器端,后来才发展到了前端\n*   服务端渲染和客户端渲染的区别:\n    *   客户端渲染不利于 SEO 搜索引擎优化\n    *   服务端渲染时可以被爬虫爬取到的,客户端异步渲染时很难被爬虫抓取到\n    *   所以你会发现真正的网站既不是纯异步,也不是纯服务端渲染出来的\n    *   而是两者结合出来的\n    *   例如京东的商品列表就采用的是服务端渲染,目的是为了SEO搜索引擎优化\n    *   而它的商品评论列表为用户体验,而且也不需要SEO优化,所以采用的是客户端渲染\n\n而在页面渲染中,前端可以使用模板渲染,后端(服务器渲染)也是可以的\n\n* * *\n\n#### 安装:\n\n    cnpm i art-template --save\n    \n\n使用下面的代码修改指定模板的扩展名(默认模板的文件扩展名是`.art`):\n\n    app.engine('html',require('express-art-template'))\n    \n\n    var express=require('express')\n    var app=express()\n    var path=require('path')\n    app.use('/public/',express.static(path.join(__dirname,'./public/')))\n    app.use('/node_modules/',express.static(path.join(__dirname,'./node_modules/')))\n    // 在ndoe中,有很多第三方模板引擎都可以使用,不是只有art-template\n    app.engine('html',require('express-art-template'))\n    app.set('views',path.join(__dirname,'./views/'))//默认views目录,\n    app.get('/',function(req,res){\n        res.render('index.html',{\n            name:'zs'\n        })\n    })\n    app.listen('3000',function(){\n        console.log('server is running at 127.0.0.1:3000');\n    })\n    \n\n#### 在`index.html`中渲染时:\n\n`index.html`:\n\n    {{extend './layout.html'}}\n    {{block 'head'}}\n    {{/block}}\n    {{block 'content'}}\n    <div>\n        <h1>\n            index页面填坑内容\n            {{name}}\n        </h1>\n    </div>\n    {{/block}}\n    {{block 'script'}}\n    {{/block}}\n    \n\n在上面中,它会把页面中的`{{name}}`替换为app.js中配置的数据\n\n#### 在服务器端使用代码模板继承时:\n\n    {{extend './layout.html'}}\n    \n    {{block 'head'}}\n    \n    {{/block}}\n    \n    {{block 'content'}}\n    <div>\n        <h1>\n            index页面填坑内容\n            {{name}}\n        </h1>\n    </div>\n    \n    {{/block}}\n    \n    {{block 'script'}}\n    \n    {{/block}}\n    \n\n文件目录结构为:\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/cb4bef9df988488bbfb45b0532142e7a.png)\n\n如下面的代码,它会引入其他页面的代码:\n\n    <!-- 继承lsyout页面的代码 -->\n    {{extend './layout.html'}}\n    \n    {{block 'content'}}\n    <div>\n        <h1>\n            index页面填坑内容\n            {{name}}\n        </h1>\n    </div>\n    {{/block}}\n    \n\n#### 使用部分代码模板:\n\n例如下面的代码,layout背继承之后,其中的\n\n        {{block 'content'}}\n        <h1>默认内容</h1>\n        {{/block}}\n    \n\n这个代码块包裹的内容会被`index.html`中被同样标签包裹的内容给替换\n\n`layout.html`:\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n        <link rel=\"stylesheet\" href=\"/node_modules/bootstrap/dist/css/bootstrap.css\">\n        <title>index</title>\n    </head>\n    <body>\n        <!-- 留一个坑 -->\n        {{block 'content'}}\n        <h1>默认内容</h1>\n        {{/block}}\n        <script src=\"/node_modules/jquery/dist/jquery.js\"></script>\n        <script src=\"../node_modules/bootstrap/dist/js/bootstrap.js\"></script>\n    </body>\n    </html>\n    \n\n`index.html`:\n\n    <!-- 继承layout页面的代码 -->\n    {{extend './layout.html'}}\n    \n    {{block 'content'}}\n    <div>\n        <h1>\n            index页面填坑内容\n            {{name}}\n        </h1>\n    </div>\n    {{/block}}\n    \n\n* * *\n\n#### 项目中使用代码模板:\n\n> 因此我们在后端返回页面时,可以将大部分公共代码器·提取出来,在使用时引入即可\n\n例如下面的页面代码:\n\n`footer.html`:\n\n    <div>\n        <h6>\n            footer\n        </h6>\n    </div>\n    \n\n`header.html`:\n\n    <div>\n    \n        <h1>公共的头部</h1>\n    </div>\n    \n\n`index.html`:\n\n    <!-- 继承lsyout页面的代码 -->\n    {{extend './layout.html'}}\n    {{block 'head'}}\n    {{/block}}\n    {{block 'content'}}\n    <div>\n        <h1>\n            index页面填坑内容\n            {{name}}\n        </h1>\n    </div>\n    {{/block}}\n    {{block 'script'}}\n    {{/block}}\n    \n\n`layout.html`:\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n        <link rel=\"stylesheet\" href=\"/node_modules/bootstrap/dist/css/bootstrap.css\">\n        <title>index</title>\n        {{block 'head'}}{{/block}}\n    </head>\n    <body>\n        {{include './header.html'}}\n        <!-- 留一个坑 -->\n        {{block 'content'}}\n        <h1>默认内容</h1>\n        {{/block}}\n        <!-- 留给下一个去填坑 -->\n        {{include './footer.html'}}\n        <script src=\"/node_modules/jquery/dist/jquery.js\"></script>\n        <script src=\"../node_modules/bootstrap/dist/js/bootstrap.js\"></script>\n        {{block 'script'}}{{/block}}\n    </body>\n    </html>\n    \n\n渲染结果页面:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/24640770f643472d84b23a72c342c47d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)",
        "states": "0",
        "description": "前言: 写这些东西是我怕要用的时候忘了怎么用为什么要使用两种渲染?服务端渲染说白了就是在服务端使用模板引擎模板引擎再造诞生于服务器端,后来才发展到了前端服务端渲染和客户端渲染的区别:客户端渲染不利于 SEO 搜索引擎优化服务端渲染时可以被爬虫爬取到的,客户端异步渲染时很难被爬虫抓取到所以你会发现真正的网站既不是纯异步,也不是纯服务端渲染出来的而是两者结合出来的例如京东的商品列表就采用的是服务端渲染,目的是为了SEO搜索引擎优化而它的商品评论列表为用户体验,而且也不需.",
        "praise": "0",
        "view": "5",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/119382416",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-08T00:52:43.000Z",
        "destroyTime": null
    },
    {
        "id": 83,
        "email": "2714351312@qq.com",
        "title": "从webstrom转到vscode(vscode插件推荐)",
        "content": null,
        "states": "0",
        "description": "21年初之前一直用的是webstrom来写前端代码的,但是到后来写的一些服务器时发现它占用的内存越来越大了(可能是太菜了,不会调试).32G的笔记本,webstrom一开启就占用了6G(最大占用空间给调了),开启有点慢,占用有点太大了,后来我换了vacode,起初担心会不会有太多有太多不习惯,功能是不是太麻烦后来发现插件真好用,使用起来也很方便,就是需要安装一些插件Auto Close Tag顾名思义,自动闭合括号的插件,不安装一个的话,是不会自动闭合的,比如下面,再写上&gt;就会自动.",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/118974216",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 84,
        "email": "2714351312@qq.com",
        "title": "python安装pip出了问题，-bash: pip: command not found",
        "content": null,
        "states": "0",
        "description": null,
        "praise": "0",
        "view": "3",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://ask.csdn.net/questions/7483803?answer=53478383",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "ask",
        "hasOriginal": null,
        "diggCount": null,
        "articleType": null,
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-08T00:41:48.000Z",
        "destroyTime": null
    },
    {
        "id": 85,
        "email": "2714351312@qq.com",
        "title": "关于nodejs的session本地存储的问题",
        "content": null,
        "states": "0",
        "description": null,
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://ask.csdn.net/questions/7483811",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "ask",
        "hasOriginal": null,
        "diggCount": null,
        "articleType": null,
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 86,
        "email": "2714351312@qq.com",
        "title": "nodejs连接MongonDB和mysql进行CRUD",
        "content": null,
        "states": "0",
        "description": "前言:学这些东西我怕忘了mongondbmysqlMongonDBmongondb中的scheama:var mongoose = require('mongoose');var Schema = mongoose.Schema// 1.连接数据库// 插入一个新的数据库时,并不会立即创建该数据库,而是会在你第一次插入一个数据时,创建该数据库mongoose.connect('mongodb://localhost:27017/user', { useNewUrlParser: .",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/119087679",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 87,
        "email": "2714351312@qq.com",
        "title": "一些简单的前端练习demo",
        "content": null,
        "states": "0",
        "description": "前言:我太缺项目练习了fullpage练习页面:360页面demo地址预览链接另一个绝地求生的demo预览链接bootstrap练习页面:HUAWEI网页的demo地址预览链接练习下模板引擎的demo:蘑菇街demo地址预览链接啥框架都没用的demo:拉勾网的demo地址预览链接...",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/118559853",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "1",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 88,
        "email": "2714351312@qq.com",
        "title": "eslint报错",
        "content": null,
        "states": "0",
        "description": "2:22  error  Newline required at end of file but not found  eol-last报错的行留一空行即可但是ide老是自动删除空行(vscode),如果你关闭了设置中的自动空行.还是没有解决文件无法留一空行的问题,可以考虑看看是不是啥插件在作祟,such as:...",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/117599789",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 89,
        "email": "2714351312@qq.com",
        "title": "Nodejs服务器端处理POST提交的数据_note",
        "content": null,
        "states": "0",
        "description": "node代码:let http = require('http');let queryString = require('querystring');//1.创建一个服务器实例对象let server = http.createServer();server.on(\"request\", function (req, res) {//1.定义变量保存传递过来的参数    let params = \"\";//注意点:在nodejs中post请求的参数我们不能一次性拿到,必须要分批获取//  ",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/116309719",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 90,
        "email": "2714351312@qq.com",
        "title": "npm run test报错",
        "content": "    \"webpack\": \"^4.41.0\",\n    \"webpack-cli\": \"^3.3.9\",\n    \"webpack-dev-server\": \"^3.8.1\"\n    \"copy-webpack-plugin\": \"^5.0.4\",\n    \n\npackage.json中的test:\n\n        \"scripts\": {\n            \"test\": \"npx webpack-dev-server --config webpack.config.js\"\n        },\n    \n\n报错:\n\n    PS D:\\Project\\WebStudy\\zhiboyu\\webpack\\24_webpack_dev_server> npm run test\n    Debugger attached.\n    \n    > 01-webpack-introductory@1.0.0 test D:\\Project\\WebStudy\\zhiboyu\\webpack\\24_webpack_dev_server\n    > npx webpack-dev-server --config webpack.config.js\n    \n    Debugger attached.\n    Debugger attached.\n    Waiting for the debugger to disconnect...\n    D:\\Project\\WebStudy\\zhiboyu\\webpack\\24_webpack_dev_server\\node_modules\\schema-utils\\src\\validateOptions.js:32\n        throw new ValidationError(ajv.errors, name);\n        ^\n    \n    ValidationError: CopyPlugin Invalid Options\n    \n    options should be array\n    \n        at validateOptions (D:\\Project\\WebStudy\\zhiboyu\\webpack\\24_webpack_dev_server\\node_modules\\schema-utils\\src\\validateOptions.js:32:11)\n        at new CopyPlugin (D:\\Project\\WebStudy\\zhiboyu\\webpack\\24_webpack_dev_server\\node_modules\\copy-webpack-plugin\\dist\\index.js:26:30)\n        at Object.<anonymous> (D:\\Project\\WebStudy\\zhiboyu\\webpack\\24_webpack_dev_server\\webpack.config.js:120:9)\n        at Module._compile (internal/modules/cjs/loader.js:1063:30)\n        at Object.Module._extensions..js (internal/modules/cjs/loader.js:1092:10)\n        at Module.load (internal/modules/cjs/loader.js:928:32)\n        at Function.Module._load (internal/modules/cjs/loader.js:769:14)\n        at Module.require (internal/modules/cjs/loader.js:952:19)\n        at require (internal/modules/cjs/helpers.js:88:18)\n        at WEBPACK_OPTIONS (D:\\Project\\WebStudy\\zhiboyu\\webpack\\24_webpack_dev_server\\node_modules\\webpack-cli\\bin\\utils\\convert-argv.js:114:13)\n        at requireConfig (D:\\Project\\WebStudy\\zhiboyu\\webpack\\24_webpack_dev_server\\node_modules\\webpack-cli\\bin\\utils\\convert-argv.js:116:6)\n        at D:\\Project\\WebStudy\\zhiboyu\\webpack\\24_webpack_dev_server\\node_modules\\webpack-cli\\bin\\utils\\convert-argv.js:123:17\n        at Array.forEach (<anonymous>)\n        at module.exports (D:\\Project\\WebStudy\\zhiboyu\\webpack\\24_webpack_dev_server\\node_modules\\webpack-cli\\bin\\utils\\convert-argv.js:121:15)\n        at Object.<anonymous> (D:\\Project\\WebStudy\\zhiboyu\\webpack\\24_webpack_dev_server\\node_modules\\webpack-dev-server\\bin\\webpack-dev-server.js:84:40)\n        at Module._compile (internal/modules/cjs/loader.js:1063:30) {\n      errors: [\n        {\n          keyword: 'type',\n          dataPath: '',\n          schemaPath: '#/type',\n          params: { type: 'array' },\n          message: 'should be array'\n        }\n      ]\n    }\n    Waiting for the debugger to disconnect...\n    npm ERR! code ELIFECYCLE\n    npm ERR! errno 1\n    npm ERR! 01-webpack-introductory@1.0.0 test: `npx webpack-dev-server --config webpack.config.js`npm ERR! Exit status 1\n    npm ERR!\n    npm ERR! Failed at the 01-webpack-introductory@1.0.0 test script.\n    npm ERR! This is probably not a problem with npm. There is likely additional logging output above.\n    \n    npm ERR! A complete log of this run can be found in:\n    npm ERR!     C:\\Users\\kirin\\AppData\\Roaming\\npm-cache\\_logs\\2021-05-21T07_51_47_749Z-debug.log  \n    Waiting for the debugger to disconnect...\n    \n\n其中主要是这里(webpack.config.js出错):\n\n    npm ERR! code ELIFECYCLE\n    npm ERR! errno 1\n    npm ERR! 01-webpack-introductory@1.0.0 test: `npx webpack-dev-server --config webpack.config.js`npm ERR! Exit status 1\n    \n\n解决:  \n在webpack.config.js中下面这一段出错:\n\n    new CopyWebpackPlugin(\n                {\n                    patterns:\n                        [{ from: \"./doc\", to: \"doc\" }]\n                }\n            ),\n    \n\n修改为:\n\n    new CopyWebpackPlugin(\n                [{ from: \"./doc\", to: \"doc\" }]\n            ),\n    \n\n然后就跑成功了,  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210521160600698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)",
        "states": "0",
        "description": "\"webpack\": \"^4.41.0\",\"webpack-cli\": \"^3.3.9\",\"webpack-dev-server\": \"^3.8.1\"\"copy-webpack-plugin\": \"^5.0.4\",package.json中的test:    \"scripts\": {        \"test\": \"npx webpack-dev-server --config webpack.config.js\"    },报错:PS D:\\Project\\WebStudy\\zhib",
        "praise": "0",
        "view": "3",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/117124895",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "1",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-07-07T00:34:37.000Z",
        "destroyTime": null
    },
    {
        "id": 91,
        "email": "2714351312@qq.com",
        "title": "html自己使用的代码template",
        "content": null,
        "states": "0",
        "description": "html.json:{\t\"html:5\": {\t\t\"prefix\": \"html\",\t\t\"body\": [\t\t\t\"&lt;!DOCTYPE html&gt;\",\t\t\t\"&lt;html&gt;\",\t\t\t\"&lt;head&gt;\",\t\t\t\"\\t&lt;meta charset=\\\"UTF-8\\\"&gt;\",\t\t\t\"\\t&lt;meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"&gt;\",\t\t\t\"",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/116648380",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 92,
        "email": "2714351312@qq.com",
        "title": "Nodejs中获取get请求传过来的参数_note",
        "content": null,
        "states": "0",
        "description": "代码:let url = require('url');let http = require('http');/*let str = \"http://root:123465@www.it666.com:80/index.html?name=lnj&amp;age=68\";//后面添加true意思为将query中的字符串也转为jsonlet obj = url.parse(str,true);console.log(obj.query.name);console.log(obj.query.",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/116305706",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 93,
        "email": "2714351312@qq.com",
        "title": "js报错",
        "content": null,
        "states": "0",
        "description": "报错:\"C:\\Program Files\\nodejs\\node.exe\" D:\\Project\\MYSELF\\zhiboyu\\node\\NodeApi\\14下.jsD:\\Project\\MYSELF\\zhiboyu\\node\\NodeApi\\15_StaticServer.js:8    let filePath = path.join(rootPath, req.url);                                           ^TypeError: Canno",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/116305062",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 94,
        "email": "2714351312@qq.com",
        "title": "js文件复制_note",
        "content": null,
        "states": "0",
        "description": "代码://数据的分批写入let fs = require('fs');let path = require('path');//1.生成读取和写入的路径let readpath = path.join(__dirname, \"test.mp4\");let writepath = path.join(__dirname, \"abc.mp4\");//第一种复制方式/*//2.创建一个读取流let ReadStream = fs.createReadStream(readpath);/",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/116294840",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 95,
        "email": "2714351312@qq.com",
        "title": "js创建,删除,读取文件目录_note",
        "content": null,
        "states": "0",
        "description": "代码://创建文件目录let fs = require('fs');let path = require('path');//读取的时候要用第二个str,创建,删除的时候用第一个str// let str = path.join(__dirname, \"abc\");let str = path.join(__dirname, \"../NodeApi\");console.log(str);//创建文件目录:/*fs.mkdir(str, function (err) {    if (",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/116293422",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 96,
        "email": "2714351312@qq.com",
        "title": "js中追加写入文件(字符串追加)_note",
        "content": null,
        "states": "0",
        "description": "代码:let fs = require('fs');let path = require('path');//1.拼接写入的路径let str = path.join(__dirname, \"lnj.txt\");//2.开始追加数据fs.appendFile(str, \"你好啊\", 'utf8', function (err) {    if (err) {        throw new Error(\"追加数据失败\")    } else {        console.log(\"",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/116293278",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 97,
        "email": "2714351312@qq.com",
        "title": "js中文件写入(字符串写入)_note",
        "content": null,
        "states": "0",
        "description": "代码://数据的分批写入let fs = require('fs');let path = require('path');//1.拼接读取的路径let str = path.join(__dirname, \"it666.txt\");//2.创建一个读取流let writeStream = fs.createWriteStream(str, {    encoding: 'utf8',    highWaterMark: 1,})//3.添加事件监听:writeStream.on",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/116293137",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 98,
        "email": "2714351312@qq.com",
        "title": "markdown基本语法使用",
        "content": null,
        "states": "0",
        "description": "链接title是当鼠标悬停在链接上时会出现的文字，这个title是可选的，它放在圆括号中链接地址后面，跟链接地址之间以空格分隔。要创建分隔线，请在单独一行上使用三个或多个星号 (***)、破折号 (—) 或下划线 (___) ，并且不能包含其他内容。如果你要表示为代码的单词或短语中包含一个或多个反引号，则可以通过将单词或短语包裹在双反引号(``)中。用法:只要将代码放在下面标签中即可,其他代码同理,只需要改变第一个```后面的标注即可。链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/116139283",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "1",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 99,
        "email": "2714351312@qq.com",
        "title": "Node概述_note",
        "content": "#### [Node概述](#overview)\n\n#### [Node的执行方式](#Howitisexecuted)\n\n#### [Node环境和浏览器环境的区别](#distinguish)\n\n#### [Node身上全局对象的属性](#attribute)\n\n#### [Node中的模块](#module)\n\n#### [Node中导出数据的几种方式](#DataExport)\n\n* * *\n\n###### 1.什么是Node.js?\n\nNode.js 是一个基于\"Chrome V8 引擎\" 的JavaScript “运行环境”\n\n###### 2.什么是V8引擎?\n\nV8引擎是一款专门解释和执行JS代码的虚拟机, 任何程序只要集成了V8引擎都可以执行JS代码 例如:  \n\\-将V8引擎嵌入到浏览器中，那么我们写的JavaScript代码就会被浏览器所执行； -将V8引擎嵌入到NodeJS中，那么我们写的JavaScript代码就会被NodeJS所执行。\n\n###### 3.什么是运行环境?\n\n运行环境 就是 生存环境 地球是人类的生存环境 浏览器是网页的生存环境 windows是.exe应用程序的生存环境 Android是.apk应用程序的生存环境 也就是说运行环境就是特定事物的生存环境 … NodeJS也是一个生存的环境,  \n由于NodeJS中集成了V8引擎 所以NodeJS是JavaScript应用程序的一个生存环境\n\n###### 4.总结:\n\nNodeJS不是一门编程语言, NodeJS是一个运行环境, 由于这个运行环境集成了V8引擎, 所以在这个运行环境下可以运行我们编写的JS代码, 这个运行环境最大的特点就是提供了操作\"操作系统底层的API\",  \n通过这些底层API我们可以编写出网页中无法实现的功能(诸如: 打包工具, 网站服务器等)\n\n* * *\n\n###### 1.由于浏览器中集成了V8引擎, 所以浏览器可以解释执行JS代码\n\n1.1可以直接在浏览器控制台中执行JS代码  \n1.2可以在浏览器中执行JS文件中的JS代码\n\n或者在命令行中打开node执行js代码如图:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210423161414301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n###### 2.由于NodeJS中也集成了V8引擎, 所以浏览器可以解释执行JS代码\n\n2.1可以直接在命令行工具中编写执行JS代码(REPL – Read Eval Print Loop:交互式解释器)  \n2.2可以在命令行工具中执行JS文件中的JS代码\n\n如图:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210423161425183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n* * *\n\n#### Node环境和浏览器环境的区别:\n\n##### 1.Node环境和浏览器环境区别\n\nNodeJS环境和浏览器环境一样都是一个JS的运行环境, 都可以执行JS代码.  \n但是由于宿主不同所以特点也有所不同\n\n1.1内置对象不同\n\n*   浏览器环境中提供了window全局对象\n*   NodeJS环境中的全局对象不叫window, 叫global\n\n1.2this默认指向不同\n\n*   浏览器环境中全局this默认指向window\n*   NodeJS环境中全局this默认指向空对象{}\n\n1.3API不同\n\n*   浏览器环境中提供了操作节点的DOM相关API和操作浏览器的BOM相关API\n*   NodeJS环境中没有HTML节点也没有浏览器, 所以NodeJS环境中没有DOM/BOM\n\n* * *\n\n#### Node全局对象身上的属性:\n\n##### 1.和浏览器一样Node环境中的全局对象也提供了很多方法属性供我们使用\n\n中文文档地址: http://nodejs.cn/api/\n\n\\_\\_dirname: 当前文件所在文件夹的绝对路径  \n\\_\\_filename: 当前文件的绝对路径 setInterval / clearInterval : 和浏览器中window对象上的定时器一样 setTimeout / clearTimeout :  \n和浏览器中window对象上的定时器一样 console : 和浏览器中window对象上的打印函数一样\n\n* * *\n\n#### 什么是模块:\n\n##### 1.什么是模块?\n\n1.1浏览器开发中的模块 在浏览器开发中为了避免命名冲突, 方便维护等等 我们采用类或者立即执行函数的方式来封装JS代码, 来避免命名冲突和提升代码的维护性 其实这里的一个类或者一个立即执行函数就是浏览器开发中一个模块 let obj =  \n{ 模块中的业务逻辑代码 }; ;(function(){ 模块中的业务逻辑代码 window.xxx = xxx; })(); 存在的问题:  \n没有标准没有规范\n\n1.2NodeJS开发中的模块 NodeJS采用CommonJS规范实现了模块系统\n\n1.3CommonJS规范 CommonJS规范规定了如何定义一个模块, 如何暴露(导出)模块中的变量函数, 以及如何使用定义好的模块\n\n*   在CommonJS规范中一个文件就是一个模块\n*   在CommonJS规范中每个文件中的变量函数都是私有的，对其他文件不可见的\n*   在CommonJS规范中每个文件中的变量函数必须通过exports暴露(导出)之后其它文件才可以使用\n*   在CommonJS规范中想要使用其它文件暴露的变量函数必须通过require()导入模块才可以使用\n\n如:\n\n    //导出\n    let name = \"it666.com\";\n    \n    function sum(a, b) {\n        return a + b;\n    }\n    \n    exports.str = name;\n    exports.fn = sum;\n    \n\n    //导入\n    let aModule = require('./06_a');\n    // console.log(name);\n    console.log(aModule);\n    console.log(aModule.str);\n    console.log(aModule.fn(10, 20))\n    \n\n* * *\n\n##### Node中导出数据几种方式:\n\n##### 1.在NodeJS中想要导出模块中的变量函数有三种方式\n\n1.1通过exports.xxx = xxx导出  \n1.2通过module.exports.xxx = xxx导出  \n1.3通过global.xxx = xxx导出  \n注意点:  \n无论通过哪种方式导出, 使用时都需要先导入(require)才能使用  \n通过global.xxx方式导出不符合CommonJS规范, 不推荐使用\n\n实例:  \n`07_a.js`:\n\n    let name = \"it666.com\";\n    \n    function sum(a, b) {\n        return a + b;\n    }\n    \n    //导出数据的第一种方式\n    // exports.str = name;\n    // exports.fn = sum;\n    \n    //第二种方式:\n    // module.exports.str = name;\n    // module.exports.fn = sum;\n    \n    //第三种方式:\n    global.str = name;\n    global.fn = sum;\n    \n\n`07_b.js`:\n\n    //导入07_a.js\n    let aModule = require('./07_a');\n    \n    //第一二种使用方式按照下面代码都可以执行\n    /*console.log(aModule);\n    console.log(aModule.str);\n    \n    let res = aModule.fn(10, 20);\n    console.log(res);*/\n    \n    //虽然没使用到aModule,但是如果没有导入,是无法使用str,fn的\n    //不符合commonjs的规范,知道就可\n    //第三种方式的接收代码:\n    console.log(str);\n    let res = fn(10, 20);\n    console.log(res);",
        "states": "0",
        "description": "Node概述Node的执行方式Node环境和浏览器环境的区别Node身上全局对象的属性Node中的模块Node中导出数据的几种方式1.什么是Node.js?Node.js 是一个基于\"Chrome V8 引擎\" 的JavaScript “运行环境”2.什么是V8引擎?V8引擎是一款专门解释和执行JS代码的虚拟机, 任何程序只要集成了V8引擎都可以执行JS代码 例如:-将V8引擎嵌入到浏览器中，那么我们写的JavaScript代码就会被浏览器所执行； -将V8引擎嵌入到NodeJS中，",
        "praise": "0",
        "view": "2",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/116059877",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-07-07T01:30:56.000Z",
        "destroyTime": null
    },
    {
        "id": 100,
        "email": "2714351312@qq.com",
        "title": "VueSummary_note",
        "content": "#### [Vue的基本结构:](#BasicStructure)\n\n#### [Vue中的插值:](#Interpolation)\n\n#### [Vue中的事件修饰符:](#EventModifier)\n\n#### [Vue双向绑定机制:](#TwoWayBinding)\n\n#### [Vue中为元素添加样式:](#AddStyle)\n\n#### [Vue中的动画:](#Animation)\n\n#### [Vue中的循环:](#Loop)\n\n#### [Vue中的key的作用及其意义:](#Key)\n\n#### [Vue中v-fi和v-show:](#IfShow)\n\n#### [Vue中的过滤器:](#SelfFilter)\n\n#### [Vue中的键盘修饰符:](#KeyboardModifier)\n\n#### [Vue中的指令:](#Directive)\n\n#### [Vue中的生命周期:](#LifeLine)\n\n#### [Vue使用vue-resource发送请求:](#SendRequest)\n\n#### [Vue中的组件:](#Component)\n\n* * *\n\n##### Vue的基本结构:\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <mate name=\"viewport\" content=\"width=device-width\" , initial-scale=\"1.0\"/>\n        <title>01_vue的基本代码</title>\n        <script src=\"../lib/vue.js\"></script>\n    </head>\n    <body>\n    <div id=\"app\">\n        <p>\n            {{msg}}\n        </p>\n    </div>\n    <script>\n        //创建vue的实例\n        //当我们导入包之后,在浏览器的内存中就多了一个vue的构造函数\n        //注意,我们新建的对象就是vm,vm为vue的调度者\n        var vm = new Vue({\n            //el表示当前我们新建的实例要控制页面上的哪个区域\n            //id\n            el: '#app',\n            //data��存放的是el要用到的数据\n            //这里的data就是mvvm中的m.专门用老保存页面的数据的\n            data: {\n                msg: \"欢迎学习vue\",\n                //通过vue提供的指令,很方便的就能把数据渲染到页面上,程序员不再手动操作dom元素了[前端的vue之类的框架,不提倡我们手动操作dom元素]\n            },\n            //vue中的自定义function\n            methods: {},\n            //自定义过滤器\n            filters: {},\n            //自定义私有指令\n            directives: {},\n            //路由规则\n            router: {},\n            //定义vue的组件\n            components: {},\n            //侦听器\n            watch: {},\n        });\n    </script>\n    </body>\n    </html>\n    \n\n* * *\n\n##### Vue中的插值\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <mate name=\"viewport\" content=\"width=device-width\" , initial-scale=\"1.0\"/>\n        <title>01_vue的基本代码</title>\n        <script src=\"../lib/vue.js\"></script>\n    </head>\n    <body>\n    <div id=\"app\">\n        <p>\n            <!--使用 {{}} 插值:-->\n            {{msg}}\n        </p>\n    \n        <!--使用v-html:-->\n        <!--此时会替代div中的内容,但是并不会渲染其中的html标签(对标签转义了)-->\n        <div v-text=\"msg2\">123456</div>\n    \n        <!--使用v-text进行替换:-->\n        <!--此时会替代div中的内容,但是并不会渲染其中的html标签(对标签转义了)-->\n        <div v-html=\"msg2\">123456</div>\n    \n        <!--使用v-bind进行绑定:-->\n        <!--v-bind可以简写为 : -->\n        <input type=\"button\" value=\"简写按钮\" v-bind:title=\"divHtml+'简写'\">\n        <input type=\"button\" value=\"简写按钮\" :title=\"divHtml+'简写'\">\n    </div>\n    <script>\n        var vm = new Vue({\n            el: '#app',\n            //data中存放的是el要用到的数据\n            //这里的data就是mvvm中的m.专门用来保存页面的数据的\n            data: {\n                msg: \"欢迎学习vue\",\n                msg2: \"<h1>这是一个h1</h1>\",\n                divHtml: '<h1>这里是使用v-bind绑定的数据</h1>'\n            }\n        });\n    </script>\n    </body>\n    </html>\n    \n\n* * *\n\n##### Vue事件修饰符\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <mate name=\"viewport\" content=\"width=device-width\" , initial-scale=\"1.0\"/>\n        <title>事件修饰符</title>\n        <script src=\"../lib/vue.js\"></script>\n        <style>\n            .inner {\n                height: 150px;\n                background-color: pink;\n            }\n        </style>\n    </head>\n    <body>\n    <div id=\"app\">\n        .stop阻止冒泡\n        <!--.stop阻止冒泡-->\n        <div class=\"inner\" @click=\"divHandler\">\n            <!--\n            @click.stop:\n            阻止冒泡发生,子元素点击执行function,而父元素不执行\n            -->\n            <input type=\"button\" value=\"戳他\" @click.stop=\"btnHandler\">\n            <!--以下代码不会阻止冒泡行为-->\n            <input type=\"button\" value=\"不阻止默认事件的戳他\" @click=\"btnHandler\">\n        </div>\n    \n        <!--.prevent阻止默认行为-->\n        <a href=\"https://cn.bing.com/\" @click.prevent=\"linkClick\">问必应(添加了prevent,阻止默认的跳转事件)</a>\n        <hr>\n        下面这个(没有添加prevent)就不会阻止跳转到必应\n        <hr>\n        <a href=\"https://cn.bing.com/\" @click=\"linkClick\">问必应</a>\n        <hr>\n    \n        <!--\n        .capture事件捕获机制\n        子元素被点击,父元素也会被点击,但是使用.capture会使父元素先于子元素被执行\n        -->\n        .capture事件捕获机制\n        <div class=\"inner\" @click.capture=\"divHandler\">\n            <input type=\"button\" value=\"戳他\" @click=\"btnHandler\">\n        </div>\n        <hr>\n    \n        .self只当事件在该元素本身(比如不是子元素)触发时触发回调\n        <!--.self只当事件在该元素本身(比如不是子元素)触发时触发回调-->\n        <!--\n        实现只有点击自身的时候才会触发点击事件\n        -->\n        <div class=\"inner\" @click.self=\"divHandler\">\n            <input type=\"button\" value=\"戳他\" @click=\"btnHandler\">\n        </div>\n    \n        <!--.once只触发一次,事件修饰符可以链式编程-->\n        <!--只会阻止一次prevent-->\n        <a href=\"https://cn.bing.com/\" @click.prevent.once=\"linkClick\">问必应(这个只会阻止一次点击跳转的事件)</a>\n    \n        <!--.self和.stop的区别\n        .self只会阻止自己身上的冒泡行为,并不会真正阻止默哀跑行为,而.stop则可以\n        -->\n    </div>\n    \n    <script>\n        var vue = new Vue({\n            el: \"#app\",\n            data: {}, methods: {\n                divHandler() {\n                    /*冒泡机制:\n                    里面的被外面的包裹,里面的被点击.外面的点击也会触发\n                    */\n                    console.log(\"这是触发了大Div(粉红色背景)的点击\");\n                },\n                btnHandler() {\n                    console.log(\"这还是触发了btn的点击事件\");\n                },\n                linkClick() {\n                    console.log(\"触发了a的点击事件\");\n                }\n            }\n        })\n    </script>\n    </body>\n    </html>\n    \n\n* * *\n\n##### Vue中的双向绑定:\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <mate name=\"viewport\" content=\"width=device-width\" , initial-scale=\"1.0\"/>\n        <title>双向事件绑定</title>\n        <script src=\"../lib/vue.js\"></script>\n    </head>\n    <body>\n    <div id=\"app\">\n        <h4>{{msg}}</h4>\n        <!--\n        v-bind 只能实现数据的单向绑定,从m自动绑定到v中,无法实现数据的双向绑定\n        -->\n        <p>使用v-bind绑定:</p>\n        <input type=\"text\" v-bind:value=\"msg\" style=\"width: 100%\">\n        <!--\n        实现数据双向绑定,a同步到b或b同步到a都是可以的\n        -->\n        <p>使用v-model绑定;</p>\n        <input type=\"text\" style=\"width: 100%\" v-model=\"msg\">\n        <!--\n        注意:v-model只能用于表单元素中,\n        input(radio,text,address,email...) select,checkbox,textarea\n        -->\n    </div>\n    <script>\n        var vue = new Vue({\n            el: \"#app\",\n            data: {\n                msg: \"关于我家狗看见我在敲代码,立刻给我写了一个电商项目并,买了鱼竿叫我去钓鱼这件事\"\n            }, methods: {}\n        })\n    </script>\n    </body>\n    </html>\n    \n\n运行:\n\n这里使用`v-bind`绑定的input里面数据改变并不会改变标题的数据,  \n而使用`v-model`绑定的数据,改变之后,标题和v-bind的数据都会改变\n\n* * *\n\n##### Vue中为元素添加样式\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n    \n        <mate name=\"viewport\" content=\"width=device-width\" , initial-scale=\"1.0\"/>\n        <title>vue的内联样式</title>\n        <script src=\"../lib/vue.js\"></script>\n    </head>\n    <body>\n    \n    <div id=\"app\">\n        <!--对象就是无序键值对的集合-->\n        <p>\n            1.直接在元素上通过:style的形式,书写样式对象\n        </p>\n        <h1 :style=\"{color:'red','font-weight':200}\">这是一个很大的h1</h1>\n    \n        <p>\n            2.将样式对象,定义到data中去,并直接引用到:style中\n        </p>\n    \n        <h1 :style=\"styleobj\">这是一个很大的h1</h1>\n    \n        <p>\n            3.在style中通过数组,引用多个data上的样式对象\n        </p>\n        <h1 :style=\"[styleobj,styleobj2]\">这是一个很大的h1</h1>\n    </div>\n    \n    <script>\n        var vue = new Vue({\n            el: \"#app\",\n            data: {\n                styleobj: {color: 'blue', 'font-weight': 200},\n                styleobj2: {\n                    'font-style': 'italic'\n                }\n            }, methods: {},\n        })\n    </script>\n    </body>\n    </html>\n    \n\n运行:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210420112925311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n* * *\n\n##### Vue中的动画:\n\n之前写过,[点这里跳转](https://blog.csdn.net/ice_stone_kai/article/details/114984830?spm=1001.2014.3001.5501)\n\nVue中动画的修改动画默认前缀:\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <mate name=\"viewport\" content=\"width=device-width\" , initial-scale=\"1.0\"/>\n        <title>修改动画v-前缀</title>\n        <script src=\"../lib/vue.js\"></script>\n        <style>\n            .v-enter,\n            .v-leave-to {\n                opacity: 0;\n                transform: translateX(80px);\n            }\n    \n            .v-enter-active,\n            .v-leave-active {\n                transition: all 0.8s ease;\n            }\n    \n            /*my-前缀的样式*/\n            .my-enter,\n            .my-leave-to {\n                opacity: 0;\n                transform: translateY(80px);\n            }\n    \n            .my-enter-active,\n            .my-leave-active {\n                transition: all 0.8s ease;\n            }\n        </style>\n    </head>\n    <body>\n    <div id=\"app\">\n        <input type=\"button\" value=\"toggle\" @click=\"flag=!flag\">\n        <!--\n        transition中.为他定义属性的前缀默认是v-\n        -->\n        <transition>\n            <h3 v-if=\"flag\">这是一个h3</h3>\n        </transition>\n        <hr>\n        <input type=\"button\" value=\"toggle2\" @click=\"flag2=!flag2\">\n        <!--此时如果不想和上面的功用一个style,可以为transition定一个name--->\n        <!--\n        从而使该transition的样式定义的前缀为my-\n        -->\n        <transition name=\"my\">\n            <h6 v-if=\"flag2\">这是一个h6</h6>\n        </transition>\n    </div>\n    <script>\n        var vm = new Vue({\n            el: '#app',\n            data: {\n                flag: false,\n                flag2: false\n            },\n            methods: {}\n        })\n    </script>\n    </body>\n    </html>\n    \n\nVue中使用第三方库实现动画:\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <mate name=\"viewport\" content=\"width=device-width\" , initial-scale=\"1.0\"/>\n        <title>第三方类实现动画</title>\n        <script src=\"../lib/vue.js\"></script>\n        <link rel=\"stylesheet\" href=\"../lib/animate.css\">\n    </head>\n    <body>\n    <div id=\"app\">\n        <input type=\"button\" value=\"toggle\" @click=\"flag=!flag\">\n    \n        <!--下面这个方法需要写两次基本类(animated)-->\n        <!--<transition enter-active-class=\"animated bounceIn\"\n                    leave-active-class=\"animated bounceOut\">\n            <h3 v-if=\"flag\">这是一个h3</h3>\n        </transition>-->\n    \n    \n        <!--基本类写在h3中也可以-->\n        <!--\n        duration:为该元素指定时间(不明显),指定的是入场和离场的时间(相同的)\n        前面带有 : 说明他是属性绑定的\n        -->\n        <!--\n            <transition enter-active-class=\"bounceIn\"\n                        leave-active-class=\"bounceOut\" :duration=\"200\">\n                <h3 v-if=\"flag\" class=\"animated\">这是一个h3</h3>\n            </transition>\n        -->\n    \n        <!--分别设置进场和离场的时间-->\n        <!--\n        使用 :duration:\"{enter: 200,leave: 400}\"来分别设置入场,离场的时长\n        -->\n        <transition enter-active-class=\"bounceIn\"\n                    leave-active-class=\"bounceOut\" :duration=\"{enter:200,leave:800}\">\n            <h3 v-if=\"flag\" class=\"animated\">这是一个h3</h3>\n        </transition>\n    </div>\n    <!--入场使用bounceIn 离场使用bounceOut-->\n    <script>\n        var vm = new Vue({\n            el: '#app',\n            data: {\n                flag: false\n            },\n            methods: {}\n        })\n    </script>\n    </body>\n    </html>\n    \n\n* * *\n\n##### Vue中的循环:\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <mate name=\"viewport\" content=\"width=device-width\" , initial-scale=\"1.0\"/>\n        <title>09_v-for_循环普通数组.html</title>\n        <script src=\"../lib/vue.js\"></script>\n    </head>\n    <body>\n    <div id=\"app\">\n        <p>\n            1.迭代数组\n        </p>\n        <p v-for=\"(item,i) in list\">value: {{item}} , index: {{i}}</p>\n        <hr>\n        <p>\n            2.迭代对象数组\n        </p>\n        <p v-for=\"(user,i) in list2\">{{user.id}} + {{user.name}} , 索引: {{i}}</p>\n        <hr>\n        <p>\n            3.循环数字\n        </p>\n        <p v-for=\"count in 10\">\n            这是第 {{count}} 次循环\n        </p>\n        <hr>\n    </div>\n    <script>\n        var uve = new Vue({\n            el: \"#app\",\n            data: {\n                list: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n                list2: [\n                    {id: 1, name: 'zs'},\n                    {id: 2, name: 'ls'},\n                    {id: 3, name: 'ww'},\n                    {id: 4, name: 'xm'},\n                    {id: 5, name: 'dm'},\n                ]\n            }, methods: {}\n        })\n    </script>\n    </body>\n    </html>\n    \n\n运行:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210420112941489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n* * *\n\n##### Vue中的key的作用及其意义:\n\n先举个例子:\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <mate name=\"viewport\" content=\"width=device-width\" , initial-scale=\"1.0\"/>\n        <title>v-for中ley属性的使用</title>\n        <script src=\"../lib/vue.js\"></script>\n    </head>\n    <body>\n    <div id=\"app\">\n        <div>\n            <label>\n                Id:\n                <input type=\"text\" v-model=\"id\">\n            </label>\n            <label>\n                Name:\n                <input type=\"text\" v-model=\"name\">\n            </label>\n            <input type=\"button\" value=\"添加\" @click=\"add\">\n        </div>\n        <!--\n        注意:v-for循环时,key属性只能用num/sting代替\n    \n        注意:key在使用的时候,必须使用b-bing属性绑定的形式,指定key的值\n    \n        此时如果没有使用 : 绑定的话,添加对象之前勾选会使添加对象之后的勾选错误\n        -->\n        <!--\n        在组件中,使用v-for循环的时候,或者在一些特殊情况中,如果v-for有问题,必须在使用v-for的同时,指定唯一的字符串/数字类型的 key值\n        -->\n        <!--        <p v-for=\"item in list\" :key=\"item.id\">-->\n        <p v-for=\"item in list\">\n            <input type=\"checkbox\"> {{item.id}}---{{item.name}}\n        </p>\n    </div>\n    <script>\n        var vue = new Vue({\n            el: \"#app\",\n            data: {\n                id: ' ',\n                name: ' ',\n                list: [\n                    {id: 1, name: '李斯'},\n                    {id: 2, name: '嬴政'},\n                    {id: 3, name: '赵高'},\n                    {id: 4, name: '韩非'},\n                    {id: 5, name: '荀子'}\n                ]\n            },\n            methods: {\n                add() {\n                    //添加方法\n                    // this.list.push({id: this.id, name: this.name});\n                    this.list.unshift({id: this.id, name: this.name});\n                }\n            }\n        })\n    </script>\n    </body>\n    </html>\n    \n\n页面没有任何操作时(没有任何操作时,不管是否使用了key都是一样的):\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210420112955312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)  \n**_不使用key_**,先勾选前两个之后,之后再添加两个对象时:\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210420113006116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)  \n这时我们发现,勾选的框错误了(正确的应该是勾选在李斯和嬴政上面)\n\n**_使用key_**,先勾选前两个之后,之后再添加两个对象时:\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210420113017230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n此时是正确的\n\n此时的区别是因为,有了key之后,每个虚拟节点会有一个指定的唯一值(唯一标识符),  \n而没有key的话,勾选的节点会复用其他节点的数据\n\n* * *\n\n##### Vue中v-fi和v-show:\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <mate name=\"viewport\" content=\"width=device-width\" , initial-scale=\"1.0\"/>\n        <title>v-if和v-show</title>\n        <script src=\"../lib/vue.js\"></script>\n    </head>\n    <body>\n    <div id=\"app\">\n        <!--    <input type=\"button\" @click=\"toggle\" value=\"toggle\">-->\n        <hr>\n        <input type=\"button\" @click=\"flag=!flag\" value=\"toggle\">\n    \n        <!--\n        v-if的特点是每次都会删除或创建一个元素\n        v-show的特点,每次不会进行dom的操作,只是切换了元素的display:none样式\n    \n        v-if有较高的切换性能消耗\n        v-show有较高的初始渲染消耗\n    \n        如果元素涉及到频繁的切换,最好不要用v-if\n        如果元素被创建出来后可能永远不被显示,那么就用v-if比较好\n        -->\n        <h3 v-if=\"flag\">这是用v-if控制的元素</h3>\n    \n        <h3 v-show=\"flag\">这是用v-show控制的元素</h3>\n    </div>\n    <script>\n        var vue = new Vue({\n            el: \"#app\",\n            data: {\n                flag: true\n            }, methods: {\n                /*toggle() {\n                    this.flag = !this.flag;\n                }*/\n            }\n        })\n    </script>\n    </body>\n    </html>\n    \n\n* * *\n\n##### Vue中的过滤器:\n\n定义一个全局过滤器:  \n顾名思义.定义的全局过滤器是所有的vue元素都可以使用\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <mate name=\"viewport\" content=\"width=device-width\" , initial-scale=\"1.0\"/>\n        <title>03_过滤器的基本使用</title>\n        <script src=\"../lib/vue.js\"></script>\n    </head>\n    <body>\n    <div id=\"app\">\n        <p>\n            {{msg | msgFormat('疯狂','arg2')}}\n        <hr>\n        <!--过滤器可以多次调用-->\n        {{msg | msgFormat('疯狂','arg2') | test}}\n        </p>\n    </div>\n    <script>\n        /*定义一个全局的过滤器:msgFormat*/\n        Vue.filter('msgFormat', function (msg, arg, arg2) {\n            // return msg.replace(\",\", \"-\")\n            //字符串的replace方法,除了可以写一个字符串之外,还可以定义一个正则\n            // return msg.replace(/,/g, \"-\")\n            return msg.replace(/,/g, arg + arg2)\n        })\n        Vue.filter('test', function (msg) {\n            return msg + \"===========\";\n        })\n        var vue = new Vue({\n            el: '#app',\n            data: {\n                msg: \"曾经,我也是世界上最无聊的男人.\",\n            }, methods: {}\n        })\n    </script>\n    </body>\n    </html>\n    \n\n运行:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210420113028274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n定义私有过滤器:  \n是有指定的vue元素可以使用\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <mate name=\"viewport\" content=\"width=device-width\" , initial-scale=\"1.0\"/>\n        <title>test</title>\n        <script src=\"../lib/vue.js\"></script>\n    </head>\n    <body>\n    <div id=\"app\">\n        <p>\n            {{msg | msgFormat('疯狂','arg2')}}\n        <hr>\n        <!--过滤器可以多次调用-->\n        {{msg | msgFormat('疯狂','arg2') | test}}\n        <hr>\n        {{msg | SelfFormate('==把逗号更换==','==使用私有过滤器==')}}\n        </p>\n    </div>\n    <script>\n        /*定义一个全局的过滤器:msgFormat*/\n        Vue.filter('msgFormat', function (msg, arg, arg2) {\n            // return msg.replace(\",\", \"-\")\n            //字符串的replace方法,除了可以写一个字符串之外,还可以定义一个正则\n            // return msg.replace(/,/g, \"-\")\n            return msg.replace(/,/g, arg + arg2)\n        })\n        Vue.filter('test', function (msg) {\n            return msg + \"===========\";\n        })\n        var vue = new Vue({\n            el: '#app',\n            data: {\n                msg: \"曾经,我也是世界上最无聊的男人.\",\n            }, methods: {},\n            filters: {\n                SelfFormate: function (msg, arg, arg2) {\n                    return msg.replace(/,/g, arg + arg2)\n                }\n            },\n        })\n    </script>\n    </body>\n    </html>\n    \n\n注意\"\n\n        /*过滤器中的function第一个参数被定死的,永远是过滤器管道符前面传递过来的数据*/\n    /*    Vue.filter('', function (data) {\n        })*/\n    //自定义私有过滤器(局部)\n    /*私有过滤器和全局过滤器的名字重复时,若该对象有私有过滤器,则会优先使用私有过滤器.过滤器采用的是就近原则\n    * * */\n    \n\n运行:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210420113040876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n* * *\n\n##### Vue中的键盘修饰符:\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n    \n        <mate name=\"viewport\" content=\"width=device-width\" , initial-scale=\"1.0\"/>\n        <title>使用回车键回应添加</title>\n        <script src=\"../lib/vue.js\"></script>\n        <link rel=\"stylesheet\" href=\"../lib/bootstrap.css\">\n        <!--vue中不要用到jquery-->\n    </head>\n    <body>\n    <div id=\"app\">\n        <div class=\"panel panel-primary\">\n            <div class=\"panel-heading\">\n                <h3 class=\"panel-title\"> 添加品牌 </h3>\n                <div class=\"panel-body form-inline\">\n                    <label>\n                        Id:\n                        <input type=\"text\" class=\"form-control\" v-model=\"Id\">\n                    </label>\n                    <label>\n                        Name:\n                        <!--keyup键盘抬起,触发add()操作(添加)-->\n                        <!--使用按键修饰符,enter键抬起时执行动作-->\n                        <input type=\"text\" class=\"form-control\" v-model=\"Name\" @keyup.enter=\"add\">\n                        <!--<input type=\"text\" class=\"form-control\" v-model=\"Name\" @keyup.113=\"add\">-->\n                    </label>\n                    <!--V\n                    这里的@click=\"add\" 也可以写为 @click=\"add()\"\n                    后者可以传参了\n                    -->\n                    <input type=\"button\" value=\"添加\" class=\"btn btn-primary\" @click=\"add()\">\n                    <label>\n                        搜索关键字:\n                        <input type=\"text\" class=\"form-control\" v-model=\"keywords\">\n                    </label>\n                </div>\n            </div>\n        </div>\n    \n        <table class=\"table table-bordered table-hover table-striped\">\n            <thead>\n            <tr>\n                <th>Id</th>\n                <th>Name</th>\n                <th>Ctime</th>\n                <th>Operation</th>\n            </tr>\n            </thead>\n            <tbody>\n            <!--之前v-for中的数据都是直接从data上的list中直接渲染过来的\n            现在我们定义一个search方法,同时,把所有的关键字通过传参的形式,传递给了search方法\n    \n             在search方法内部通过for循环,吧所有符合关键字的保存在一个新数组中返回\n            -->\n            <tr v-for=\"item in search(keywords)\" :key=\"item.Id\">\n                <td>{{item.Id}}</td>\n                <!--v-text中使用插值表达式会报错-->\n                <td v-text=\"item.Name\"></td>\n                <!--            <td>{{item.Ctime | dateFormat('yyyy-MM-DD-hh')}}</td>-->\n                <td>{{item.Ctime | dateFormat()}}</td>\n                <td>\n                    <!--阻止默认行为-->\n                    <a href=\"\" @click.prevent=\"del(item.Id)\">删除</a>\n                </td>\n            </tr>\n            </tbody>\n        </table>\n    </div>\n    <div id=\"app2\">\n        {{1 + 1}}\n        <h3>\n            {{dt | dateFormat()}}\n        </h3>\n    </div>\n    <script>\n        <!--    全局过滤器进行时间格式化-->\n        /*全局过滤器是所有的vue实例中都可以使用的*/\n        Vue.filter('dateFormat', function (dateStr, pattern = \"\") {\n            //根据给定的时间字符串,得到特定的时间\n            var dt = new Date(dateStr)\n            var y = dt.getFullYear();\n            var m = dt.getMonth() + 1;\n            var d = dt.getDate();\n            if (pattern && pattern.toLowerCase() === 'yyyy-mm-dd') {\n                //如果在使用时没有传入格式,那么就是用下面这个字符串片段\n                return `${y}-${m}-${d}`;\n            } else {\n                var hh = dt.getHours();\n                var mm = dt.getMinutes();\n                var ss = dt.getSeconds();\n                return `${y}-${m}-${d} ${hh}:${mm}:${ss} 你没有传入格式字符串`;\n            }\n        })\n        var vue = new Vue({\n            el: \"#app\",\n            data: {\n                Id: '',\n                Name: '',\n                keywords: '',\n                list: [\n                    {Id: 1, Name: '奔驰', Ctime: new Date()},\n                    {Id: 2, Name: '宝马', Ctime: new Date()},\n                ]\n    \n            },\n            methods: {\n                add() {\n                    // console.log(\"ok\");\n                    var car = {Id: this.Id, Name: this.Name, Ctime: new Date(),}\n                    this.list.push(car);\n                    this.Id = this.Name = \"\";\n                },\n                del(Id) {\n                    //some总如果返回了true,就会立即终止数组的循环\n                    /*this.list.some((item, i) => {\n                        if (item.Id == Id) {\n                            this.list.splice(i, 1);\n                            return true;\n                        }\n                    })*/\n    \n                    //使用find:专门查找索引\n                    var index = this.list.findIndex(item => {\n                        if (item.Id = Id) {\n                            return true;\n                        }\n                    })\n                    // console.log(index);\n                    this.list.splice(index, 1);\n                },\n                search(keywords) {\n                    //根据关键字进行数据的搜索\n                    /*var newlist = [];\n                    this.list.forEach(item => {\n                        if (item.Name.indexOf(keywords) != -1) {\n                            newlist.push(item);\n                        }\n                    })\n                    return newlist;*/\n    \n                    //注意,foreach some filter findIndex都属于数组的新方法,都会对数组中的每一项进行遍历,执行相关操作\n    \n                    //注意,在es6中提供了一个新方法, String.prototype.includes('要包含的字符串')\n                    //如果包含,则返回true,如果不包含,则返回false\n                    return this.list.filter(item => {\n                        if (item.Name.includes(keywords)) {\n                            return item;\n                        }\n    \n                    })\n                },\n            }\n        })\n    \n        // Vue.filter('过滤器名称', function () {\n        //\n        // })\n    \n        /*过滤器中的function第一个参数被定死的,永远是过滤器管道符前面传递过来的数据*/\n        /*    Vue.filter('', function (data) {\n            })*/\n    \n        //自定义私有过滤器(局部)\n        /*私有过滤器和全局过滤器的名字重复时,若该对象有私有过滤器,则会优先使用私有过滤器.过滤器采用的是就近原则\n        * * */\n        var vm2 = new Vue({\n            el: '#app2',\n            data: {\n                dt: new Date(),\n    \n            }, methods: {},\n            //这里面定义私有过滤器\n            filters: {\n                //    过滤器有两个条件: [过滤器名称 和 处理函数]\n                dateFormat: function (dateStr, pattern = \"\") {\n                    //根据给定的时间字符串,得到特定的时间\n                    var dt = new Date(dateStr)\n                    var y = dt.getFullYear();\n                    // var m = dt.getMonth();\n                    /*\n                    将String用str补全至maxLength位(顺序补全)\n                    String.padStart(maxLength,str)\n    \n                    将String用str补全至maxLength位(倒序补全)\n                    String.padEnd(maxLength,str)\n    \n                    * */\n                    var m = (dt.getMonth() + 1).toString().padStart(2, '0');\n                    var d = (dt.getDate() + 1).toString().padStart(2, '0');\n                    if (pattern && pattern.toLowerCase() === 'yyyy-mm-dd') {\n                        //如果在使用时没有传入格式,那么就是用下面这个字符串片段\n                        return `${y}-${m}-${d}`;\n                    } else {\n                        var hh = (dt.getHours() + 1).toString().padStart(2, '0');\n                        var mm = (dt.getMinutes() + 1).toString().padStart(2, '0');\n                        var ss = (dt.getSeconds() + 1).toString().padStart(2, '0');\n                        return `${y}-${m}-${d} ${hh}:${mm}:${ss} 自定义过滤器`;\n                    }\n                }\n    \n            }\n        })\n    </script>\n    </body>\n    </html>\n    \n\n如图,在name框中按下enter立刻提添加对象  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210420113053430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n使用自定义的按键修饰符:\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <mate name=\"viewport\" content=\"width=device-width\" , initial-scale=\"1.0\"/>\n        <title>自定义私有指令</title>\n        <script src=\"../lib/vue.js\"></script>\n        <link rel=\"stylesheet\" href=\"../lib/bootstrap.css\">\n        <!--vue中不要用到jquery-->\n    </head>\n    <body>\n    <div id=\"app\">\n        <div class=\"panel panel-primary\">\n            <div class=\"panel-heading\">\n                <h3 class=\"panel-title\"> 添加品牌 </h3>\n                <div class=\"panel-body form-inline\">\n                    <label>\n                        Id:\n                        <input type=\"text\" class=\"form-control\" v-model=\"Id\">\n                    </label>\n                    <label>\n                        Name:\n                        <!--keyup键盘抬起,触发add()操作(添加)-->\n                        <!--使用按键修饰符,enter键抬起时执行动作-->\n                        <!--<input type=\"text\" class=\"form-control\" v-model=\"Name\" @keyup.enter=\"add\">-->\n                        (使用指定的的按键修饰符,按下f2执行添加)\n                        <input type=\"text\" class=\"form-control\" v-model=\"Name\" @keyup.113=\"add\">\n                    </label>\n                    <!--V\n                    这里的@click=\"add\" 也可以写为 @click=\"add()\"\n                    后者可以传参了\n                    -->\n                    <input type=\"button\" value=\"添加\" class=\"btn btn-primary\" @click=\"add()\">\n                    <label>\n                        搜索关键字:\n                        <!--                    <input type=\"text\" class=\"form-control\" v-model=\"keywords\" id=\"search\">-->\n                        <!--vue中所有的指令在调用时都以v-开头-->\n                        <!--                    <input type=\"text\" class=\"form-control\" v-model=\"keywords\" id=\"search\" v-focus v-color>-->\n                        <!--自定义颜色:-->\n                        <!--如果这里\"\"内不使用''单引号括起来的话,等于的就是一个变量,而不是字符串了-->\n                        <input type=\"text\" class=\"form-control\" v-model=\"keywords\" id=\"search\" v-focus v-color=\"'blue'\">\n                    </label>\n                </div>\n            </div>\n        </div>\n    \n        <table class=\"table table-bordered table-hover table-striped\">\n            <thead>\n            <tr>\n                <th>Id</th>\n                <th>Name</th>\n                <th>Ctime</th>\n                <th>Operation</th>\n            </tr>\n            </thead>\n            <tbody>\n            <!--之前v-for中的数据都是直接从data上的list中直接渲染过来的\n            现在我们定义一个search方法,同时,把所有的关键字通过传参的形式,传递给了search方法\n             在search方法内部通过for循环,吧所有符合关键字的保存在一个新数组中返回\n            -->\n            <tr v-for=\"item in search(keywords)\" :key=\"item.Id\">\n                <td>{{item.Id}}</td>\n                <!--v-text中使用插值表达式会报错-->\n                <td v-text=\"item.Name\"></td>\n                <!--            <td>{{item.Ctime | dateFormat('yyyy-MM-DD-hh')}}</td>-->\n                <td>{{item.Ctime | dateFormat()}}</td>\n                <td>\n                    <!--阻止默认行为-->\n                    <a href=\"\" @click.prevent=\"del(item.Id)\">删除</a>\n                </td>\n            </tr>\n            </tbody>\n        </table>\n    </div>\n    \n    <div id=\"app2\">\n        {{1 + 1}}\n        <h3 v-color=\"'pink'\">\n            {{dt | dateFormat()}}\n        </h3>\n    </div>\n    \n    \n    <script>\n        /*全局自定义键盘修饰符*/\n        Vue.config.keyCodes.f2 = 113;\n    \n        <!--    全局过滤器进行时间格式化-->\n        /*全局过滤器是所有的vue实例中都可以使用的*/\n        Vue.filter('dateFormat', function (dateStr, pattern = \"\") {\n            //根据给定的时间字符串,得到特定的时间\n            var dt = new Date(dateStr)\n            var y = dt.getFullYear();\n            var m = dt.getMonth() + 1;\n            var d = dt.getDate();\n            if (pattern && pattern.toLowerCase() === 'yyyy-mm-dd') {\n                //如果在使用时没有传入格式,那么就是用下面这个字符串片段\n                return `${y}-${m}-${d}`;\n            } else {\n                var hh = dt.getHours();\n                var mm = dt.getMinutes();\n                var ss = dt.getSeconds();\n                return `${y}-${m}-${d} ${hh}:${mm}:${ss} 你没有传入格式字符串`;\n            }\n        })\n    \n        /*设置全局的自定义命令:\n        使用Vue.directive()定义全局的指令 v-focus\n        其中参数一: 指令的名称,注意在定义的时候,指令的名称前面,不需要加v-前缀\n        但是在调用的时候,必须在指令前面加上 v- 前缀来进行调用\n        参数二: 是一个对象,这个对象身上,有一些指令相关的函数,这些函数可以在特定的阶段,执行相关的操作\n        * * */\n        Vue.directive('focus', {\n            bind: function (el) {//每当指令绑定到元素上的时候,会立即执行这个bind函数 只执行一次\n                //注意:在每一个函数中,第一个参数永远是el,表示被指令的那个元素,这个el参数是一个原生的js对象(就是dom对象)\n                //在元素刚绑定了指令的时候,还没有插入到dom中去,这时候,调用focus方法没有作用\n                //因为一个元素只有插入dom之后才能获取焦点\n                // el.focus();\n            },\n            inserted: function (el) {//inserted表示元素插入到dom中的时候会执行inserted函数\n                //和js行为有关的操作,最好在inserted中执行,防止js行为不生效\n                el.focus();\n            },\n            updated: function () {//当VNode更新的时候,会执行update,肯能会触发多次[触发一次]\n    \n            }\n        })\n    \n        //自定义一个为字体设置颜色的指令\n        //设置样式时,不用关心元素是否被渲染到dom中,而style样式是直接绑定给元素的\n        Vue.directive('color', {\n            //样式只要通过指令绑定给力元素,不管这个元素有没有被插入到页面中去,这个元素肯定有了一个内联的样式\n            //将来元素肯定会显示到页面中去,这时候,浏览器的渲染引擎必然会解析样式.应用给这个元素\n    \n            /*binding是形参,用什么来接收都可以,所以binding可以写为其他的*/\n            bind: function (el, binding) {\n                //和样式相关的操作,一般都可以在bind中执行\n                // el.style.color = 'red';\n                console.log(binding);\n                /*使用传入的颜色*/\n                el.style.color = binding.value;\n            },\n        })\n    \n        var vue = new Vue({\n            el: \"#app\",\n            data: {\n                Id: '',\n                Name: '',\n                keywords: '',\n                list: [\n                    {Id: 1, Name: '奔驰', Ctime: new Date()},\n                    {Id: 2, Name: '宝马', Ctime: new Date()},\n                ]\n    \n            },\n            methods: {\n                add() {\n                    // console.log(\"ok\");\n                    var car = {Id: this.Id, Name: this.Name, Ctime: new Date(),}\n                    this.list.push(car);\n                    this.Id = this.Name = \"\";\n                },\n                del(Id) {\n                    //some总如果返回了true,就会立即终止数组的循环\n                    /*this.list.some((item, i) => {\n                        if (item.Id == Id) {\n                            this.list.splice(i, 1);\n                            return true;\n                        }\n                    })*/\n    \n                    //使用find:专门查找索引\n                    var index = this.list.findIndex(item => {\n                        if (item.Id = Id) {\n    \n                            return true;\n                        }\n                    })\n                    // console.log(index);\n                    this.list.splice(index, 1);\n                },\n                search(keywords) {\n                    //根据关键字进行数据的搜索\n                    /*var newlist = [];\n                    this.list.forEach(item => {\n                        if (item.Name.indexOf(keywords) != -1) {\n                            newlist.push(item);\n                        }\n                    })\n                    return newlist;*/\n    \n                    //注意,foreach some filter findIndex都属于数组的新方法,都会对数组中的每一项进行遍历,执行相关操作\n    \n                    //注意,在es6中提供了一个新方法, String.prototype.includes('要包含的字符串')\n                    //如果包含,则返回true,如果不包含,则返回false\n                    return this.list.filter(item => {\n                        if (item.Name.includes(keywords)) {\n                            return item;\n                        }\n    \n                    })\n                },\n            }\n        })\n    \n        // Vue.filter('过滤器名称', function () {\n        //\n        // })\n    \n        /*过滤器中的function第一个参数被定死的,永远是过滤器管道符前面传递过来的数据*/\n        /*    Vue.filter('', function (data) {\n            })*/\n    \n        //自定义私有过滤器(局部)\n        /*私有过滤器和全局过滤器的名字重复时,若该对象有私有过滤器,则会优先使用私有过滤器.过滤器采用的是就近原则\n        * * */\n        3\n        var vm2 = new Vue({\n            el: '#app2',\n            data: {\n                dt: new Date(),\n    \n            }, methods: {},\n            //这里面定义私有过滤器\n            filters: {\n                //    过滤器有两个条件: [过滤器名称 和 处理函数]\n                dateFormat: function (dateStr, pattern = \"\") {\n                    //根据给定的时间字符串,得到特定的时间\n                    var dt = new Date(dateStr)\n                    var y = dt.getFullYear();\n                    // var m = dt.getMonth();\n                    /*\n                    将String用str补全至maxLength位(顺序补全)\n                    String.padStart(maxLength,str)\n    \n                    将String用str补全至maxLength位(倒序补全)\n                    String.padEnd(maxLength,str)\n    \n                    * */\n                    var m = (dt.getMonth() + 1).toString().padStart(2, '0');\n                    var d = (dt.getDate() + 1).toString().padStart(2, '0');\n                    if (pattern && pattern.toLowerCase() === 'yyyy-mm-dd') {\n                        //如果在使用时没有传入格式,那么就是用下面这个字符串片段\n                        return `${y}-${m}-${d}`;\n                    } else {\n                        var hh = (dt.getHours() + 1).toString().padStart(2, '0');\n                        var mm = (dt.getMinutes() + 1).toString().padStart(2, '0');\n                        var ss = (dt.getSeconds() + 1).toString().padStart(2, '0');\n                        return `${y}-${m}-${d} ${hh}:${mm}:${ss} 自定义过滤器`;\n                    }\n                }\n            }\n        })\n        //设置进入页面时的焦点\n        //但是vue不提倡这么做\n        document.getElementById('search').focus()\n    </script>\n    </body>\n    </html>\n    \n\n* * *\n\n##### Vue中的指令:\n\n注意这里的`directive`后面不加 s ,私有指令的后面加 s\n\n自定义全局指令:\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <mate name=\"viewport\" content=\"width=device-width\" , initial-scale=\"1.0\"/>\n        <title>使用回车键回应添加</title>\n        <script src=\"../lib/vue.js\"></script>\n        <link rel=\"stylesheet\" href=\"../lib/bootstrap.css\">\n        <!--vue中不要用到jquery-->\n    </head>\n    <body>\n    <div id=\"app\">\n        <p v-fontweight=\"'30'\">私有指令测试</p>\n        <p v-fontweight=\"'900'\">{{msg}}</p>\n    </div>\n    \n    <script>\n        Vue.directive('fontweight', {\n            bind: function (el, binding) {\n                el.style.fontWeight = binding.value;\n                el.style.color = 'red';\n            }\n        })\n        var vm = new Vue({\n            el: '#app',\n            data: {\n                msg: 'data中用以测试的数据'\n            }, methods: {},\n            //这里面定义私有过滤器\n            filters: {},\n        })\n    </script>\n    </body>\n    </html>\n    \n\n自定义私有指令:\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <mate name=\"viewport\" content=\"width=device-width\" , initial-scale=\"1.0\"/>\n        <title>使用回车键回应添加</title>\n        <script src=\"../lib/vue.js\"></script>\n        <link rel=\"stylesheet\" href=\"../lib/bootstrap.css\">\n        <!--vue中不要用到jquery-->\n    </head>\n    <body>\n    <div id=\"app\">\n        <p v-fontweight=\"'30'\">私有指令测试</p>\n        <p v-fontweight=\"'900'\">{{msg}}</p>\n    </div>\n    \n    <script>\n        var vm = new Vue({\n            el: '#app',\n            data: {\n                msg: 'data中用以测试的数据'\n    \n            }, methods: {},\n            //这里面定义私有过滤器\n            filters: {},\n            directives: {\n                'fontweight': {\n                    bind: function (el, binding) {\n                        el.style.fontWeight = binding.value;\n                        el.style.color = 'red';\n                    }\n                }\n            },\n        })\n    </script>\n    </body>\n    </html>\n    \n\n指令简写:\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <mate name=\"viewport\" content=\"width=device-width\" , initial-scale=\"1.0\"/>\n        <title>指令简写</title>\n        <script src=\"../lib/vue.js\"></script>\n    </head>\n    <body>\n    <div id=\"app\">\n        <h3 v-fontsize=\"'20'\" v-color=\"'red'\">\n            这是一个用于测试字体大小的指令\n        </h3>\n    </div>\n    <!--\n    函数简写:\n    大多数情况下,我们想在bind和update钩子上做重复动作,并且不关心其他的钩子函数,可以这样写:\n    Vue.directive('color-swatch',function(el,binding){\n    el.style.backgroundColor=binding.value;\n    })\n    -->\n    <script>\n        var vm = new Vue({\n            el: '#app',\n            data: {}, methods: {}, filters: {}, directives: {\n                //注意,这个function等同于把代码写到了bind和update中去\n                'fontsize': function (el, binding) {\n                    // el.style.fontSize = binding.value;\n                    el.style.fontSize = parseInt(binding.value) + 'px';\n                }, 'color': function (el, binding) {\n                    el.style.color = binding.value;\n                }\n            }\n        })\n    </script>\n    </body>\n    </html>\n    \n\n运行:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210420113113881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n* * *\n\n###### Vue中的生命周期:\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <mate name=\"viewport\" content=\"width=device-width\" , initial-scale=\"1.0\"/>\n        <title>生命周期</title>\n        <script src=\"../lib/vue.js\"></script>\n    </head>\n    <body>\n    <div id=\"app\">\n        <input type=\"button\" value=\"修改\" @click=\"msg='No'\">\n        <h3 id=\"h3\">{{msg}}</h3>\n    </div>\n    <script>\n        var vm = new Vue({\n            el: '#app',\n            data: {\n                msg: \"ok\"\n            },\n            methods: {\n                show() {\n                    console.log(\"执行了show方法\");\n                }\n            },\n            beforeCreate() {//这是我们遇到的第一个生命周期,表示实例完全被创建出来之前,会执行它\n                // console.log(this.msg);\n                // this.show()\n                // 注意:在beforeCreate生命周期函数执行的时候,data和methods中的数据都还没有被初始化\n            },\n            created() {//这是遇到的第二个生命周期函数\n                // console.log(this.msg);\n                // this.show()\n                //在created中,data和methods都已经被初始化好了\n                //如果要调用methods中的方法,或者操作data中的数据,最早,只能在created中操作\n            },\n            beforeMount() {//这是遇到的第三个生命周期函数,表示模板已经在内存中编译完成了,但是尚未把模板渲染到页面中去\n                console.log('beforeMount    ' + document.getElementById('h3').innerText)\n                //beforeMount执行的时候,页面中的元素并没有被替换过来,只是之前写的模板字符串\n            },\n            mounted() {//遇到的第四个生命周期函数,表示内存中的模板,已经真实地挂载到了页面中去,用户已经可以看到渲染好的页面了\n                console.log('mounted    ' + document.getElementById('h3').innerText)\n                //注意:mounted是实例创建期间的最后一个生命周期函数,当执行完mounted就表示,实例已经被完全创建好了,此时,如果没有其他操作,这个实例就已经存在与内存当中了\n                //此时组件已经脱离了创建阶段,进入了运行阶段\n            },\n            //组件运行阶段的生命周期函数只有两个:beforeUpdate和updated\n            //这两个会根据数据的改变有选择性的触发零次到无数次\n    \n            //下面是运行中的两个事件:\n            beforeUpdate() {//这时候表示我们的页面还没有被更新\n                console.log('beforeUpdate(界面上元素的内容)    ' + document.getElementById('h3').innerText)\n                console.log('date中的最新数据是:   ' + this.msg)\n                //当执行beforeUpdate时,页面中显示的数据还是旧的,此时date数据是最新的,页面尚未和最新的数据保持同步\n            },\n            updated() {\n                console.log('updated(界面上元素的内容)    ' + document.getElementById('h3').innerText)\n                console.log('date中的最新数据是:   ' + this.msg)\n                //updated执行的时候,页面上的内容和数据已经保持同步了,都是最新的\n            }\n        })\n    </script>\n    </body>\n    </html>\n    \n    \n\n* * *\n\n##### Vue使用vue-resource发送请求:\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <mate name=\"viewport\" content=\"width=device-width\" , initial-scale=\"1.0\"/>\n        <title>vue-resource</title>\n        <script src=\"../lib/vue.js\"></script>\n        <!--要在vue后面导入这个包,它依赖于vue\n        它在vue身上挂载了 this.$http\n        -->\n        <script src=\"../lib/vue-resource1.3.4.js\"></script>\n    </head>\n    <body>\n    <div id=\"app\">\n        <input type=\"button\" value=\"发送get请求\" @click=\"getInfo\">\n        <input type=\"button\" value=\"发送post请求\" @click=\"postInfo\">\n        <input type=\"button\" value=\"发送jsonp请求\" @click=\"jsonpInfo\">\n    </div>\n    \n    <script>\n        var vm = new Vue({\n            el: '#app',\n            data: {}, methods: {\n                getInfo() {\n                    //发起get请求:\n                    //http://vue/studyit.io/api/getlunbo\n                    // this.$http.get('https://api.apiopen.top/searchMusic?name=%E5%A5%BD%E4%B9%85%E4%B8%8D%E8%A7%81').then(function (result) {\n                    this.$http.get('https://api.imjad.cn/cloudmusic/?type=song&id=28012031&br=128000').then(function (result) {\n                        console.log(result.body);\n                    })\n                },\n                postInfo() {\n                    //发起post请求\n                    //手动发起的post请求没有表单格式,所以,有的服务器处理不了\n                    //通过post方法的第三个参数,设置提交的内容类型,为普通表单数据格式\n                    this.$http.post('https://api.imjad.cn/cloudmusic/?type=song&id=28012031&br=128000', {}, {emulateJSON: true}).then(result => {\n                        console.log(result.body);\n                    })\n                },\n                jsonpInfo() {\n                    //发���jsonp请求\n                    this.$http.jsonp('http://vue.studyit.io/qpi/jsonp').then(result => {\n                        console.log(result);\n                    })\n                }\n            }, filters: {}, directives: {}\n        })\n    </script>\n    </body>\n    </html>\n    \n\n* * *\n\n##### Vue中的组件:\n\n使用全局组件:\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <mate name=\"viewport\" content=\"width=device-width\" , initial-scale=\"1.0\"/>\n        <title>07_创建组件</title>\n        <script src=\"../lib/vue.js\"></script>\n    </head>\n    <body>\n    <div id=\"app\">\n        <!--如果要使用组件,直接把组件的名称,以html标签的形式,引入到页面中,即可-->\n        <mycom1></mycom1>\n    </div>\n    \n    <script>\n        //1.1 使用Vue.extend来创建全局的vue组件\n        var com1 = Vue.extend({\n            template: '<h3>这是使用vue.extend创建的组件</h3>'//通过template属性,指定了组件要展示的html\n        });\n        //1.2 使用Vue.component('组件名称','创建出来的组件模板对象')\n        /*\n        使用驼峰命名时,在调用组件的时候必须把大写改为小写,在两个单词之间加 -\n        * */\n        // Vue.component('myCom1', com1);\n        /*\n        如果没有用驼峰命名法,那么不用在大写字母前加 -\n        * */\n        Vue.component('mycom1', com1);\n        var vm = new Vue({\n            el: '#app',\n        });\n    \n    \n        //2.也可以这样写:\n        //Vue.component第一个参数:组件的名称,将来在引用组件的时候,就是一个标签形式来引入它的\n        //第二个参数: VUe.extend 创建组件 ,其中,template就是组件将来要展示的html内容\n        //注意:不论是那种方式创建出来的组件,组件的template属性指向的模板内容,必须有且只能有一个根元素\n        //而且这种方式写模板字符串是没有提示的\n        /*Vue.component('mycom1', Vue.extend({\n            template: '<h3>这是使用vue.extend创建的组件</h3>'\n        }));\n        var vm = new Vue({\n            el: '#app',\n        })*/\n    \n        //3.或者:  \n        /*Vue.component('mycom2', {\n            template: '<h3>这是使用Vue.component 创建出来的组件</h3>'\n        });\n        var vm = new Vue({\n            el: '#app',\n        })*/\n    </script>\n    </body>\n    </html>\n    \n\n运行:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210420113125300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n通过template创建组件:\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <mate name=\"viewport\" content=\"width=device-width\" , initial-scale=\"1.0\"/>\n        <title>组件创建_3</title>\n        <script src=\"../lib/vue.js\"></script>\n    </head>\n    <body>\n    <!--在被控制的div外面,使用template元素定义组件的模板结构-->\n    <template id=\"tmp1\">\n        <div>\n            <h1>这是通过template在外部定义的组件结构,这个方式有代码的智能提示和高亮</h1>\n            <h3>好用且不错</h3>\n        </div>\n    </template>\n    <div id=\"app\">\n        <mycom3></mycom3>\n    </div>\n    <script>\n        Vue.component('mycom3', {\n            template: '#tmp1',\n        })\n        var vm = new Vue({\n            el: '#app'\n        })\n    </script>\n    </body>\n    </html>\n    \n\n运行:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210420113133270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n创建私有组件:\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <mate name=\"viewport\" content=\"width=device-width\" , initial-scale=\"1.0\"/>\n        <title>10_创建私有模板</title>\n        <script src=\"../lib/vue.js\"></script>\n    </head>\n    <body>\n    <!--在被控制的div外面,使用template元素定义组件的模板结构-->\n    <template id=\"tmp1\">\n        <div>\n            <h1>这是通过template在外部定义的组件结构,这个方式有代码的智能提示和高亮</h1>\n            <h3>好用且不错</h3>\n        </div>\n    </template>\n    <template id=\"tmp2\">\n        <h1>这是私有的login组件</h1>\n    </template>\n    \n    <div id=\"app\">\n        <mycom3></mycom3>\n    </div>\n    \n    <div id=\"app2\">\n        <login></login>\n    </div>\n    \n    <script>\n        Vue.component('mycom3', {\n            template: '#tmp1',\n        })\n        var vm = new Vue({\n            el: '#app'\n        })\n    </script>\n    \n    <script>\n        vm2 = new Vue({\n            el: '#app2',\n            data: {},\n            methods: {},\n            filters: {},\n            directives: {},\n            components: {//实例内部定义有组件\n                login: {\n                    // template: '<h1>这是私有的login组件</h1>'\n                    //或者在外部定义template\n                    template: '#tmp2'\n                }\n            },\n        })\n    </script>\n    </body>\n    </html>\n    \n\n运行:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210420113142393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n组件中定义数据:\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <mate name=\"viewport\" content=\"width=device-width\" , initial-scale=\"1.0\"/>\n        <title>组件中的data和methods</title>\n        <script src=\"../lib/vue.js\"></script>\n    </head>\n    <body>\n    <div id=\"app\">\n        <mycom1></mycom1>\n    </div>\n    \n    <script>\n        // 1.组件可以有自己的data数据\n        //2.组件大data和实例的data有些不一样，实例中的data可以作为一个对象，但是组件中的data必须是一个方法\n        //3.组件中的data必须为一个方法之外，这个方内部还必须返回一个对象才行\n        Vue.component('mycom1', {\n                    template: '<h1>这个是全局组件{{msg}}</h1>',\n                    data: function () {\n                        return {\n                            msg: '---这是组件中的定义的数据---'\n                        }\n                    }\n                }\n        )\n        var vm = new Vue({\n            el: '#app',\n            data: {}, methods: {},\n        })\n    </script>\n    </body>\n    </html>\n    \n\n运行:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210420113151735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n组件的切换(这个只能切换两个组件):\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <mate name=\"viewport\" content=\"width=device-width\" , initial-scale=\"1.0\"/>\n        <title>13_不同组件之间的切换</title>\n        <script src=\"../lib/vue.js\"></script>\n    </head>\n    <body>\n    <!--缺陷:只能切换俩-->\n    <div id=\"app\">\n        <a href=\"#\" @click.prevent=\"flag=true\">登录</a>\n        <a href=\"#\" @click.prevent=\"flag=false\">注册</a>\n        <login v-if=\"flag\"></login>\n        <register v-else=\"flag\"></register>\n    </div>\n    <script>\n        Vue.component('login', {\n            template: '<h3>登录组件</h3>'\n        })\n        Vue.component('register', {\n            template: '<h3>注册组件</h3>'\n        })\n        var vm = new Vue({\n            el: '#app',\n            data: {\n                flag: false\n            },\n            methods: {}\n        })\n    </script>\n    </body>\n    </html>\n    \n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210420113159171.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n组件切换二(可以切换两个及以上):\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <mate name=\"viewport\" content=\"width=device-width\" , initial-scale=\"1.0\"/>\n        <title>14_不同组件之间切换_方式二</title>\n        <script src=\"../lib/vue.js\"></script>\n    </head>\n    <body>\n    <div id=\"app\">\n        <a href=\"#\" @click.prevent=\"comName='login'\">登录</a>\n        <a href=\"#\" @click.prevent=\"comName='register'\">注册</a>\n        <!--vue提供了component组件来展示对应名称的组件-->\n        <!--conponent是一个占位符.: 属性,可以用来指定要展示的组件的名称-->\n        <!--填写组件名称的时候,用 ' 包裹起来,表示它是一个组件-->\n        <component :is=\"comName\"></component>\n        <!--当前学习的几个Vue组件:-->\n        <!--component template transition  transitionGroup-->\n    </div>\n    <script>\n        <!--组件名称是字符串-->\n        Vue.component('login', {\n            template: '<h3>登录组件</h3>'\n        })\n        Vue.component('register', {\n            template: '<h3>注册组件</h3>'\n        })\n        var vm = new Vue({\n            el: '#app',\n            data: {\n                comName: 'login'//当前component中的:''中绑定的组件名称\n            }, methods: {}\n        })\n    </script>\n    </body>\n    </html>\n    \n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210420113206927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n* * *\n\n> 未完,他日再写",
        "states": "0",
        "description": "Vue的基本结构:Vue中的插值:Vue中的事件修饰符:Vue双向绑定机制:Vue中为元素添加样式:Vue中的动画:Vue中的循环:Vue中的key的作用及其意义:Vue中v-fi和v-show:Vue中的过滤器:Vue中的键盘修饰符:Vue中的指令:Vue中的生命周期:Vue使用vue-resource发送请求:Vue中的组件:Vue的基本结构:&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &",
        "praise": "0",
        "view": "1",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/115898770",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-06T09:23:46.000Z",
        "destroyTime": null
    },
    {
        "id": 101,
        "email": "2714351312@qq.com",
        "title": "Vue执行动画(transition)",
        "content": "###### Vue中的动画机制: [参考](https://cn.vuejs.org/v2/guide/transitions.html#%E6%98%BE%E6%80%A7%E7%9A%84%E8%BF%87%E6%B8%A1%E6%8C%81%E7%BB%AD%E6%97%B6%E9%97%B4)\n\nVue中的动画可以认为是有生命周期的:\n\n> 下面前四个事件是元素进入中到完成进入  \n> 后四个是元素离开时到完全离开\n\n    <transition\n                v-on:before-enter=\"beforeEnter\"\n                v-on:enter=\"enter\"\n                v-on:after-enter=\"afterEnter\"\n                v-on:enter-cancelled=\"enterCancelled\"\n    \n                v-on:before-leave=\"beforeLeave\"\n                v-on:leave=\"leave\"\n                v-on:after-leave=\"afterLeave\"\n                v-on:leave-cancelled=\"leaveCancelled\"\n        >\n            <!-- ... -->\n        </transition>\n    \n\n* * *\n\n##### 1.`transition`使用默认的前缀定义动画:\n\n        <!--自定义两组样式来控制transition内部元素实现动画-->\n        <style>\n            /*v-enter[这是一个时间点]是进入之前,元素的起始状态,此时还没有开始进入*/\n            /*v-leave-to[这是一个时间点] 是动画离开之后,离开的终止状态,此时元素动画已经结束*/\n            /*\n            这里的v-enter,v-leave-to等是为transition定义动画效果的\n            */\n            .v-enter,\n            .v-leave-to {\n                opacity: 0;\n                transform: translateX(80px);\n            }\n            /*v-enter-active [入场动画的时间段]*/\n            /*v-leave-active [离场动画的时间段]*/\n            .v-enter-active,\n            .v-leave-active {\n                transition: all 0.8s ease;\n            }\n        </style>\n    </head>\n    <body>\n    <div id=\"app\">\n        <input type=\"button\" value=\"toggle\" @click=\"flag=!flag\">\n        <!--1.使用transition使元素动起来-->\n        <!--transition是官方提供的-->\n        <transition>\n            <h3 v-if=\"flag\">这是一个h3</h3>\n        </transition>\n    </div>\n    \n    <script>\n        var vm = new Vue({\n            el: '#app', data: {\n                flag: false,\n            }, methods: {}\n        })\n    </script>\n    </body>\n    \n\n> 此处是在html中定义了一个`transition`标签,再使用默认的`过渡的类名`来设置动画\n\n效果: 啊这,自己试一试吧,gjf图不太好整\n\n##### 2.`transition`使用自定义的前缀定义动画:\n\n    <style>\n    \t\t/*默认前缀的样式*/\n            .v-enter,\n            .v-leave-to {\n                opacity: 0;\n                transform: translateX(80px);\n            }\n            .v-enter-active,\n            .v-leave-active {\n                transition: all 0.8s ease;\n            }\n            /*my-前缀的样式*/\n            .my-enter,\n            .my-leave-to {\n                opacity: 0;\n                transform: translateY(80px);\n            }\n            .my-enter-active,\n            .my-leave-active {\n                transition: all 0.8s ease;\n            }\n        </style>\n    </head>\n    <body>\n    <div id=\"app\">\n        <input type=\"button\" value=\"toggle\" @click=\"flag=!flag\">\n        <!--\n        transition中.为他定义属性的前缀默认是v-\n        -->\n        <transition>\n            <h3 v-if=\"flag\">这是一个h3</h3>\n        </transition>\n        <hr>\n        <input type=\"button\" value=\"toggle2\" @click=\"flag2=!flag2\">\n        <!--此时如果不想和上面的功用一个style,可以为transition定一个name--->\n        <!--\n        从而使该transition的样式定义的前缀为my-\n        -->\n        <transition name=\"my\">\n            <h6 v-if=\"flag2\">这是一个h6</h6>\n        </transition>\n    </div>\n    <script>\n        var vm = new Vue({\n            el: '#app',\n            data: {\n                flag: false,\n                flag2: false\n            },\n            methods: {}\n        })\n    </script>\n    </body>\n    \n\n> 此处是在html标签中的`transition`标签里定义了一个`name=前缀`,然后在style中使用`前缀-enter`等定义动画\n\n效果: 啊这,自己试一试吧,gjf图不太好整",
        "states": "0",
        "description": "Vue中的动画机制: 参考Vue中的动画可以认为是有生命周期的:下面前四个事件是元素进入中到完成进入后四个是元素离开时到完全离开&lt;transition            v-on:before-enter=\"beforeEnter\"            v-on:enter=\"enter\"            v-on:after-enter=\"afterEnter\"            v-on:enter-cancelled=\"enterCancelled\"   ",
        "praise": "0",
        "view": "8",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/114984830",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-19T06:30:35.000Z",
        "destroyTime": null
    },
    {
        "id": 102,
        "email": "2714351312@qq.com",
        "title": "vue_过滤器_note",
        "content": "#### vue中过滤器的作用:\n\n> 将常见的字符串格式化 and soon(英语好像用错了)\n\n##### 过滤器有`全局过滤器`和`私有过滤器`(仅作用在当前的vue实例)\n\n##### 使用:\n\n1.在vue实例外面中定义你的过滤器(`此时是全局过滤器`),如:\n\n    <script>\n        <!--    全局过滤器进行时间格式化-->\n        Vue.filter('dateFormat', function (dateStr) {\n            //根据给定的时间字符串,得到特定的时间\n            var dt = new Date(dateStr)\n            var y = dt.getFullYear();\n            var m = dt.getMonth();\n            var d = dt.getDate();\n            return `${y}-${m}-${d}`;\n        })\n        var vm = new Vue({\n            el: '#app',\n            data: {\n                time1: new Date(),\n            }, methods: {}\n        })\n    </script>\n    \n\n2.在vue中定义过滤器(`此时是私有过滤器`):\n\n    <script>\n        var vue = new Vue({\n            el: '#app',\n            data: {\n                time1: new Date(),\n            }, \n            methods: {}, \n            //在`filters`中定义过滤器\n            filters: {\n                dataFormat(dateStr) {\n                    //根据给定的时间字符串,得到特定的时间\n                    var dt = new Date(dateStr)\n                    var y = dt.getFullYear();\n                    var m = dt.getMonth();\n                    var d = dt.getDate();\n                    return `${y}-${m}-${d}`;\n                }\n            }\n        })\n    </script>\n    \n\n* * *\n\n#### 使用的例子:\n\n    <!DOCTYPE html>\n    <html lang=\"en\" xmlns:v-bind=\"http://www.w3.org/1999/xhtml\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <mate name=\"viewport\" content=\"width=device-width\" , initial-scale=\"1.0\"/>\n        <title>全局过滤器演示</title>\n        <script src=\"vue.js\"></script>\n    </head>\n    <body>\n    <div id=\"app\">\n    <!--    <h2>不使用过滤器:{{time1}}</h2>-->\n        <h2>第一种方法:{{time1 | dateFormat}}</h2>\n        <p>第二种方法\n            <input type=\"text\" v-bind:value=\"time1 | dateFormat\">\n        </p>\n    </div>\n    <script>\n        <!--    全局过滤器进行时间格式化-->\n        Vue.filter('dateFormat', function (dateStr) {\n            //根据给定的时间字符串,得到特定的时间\n            var dt = new Date(dateStr)\n            var y = dt.getFullYear();\n            var m = dt.getMonth();\n            var d = dt.getDate();\n            return `${y}-${m}-${d}`;\n        })\n        var vm = new Vue({\n            el: '#app',\n            data: {\n                time1: new Date(),\n            }, methods: {}\n        })\n    </script>\n    </body>\n    </html>\n    \n\n不使用过滤器:\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021031217400498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n使用过滤器:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021031211345971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n* * *\n\n私有过滤器和全局过滤器的区别:  \n(其实也就`前者只能用于过滤器所在的vue实例`),`后者是所有vue实例都可以使用`\n\n* * *\n\n如果`私有过滤器和全局过滤器名称重复时`,使用该过滤器时会`优先使用私有过滤器`",
        "states": "0",
        "description": "vue中过滤器的作用:将常见的字符串格式化 and soon(英语好像用错了)过滤器有全局过滤器和私有过滤器(仅作用在当前的vue实例)使用:1.在vue实例外面中定义你的过滤器(此时是全局过滤器),如:&lt;script&gt;    &lt;!--    全局过滤器进行时间格式化--&gt;    Vue.filter('dateFormat', function (dateStr) {        //根据给定的时间字符串,得到特定的时间        var dt = ne",
        "praise": "0",
        "view": "2",
        "audit": "1",
        "tag1": "vue",
        "tag2": "html",
        "tag3": "前端",
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/114691024",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-06-02T17:00:40.000Z",
        "destroyTime": null
    },
    {
        "id": 103,
        "email": "2714351312@qq.com",
        "title": "note_idea中的maven命令操作",
        "content": null,
        "states": "0",
        "description": "将自己的项目添加至本地库:之前用命令行是mvn install在idea中操作:执行maven目标使用mvn install即可安装成功:",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": "java",
        "tag2": "maven",
        "tag3": "less",
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/114220629",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-07T08:10:54.000Z",
        "destroyTime": null
    },
    {
        "id": 104,
        "email": "2714351312@qq.com",
        "title": "note_pom.xml文件配置说明_note",
        "content": null,
        "states": "0",
        "description": "仅作为参考笔记,不推荐&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": "java",
        "tag2": "maven",
        "tag3": "less",
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/114212878",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-07T08:10:50.000Z",
        "destroyTime": null
    },
    {
        "id": 105,
        "email": "2714351312@qq.com",
        "title": "note_maven中的常用命令",
        "content": "*   编译命令:`mvn compile`\n\n> 编译时,它会去编译HelloWorld中的java代码  \n>   \n> 在编译时,需要在`pom`所在的目录(如\"`C:\\Windows\\System32\\cmd.exe`)进行命令行操作:  \n>   \n> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210228110939700.png)\n\n> 使用`mvn compile`命令  \n>   \n> 此时它会自动下载在`pom.xml`配置的本地仓库,添加的依赖时首先在本地仓库中找,本地仓库找不到了会去中央仓库下载  \n>   \n> 完成时:  \n> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210228111011166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n> 在第一次下载时,它会下载一些基础的maven的jar包  \n>   \n> 编译成功之后:  \n> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210228111025762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n> 圈起来的是编译之后代码的目录  \n> 该命令只编译main目录中的代码\n\n*   测试命令:`mvn test`\n\n> 还是在刚刚的命令行中操作  \n>   \n> 使用`mvn test`命令:  \n> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210228111055447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n> 此时它下载的是测试环境要用的一些基础包  \n>   \n> 测试完之后,它会报告测试了多少,会报错  \n> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210228111106966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n*   打包:`mvn package`  \n    \n\n> 第一次执行时也会下载一些环境  \n> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210228111129509.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n> 注: _只有测试通过才能打包成功_  \n>   \n> 打包成功:  \n> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210228111140787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n> 同时会显示存放的路径\n\n*   将所使用的插件放入本地仓库以供使用:`mvn install`\n\n> 将开发的模块放入本地仓库供其他模块使用  \n>   \n> 放入的路径由`pom.xml`中的`gav`决定  \n> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210228111154309.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n> 完成:  \n> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210228111205740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n> 这里安装到本地仓库的路径是在之前设置的路径:  \n>   \n> ![在这里插入图片描述](https://img-blog.csdnimg.cn/2021022811121285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n> 路径中和`pom.xml`中的`gav`对应关系:  \n>   \n> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210228111218878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n*   删除target(删除编译文件的目录):`mvn clean`\n\n> 运行mvn命令,必须在pom.xml所在的目录",
        "states": "0",
        "description": "编译命令:mvn compile编译时,它会去编译HelloWorld中的java代码在编译时,需要在pom所在的目录(如\"C:\\Windows\\System32\\cmd.exe)进行命令行操作:使用mvn compile命令此时它会自动下载在pom.xml配置的本地仓库,添加的依赖时首先在本地仓库中找,本地仓库找不到了会去中央仓库下载完成时:在第一次下载时,它会下载一些基础的maven的jar包编译成功之后:圈起来的是编译之后代码的目录该命令只编译main目录中的代码.",
        "praise": "0",
        "view": "2",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/114213112",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-11T17:24:04.000Z",
        "destroyTime": null
    },
    {
        "id": 106,
        "email": "2714351312@qq.com",
        "title": "note_maven的pom.xml部分配置说明",
        "content": null,
        "states": "0",
        "description": "仅作为个人参考的笔记,不推荐看&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.ap",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/114213028",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 107,
        "email": "2714351312@qq.com",
        "title": "note_maven的基本使用",
        "content": "*   1.下载配置maven\n\n> > [官网](http://maven.apache.org/download.cgi) ,[下载链接](https://mirror.bit.edu.cn/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz)  \n> >   \n> > a.配置`JAVA_HOME`  \n> >   \n> > b.配置`MAVEN_HOME` / `M2_HOME`  \n> >   \n> > c.将maven中的bin配置到path: %MAVEN HOME%\\\\bin  \n> >   \n> > d.检验:命令行下输入`mvn -v`:  \n> >   \n> > \\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传  \n> >   \n> > ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210228105619626.png)\n\n> e.配置本地仓库:  \n> \n> > 本地仓库需要在maven文件下的`conf`中的`seeting`中修改(默认值是:`${user.home}/.m2/repository`):  \n> >   \n> > 修改本地仓库,把圈起来的东西抄出来就行了:  \n> >   \n> > \\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传  \n> >   \n> > ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210228105605424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n> 修改后如图:  \n>   \n> \\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传  \n>   \n> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210228105634790.png)\n\n*   2.使用maven:  \n    \n\n> > 软件开发原则:约定 优于 配置  \n> > \n> > > 1.硬编码方式: job.setPath(“d:\\\\abc”\")  \n> > >   \n> > > 2.配置方式:job 下写`conf.xml` d:\\\\abc  \n> > >   \n> > > 3.约定方式(使用默认值)  \n> \n> > maven约定结果目录:  \n> > \n> > > 执行项目去`main`中找,测试项目去`test`中找  \n> > >   \n> > > \\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传  \n> > >   \n> > > ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210228105650476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n> 其中`maven_1`为模块名,  \n>   \n> `main`放主程序代码,  \n>   \n> `test`放测试代码,  \n>   \n> `resources`放资源代码/配置代码,  \n>   \n> `pom.xml`:项目对象模型  \n\n* * *\n\n*   maven的仓库:  \n    \n\n> 本地仓库:  \n>   \n> 远程仓库:  \n> \n> > 中央仓库  \n> >   \n> > 中央仓库镜像(对中央仓库的分流)  \n> >   \n> > 私服nexus",
        "states": "0",
        "description": "1.下载配置maven官网 ,下载链接 a.配置JAVA_HOMEb.配置MAVEN_HOME / M2_HOMEc.将maven中的bin配置到path: %MAVEN HOME%\\bind.检验:命令行下输入mvn -v:[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传e.配置本地仓库:本地仓库需要在maven文件下的conf中的seeting中修改(默认值是:${user.home}/.m2/repository):修改本地仓库,把圈起来的东西抄.",
        "praise": "0",
        "view": "6",
        "audit": "1",
        "tag1": "java",
        "tag2": "note",
        "tag3": "maven",
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/114212433",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-07T08:10:42.000Z",
        "destroyTime": null
    },
    {
        "id": 108,
        "email": "2714351312@qq.com",
        "title": "note_maven的概念,作用",
        "content": null,
        "states": "0",
        "description": "maven的概念:它是一个基于java平台的自动化构建工具(make-&gt;ant-&gt;maven-&gt;gradle)maven的作用:a.管理jari.增加第三方jar(commons-fileupload.jar commons-io.jar)ii.管理jar包之间的一览关系(例如当你告诉了使用commons-fileupload.jar,它发现这个包依赖于commons-io.jar时,它会自动下载依赖关联的所有jar,并且不会冲突)b.将项目拆分成若干.",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/114210522",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 109,
        "email": "2714351312@qq.com",
        "title": "前端中实时显示当前时间的js代码",
        "content": "###### 纯小白,不对的地方请指正\n\n代码:\n\n    <script>\n        var t = null;\n        t = setTimeout(time, 1000);//開始运行\n        function time() {\n            clearTimeout(t);//清除定时器\n            dt = new Date();\n            var y = dt.getFullYear();\n            var mt = dt.getMonth() + 1;\n            var day = dt.getDate();\n            var h = dt.getHours();//获取时\n            var m = dt.getMinutes();//获取分\n            var s = dt.getSeconds();//获取秒\n            // 为类名为`.showTime`的元素添加时间\n            document.querySelector(\".showTime\").innerHTML = '当前时间：' + y + \"年\" + mt + \"月\" + day + \"-\" + h + \"时\" + m + \"分\" + s + \"秒\";\n            t = setTimeout(time, 1000); //设定定时器，循环运行\n        }\n    </script>\n    \n\n> 选中`showTime`的class标签.改变它的html文本内容为时间字符串,每秒刷新一次\n\n效果:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210218163745311.png)",
        "states": "0",
        "description": "纯小白,不对的地方请指正代码:&lt;script&gt;    var t = null;    t = setTimeout(time, 1000);//開始运行    function time() {        clearTimeout(t);//清除定时器        dt = new Date();        var y = dt.getFullYear();        var mt = dt.getMonth() + 1;        var day = d",
        "praise": "0",
        "view": "6",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/113849104",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "1",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-07-06T06:46:29.000Z",
        "destroyTime": null
    },
    {
        "id": 110,
        "email": "2714351312@qq.com",
        "title": "python下绘制叠加区域图和叠加柱状图",
        "content": "数据：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210105193136463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n叠加区域图\n\n代码：\n\n    # KIRIN\n    # 2021-1-5\n    # 18:41\n    # 叠加折线图\n    import pandas as pd\n    \n    import matplotlib.pyplot as plt\n    \n    csv = pd.read_csv(\"data/26_.csv\")\n    \n    print(csv.columns)\n    \n    csv.plot.area(y=['id', 'from', 'a', 'b'], color=['red', 'blue', 'yellow','brown'])\n    \n    plt.title('It\\'s a title', fontsize=16, fontweight='bold')\n    plt.ylabel('total', fontsize=12)\n    \n    # 设置x轴的排列顺序为csv中的index\n    plt.xticks(csv.index + 1, fontsize=18)\n    \n    plt.show()\n    \n\n结果：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210105193040682.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n叠加柱状图：\n\n代码：\n\n    # KIRIN\n    # 2021-1-5\n    # 18:41\n    # 叠加柱状图\n    import pandas as pd\n    \n    import matplotlib.pyplot as plt\n    \n    csv = pd.read_csv(\"data/26_.csv\")\n    \n    print(csv.columns)\n    \n    csv.plot.bar(y=['id', 'from', 'a', 'b'], color=['red', 'blue', 'yellow','brown'])\n    \n    plt.title('It\\'s a title', fontsize=16, fontweight='bold')\n    plt.ylabel('total', fontsize=12)\n    \n    # 设置x轴的排列顺序为csv中的index\n    plt.xticks(csv.index + 1, fontsize=18)\n    \n    plt.show()\n    \n\n结果：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210105193556678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n传递进`stacked=True`:\n\n    csv.plot.bar(y=['id', 'from', 'a', 'b'], color=['red', 'blue', 'yellow', 'brown'], stacked=True)\n    \n\n结果：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210105193957834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n（也就看起来好了一点）",
        "states": "0",
        "description": "数据：代码：# KIRIN# 2021-1-5# 18:41# 叠加折线图import pandas as pdimport matplotlib.pyplot as pltcsv = pd.read_csv(\"data/26_.csv\")print(csv.columns)csv.plot.area(y=['id', 'from', 'a', 'b'], color=['red', 'blue', 'yellow','brown'])plt.title('It\\'s a ",
        "praise": "0",
        "view": "2",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/112251150",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "2",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-11T17:23:52.000Z",
        "destroyTime": null
    },
    {
        "id": 111,
        "email": "2714351312@qq.com",
        "title": "python下绘制折线图",
        "content": "利用下面的数据：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210105164849734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n(最简化版本)代码：\n\n    # KIRIN\n    # 2021-1-5\n    # 16:19\n    # 绘制折线图\n    import pandas as pd\n    \n    import matplotlib.pyplot as plt\n    \n    csv = pd.read_csv(\"data/26_.csv\")\n    \n    print(csv.columns)\n    \n    csv.plot(y=['id', 'from', 'a', 'b'], color=['red', 'blue', 'yellow'])\n    \n    plt.show()\n    \n\n结果：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210105184449950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n增加其他选项的图：\n\n    # KIRIN\n    # 2021-1-5\n    # 16:19\n    # 绘制折线图\n    import pandas as pd\n    \n    import matplotlib.pyplot as plt\n    \n    csv = pd.read_csv(\"data/26_.csv\")\n    \n    print(csv.columns)\n    \n    # 控制折线图的颜色\n    csv.plot(y=['id', 'from', 'a', 'b'], color={'red', 'blue', 'brown', 'black'})\n    \n    plt.title('It\\'s a title', fontsize=16, fontweight='bold')\n    plt.ylabel('total', fontsize=12)\n    \n    # 设置x轴的排列顺序为csv中的index\n    plt.xticks(csv.index + 1, fontsize=18)\n    \n    plt.show()\n    \n\n结果(我这里from和a的数据一样，所以from的折线被覆盖了)：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210105192614467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)",
        "states": "0",
        "description": "利用下面的数据：(最简化版本)代码：# KIRIN# 2021-1-5# 16:19# 绘制折线图import pandas as pdimport matplotlib.pyplot as pltcsv = pd.read_csv(\"data/26_.csv\")print(csv.columns)csv.plot(y=['id', 'from', 'a', 'b'], color=['red', 'blue', 'yellow'])plt.show()...",
        "praise": "0",
        "view": "5",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/112244130",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "1",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-12T02:04:40.000Z",
        "destroyTime": null
    },
    {
        "id": 112,
        "email": "2714351312@qq.com",
        "title": "利用pandas，matplotlib画饼图",
        "content": null,
        "states": "0",
        "description": "前言今天没得前言这样的数据：先画一个最简单的饼图：# @DATE : 2021-1-3# @TIME : 13:36# @USER : kirinimport pandas as pdimport matplotlib.pyplot as pltcsv = pd.read_csv(\"data/26_.csv\")csv['a'].plot.pie()plt.show()结果：这个图中旁边的的数字显示的其实是csv的index，因为在这里我没有设置index文件读取后设..",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/112235838",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "1",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 113,
        "email": "2714351312@qq.com",
        "title": "利用pandas,pyplot 绘制柱状图",
        "content": "> *   前言:  \n>     整活真好玩\n\n利用下列数据:\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210103133911587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n直接上代码:\n\n    import pandas as pd\n    import matplotlib.pyplot as plt\n    \n    csv = pd.read_csv(\"data/salary.csv\")\n    csv.plot.bar(x='id', y='money', color='red', title='money')\n    plt.show()\n    \n\n结果:\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021010313412217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n此时如果想要按照`money`进行降序排列:\n\n只需要在`csv`读取之后加上:\n\n    csv.sort_values(by='money', inplace=True, ascending=False)\n    \n\n*   注意:\n    ---\n    \n\n如果这句写为\n\n    csv = csv.sort_values(by='money', inplace=True, ascending=False)\n    \n\n会报错:\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021010313441099.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n写一个demo你会发现:\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210103134502173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n    csv.sort_values(by='money', inplace=True, ascending=False)\n    \n\n返回的是一个空值\n\n*   补充:\n    ---\n    \n\n> 一:`cvs.plot.bar`中另一写法\n\n    csv.plot.bar(x='id', y='money', color='red', title='money')\n    \n\n也可以写为:\n\n    plt.bar(csv.id, csv.money, color='red',title='money')\n    \n\n代码中如果写的是`plt.bar(csv.id, csv.money, color='skyblue')`:\n\n    \n    import pandas as pd\n    import matplotlib.pyplot as plt\n    \n    csv = pd.read_csv(\"data/salary.csv\")\n    \n    plt.bar(csv.id, csv.money, color='skyblue')\n    \n    plt.tight_layout()\n    plt.show()\n    \n\n你就会发现这个图很别扭:\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021010313495580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)  \n此时我们需要对其进行修改:\n\n    # 调整x轴挤在一起的数据旋转90度:\n    plt.xticks(csv.id, rotation=90)\n    \n\n    # 显示x轴标识:\n    plt.xlabel('id')\n    \n\n    # 显示y轴标识:\n    plt.ylabel('money')\n    \n\n    # 显示标题:\n    plt.title('international_student')\n    \n    \n\n    # 紧凑型的布局\n    plt.tight_layout()\n    \n\n结果:\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210103135338454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n> 二:图表颜色,标题,紧凑型布局:\n\n    # 修改颜色,添加标题\n    csv.plot.bar(x='id', y='money', color='red', title='money')\n    \n\n    # 紧凑型布局:\n    plt.tight_layout()\n    \n\n这个紧凑布局,我这里就一张图,显示的没啥区别,看下面这位大佬的文章可以看出效果\n\n[大佬](https://blog.csdn.net/Du_Shuang/article/details/84139716)\n\n* * *\n\n*   下面没啥好看的了\n\n* * *\n\n完整代码笔记:  \n20\\_.py\n\n    # @DATE : 2021-1-3\n    # @TIME : 11:25\n    # @USER : kirin\n    \n    # pandas制图\n    import pandas as pd\n    import matplotlib.pyplot as plt\n    \n    # csv = pd.read_csv(\"data/salary.csv\", index_col='id')\n    csv = pd.read_csv(\"data/salary.csv\")\n    csv = csv.sort_values(by='money', inplace=True, ascending=False)\n    # csv = csv.sort_values(by='money', inplace=True)\n    # color:更改图标颜色,title:更改图标名称\n    csv.plot.bar(x='id', y='money', color='red', title='money')\n    # 紧凑型的布局\n    plt.tight_layout()\n    plt.show()\n    # print(csv)\n    \n\n21\\_.py\n\n    # @DATE : 2021-1-3\n    # @TIME : 11:47\n    # @USER : kirin\n    \n    # matplotlib制图\n    \n    import pandas as pd\n    import matplotlib.pyplot as plt\n    \n    # csv = pd.read_csv(\"data/salary.csv\", index_col='id')\n    csv = pd.read_csv(\"data/salary.csv\")\n    # csv.plot.bar(x='id', y='money', color='red', title='money')\n    \n    # 或者不写x,y= :\n    plt.bar(csv.id, csv.money, color='skyblue')\n    # 此时会发现它的x轴数据挤在一起了,并且没有x轴和y轴的标识,所以需要调整:\n    \n    # 调整x轴挤在一起的数据旋转90度:\n    plt.xticks(csv.id, rotation=90)\n    \n    # 显示x轴标识:\n    plt.xlabel('id')\n    \n    # 显示y轴标识:\n    plt.ylabel('money')\n    \n    # 显示标题:\n    plt.title('international_student')\n    \n    # 紧凑型的布局\n    plt.tight_layout()\n    plt.show()\n    # print(csv)",
        "states": "0",
        "description": "前言:整活真好玩利用下列数据:直接上代码:import pandas as pdimport matplotlib.pyplot as pltcsv = pd.read_csv(\"data/salary.csv\")csv.plot.bar(x='id', y='money', color='red', title='money')plt.show()结果:此时如果想要按照money进行降序排列:只需要在csv读取之后加上:csv.sort_values(by='mon..",
        "praise": "0",
        "view": "2",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/112134054",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "2",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-11T17:23:45.000Z",
        "destroyTime": null
    },
    {
        "id": 114,
        "email": "2714351312@qq.com",
        "title": "利用pandas对一列/多列进行数据区间筛选",
        "content": null,
        "states": "0",
        "description": "前言如果不整活,那就是浪费生命下面这个表,如果你想筛选出age大于等于18,小于等于30的行:如果在mysql中整这种活很容易,用个where就可以了在pandas中也有相当于where作用的语法,loc筛选18&lt;=age&lt;=30的数据:import pandas as pdstu = pd.read_csv(\"data/student.csv\", index_col='id')# 留下18&lt;=年龄&lt;=30def age_18_to30(a):   ..",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/112113788",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "3",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 115,
        "email": "2714351312@qq.com",
        "title": "pandas中对列进行排序(单列/多列)/(升序/降序)/(多列升序,降序控制)",
        "content": null,
        "states": "0",
        "description": "前言我想把数据分析刻进DNA里如下面的数据,对price,要进行最简单的升序操作:这个好整:import pandas as pdshop = pd.read_csv(\"data/shop.csv\", index_col='id')shop.sort_values(by='price', inplace=True)结果:按照降序,传递进ascending,并将其值改为False即可:import pandas as pdshop = pd.read_csv(\"dat..",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": null,
        "tag2": null,
        "tag3": null,
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/112100311",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "39",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-04-27T07:57:48.000Z",
        "destroyTime": null
    },
    {
        "id": 116,
        "email": "2714351312@qq.com",
        "title": "pandas中计算两列相乘",
        "content": "#### 在excel中计算两列相乘是十分容易的,在pandas中也是如此\n\n如下表中的Discoount 和 ListPrice相乘\n\n\n![](https://img-blog.csdnimg.cn/20210102124431130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n直接上python代码:\n```python\n# @DATE : 2021-1-2\n# @TIME : 11:49\n# @USER : kirin\n# 利用pandas计算打折后的价格\n\nimport pandas as pd\n\nbook = pd.read_csv(\"data/book_sel_2.csv\", index_col='id')\n# 操作符的重载,在pandas中 * 如果他的两边都是列,那么,它会把两边进行对齐,相乘\n# 方法一:\n# book['Price'] = book['ListPrice'] * book['Discount']\n# 也可以列 * 数字\n# book['Price'] = book['ListPrice'] * 0.8\n\n# 方法二:\n# 对整个index进行运算:\n# for i in book.index:\n#     book['Price'].at[i] = book['ListPrice'].at[i] * book['Discount'].at[i]\n\n# 如果你并不是想全部相乘,而是对其中的部分进行运算:\nfor i in range(5, 10):\n    book['Price'].at[i] = book['ListPrice'].at[i] * book['Discount'].at[i]\nprint(book)\n```\n\n输出:\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021010212503141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n对应代码文件:F:\\Project\\python\\src\\WangYiYun\\DataAnalysis\\15.py",
        "states": "0",
        "description": "在excel中计算两列相乘是十分容易的,在pandas中也是如此如下表中的Discoount 和 ListPrice相乘直接上python代码:# @DATE : 2021-1-2# @TIME : 11:49# @USER : kirin# 利用pandas计算打折后的价格import pandas as pdbook = pd.read_csv(\"data/book_sel_2.csv\", index_col='id')# 操作符的重载,在pandas中 * 如果他的两边都是列,",
        "praise": "0",
        "view": "12",
        "audit": "1",
        "tag1": "python",
        "tag2": "pandas",
        "tag3": "note",
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/112095008",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "4",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-11T17:13:46.000Z",
        "destroyTime": null
    },
    {
        "id": 117,
        "email": "2714351312@qq.com",
        "title": "fullpage常用配置",
        "content": "主要是看script里面的常用配置\n\n    <!DOCTYPE html>\n    <html lang=\"zh-CN\">\n    <head>\n        <meta charset=\"utf-8\">\n        <meta name=\"renderer\" content=\"webkit\">\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <title>fullpage常用配置</title>\n        <link rel=\"stylesheet\" href=\"css/fullpage.css\">\n        <!--注意:FullPage是基于jQuery的插件-->\n        <script src=\"js/jquery-3.1.1.js\"></script>\n        <script src=\"js/easings.js\"></script>\n        <script src=\"js/scrolloverflow.js\"></script>\n        <script src=\"js/fullpage.js\"></script>\n    </head>\n    <body>\n    \n    <div id=\"fullpage\">\n        <div class=\"section\">Some section 1</div>\n        <div class=\"section\">Some section 2</div>\n        <div class=\"section\">Some section 3</div>\n        <div class=\"section\">Some section 4</div>\n    </div>\n    \n    <script>\n        new fullpage('#fullpage', {\n            //设置每页的背景颜色\n            sectionsColor: ['red', 'yellow', 'blue', 'pink'],\n            //是否显示右侧小圆点,默认为false(显示指示器)\n            navigation: true,\n            //设置鼠标移到小圆点上时显示的内容\n            navigationTooltips: ['1tip', '2top', '3spt', '4piu'],\n            //设置小圆点显示的内容是否默认直接显示而不需要鼠标移上去\n            showActiveTooltip: true,\n            //设置指示器默认显示在哪里\n            // navigationPosition: 'left',\n            //定义滚动到最后一节后是否要滚动到第一节,默认为false\n            // loopBottom: true,\n            //设置滚动到第一页后再望山滚是否回滚到最后一页,默认为false\n            // loopTop: true,\n            //实现无限循环滚动\n            continueVertical: true,\n            // 控制section文字是否上下居中\n            verticalCentered: false,\n    \n        })\n    </script>\n    </body>\n    </html>",
        "states": "0",
        "description": "主要是看scripp里面的常用配置&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;meta name=\"renderer\" content=\"webkit\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" c",
        "praise": "0",
        "view": "16",
        "audit": "1",
        "tag1": "demo",
        "tag2": "html",
        "tag3": "fullpage",
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/110913340",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-07-06T06:52:45.000Z",
        "destroyTime": null
    },
    {
        "id": 118,
        "email": "2714351312@qq.com",
        "title": "页面中鼠标触碰字体后切换颜色且随鼠标移走后改变",
        "content": null,
        "states": "0",
        "description": "such as:",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": "html",
        "tag2": "less",
        "tag3": "css",
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/110839289",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "1",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-11T17:09:16.000Z",
        "destroyTime": null
    },
    {
        "id": 119,
        "email": "2714351312@qq.com",
        "title": "11_less中的条件判断",
        "content": null,
        "states": "0",
        "description": "less中可以通过when混合添加执行限定条件,只有条件满足(为真)才会执行混合中的代码when表达式中可以使用比较运算符(&gt; &lt; &gt;= &lt;= =),逻辑运算符,或检查函数来进行条件判断&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;meta name=\"renderer\" content=\"webkit\"&gt;   .",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": "html",
        "tag2": "less",
        "tag3": "css",
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/110729295",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-11T17:09:12.000Z",
        "destroyTime": null
    },
    {
        "id": 120,
        "email": "2714351312@qq.com",
        "title": "10_less中的继承",
        "content": null,
        "states": "0",
        "description": "html:&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;meta name=\"renderer\" content=\"webkit\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"widt",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": "html",
        "tag2": "less",
        "tag3": "css",
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/110729288",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-11T17:09:09.000Z",
        "destroyTime": null
    },
    {
        "id": 121,
        "email": "2714351312@qq.com",
        "title": "9_less中的层级结构",
        "content": null,
        "states": "0",
        "description": "如果在某一选择器的 {} 中直接写上了其他的选择器,会自动转换成后代选择器,如:.father{  .son{    }}此时编译为css就是(好像这个有点废话了):.father .son{}&amp; 的作用是,告诉less在转换时,不要用后代来转换,直接拼接在当前选择器的后面即可例如:.father {  width: 300px;  height: 300px;  background: red;  position: absolute;  top: 5.",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": "html",
        "tag2": "less",
        "tag3": "css",
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/110729281",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-11T17:09:06.000Z",
        "destroyTime": null
    },
    {
        "id": 122,
        "email": "2714351312@qq.com",
        "title": "8_less中的内置函数",
        "content": null,
        "states": "0",
        "description": "less中更支持一些js函数:直接上html代码:&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;meta name=\"renderer\" content=\"webkit\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"vi",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": "less",
        "tag2": "html",
        "tag3": "css",
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/110729257",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-07T08:10:08.000Z",
        "destroyTime": null
    },
    {
        "id": 123,
        "email": "2714351312@qq.com",
        "title": "4_less中带参数混合",
        "content": null,
        "states": "0",
        "description": "less中你可以定义一些形参,将数值传入形参,然后再将形参赋予给某一元素(就是利用形参为该元素添加属性)如:// 创建一个形参.whc(@w:,@h:,@c) {  width: @w;  height: @h;  background: @c;}.div1 {  //width: 200px;  //height: 200px;  //background: red;　//下面一行就相当于上面三行的代码  .whc(200px, 200px, red);}也可以使用带默认",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": "css",
        "tag2": "less",
        "tag3": "html",
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/110729215",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-08T06:46:52.000Z",
        "destroyTime": null
    },
    {
        "id": 124,
        "email": "2714351312@qq.com",
        "title": "7_less中引入其他文件 / 模块",
        "content": "在less中引入(这玩意你可以引入文件名,加不加好慢的扩展名都可以,或者你直接引入要用的模块之类的):\n\n    // 四种导入方式都可以\n    //@import \"triangle.less\";\n    //@import \"triangle\";\n    @import \"09\";\n    //@import \"09.less\";\n    \n    div {\n      .triangle(Down, 40px, red);\n    }\n    \n\n输出:\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201205233130404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n我这里的目录结构:\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201205233136914.png)\n\ntriangle这个东西在9.less中,  \n  \n代码:\n\n    .triangle(@_,@width,@color) {\n      width: 0;\n      height: 0;\n      border-style: solid solid solid solid;\n    }\n    \n    .triangle(Down,@width,@color) {\n      border-width: @width;\n      border-color: @color transparent transparent transparent;\n    }",
        "states": "0",
        "description": "在less中引入(这玩意你可以引入文件名,加不加好慢的扩展名都可以,或者你直接引入要用的模块之类的):// 四种导入方式都可以//@import \"triangle.less\";//@import \"triangle\";@import \"09\";//@import \"09.less\";div {  .triangle(Down, 40px, red);}输出:我这里的目录结构:triangle这个东西在9.less中,代码:.triangle(@_,@width,@colo",
        "praise": "0",
        "view": "14",
        "audit": "1",
        "tag1": "css",
        "tag2": "html",
        "tag3": "less",
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/110729250",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-11T17:19:03.000Z",
        "destroyTime": null
    },
    {
        "id": 125,
        "email": "2714351312@qq.com",
        "title": "6_less中的匹配模式",
        "content": null,
        "states": "0",
        "description": "如果利用div创建一个箭头:它的HTML代码:&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;meta name=\"renderer\" content=\"webkit\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"vie",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": "less",
        "tag2": "html",
        "tag3": "css",
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/110729237",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-07T08:10:05.000Z",
        "destroyTime": null
    },
    {
        "id": 126,
        "email": "2714351312@qq.com",
        "title": "5_less中传入可变参数",
        "content": null,
        "states": "0",
        "description": "先上效果图(最开始是宽高200px,红色,鼠标移上去,变为宽高400px,蓝色,0s延迟,持续4s):less如果不用可变参数的话:.animate(@name,@time,@mode,@delay) {  transition: @name, @time, @mode, @delay;}div {  width: 200px;  height: 200px;  background: red;  .animate(all, 4s, linear, 0s);}在 () 写的东西",
        "praise": "0",
        "view": "0",
        "audit": "1",
        "tag1": "less",
        "tag2": "html",
        "tag3": "css",
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/110729225",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-07T08:10:03.000Z",
        "destroyTime": null
    },
    {
        "id": 127,
        "email": "2714351312@qq.com",
        "title": "3_less混和(使用类来混合)",
        "content": "*   less支持混合\n\n> 什么是less混合?\n> \n> > 将需要重复使用的代码封装到一个类中,在需要的地方调用封装好的类即可,  \n> >   \n> > 在预处理的时候,less会自动将用到的封装好的类中的代码拷贝进来  \n> >   \n> > 本质就是ctrl+c --> Ctrl+v  \n\nhtml代码:\n\n    <!DOCTYPE html>\n    <html lang=\"zh-CN\">\n    <head>\n        <meta charset=\"utf-8\">\n        <meta name=\"renderer\" content=\"webkit\">\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <title></title>\n        <style>\n            * {\n                margin: 0;\n                padding: 0;\n            }\n        </style>\n        <link rel=\"stylesheet\" href=\"css/06.css\">\n    </head>\n    <body>\n    <div class=\"father\">\n        <div class=\"son\"></div>\n    </div>\n    </body>\n    </html>\n    \n\n例如,要利用上面的HTML代码实现这样一个效果:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201205232733522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n#### 如果不用less混合的话,less代码:\n\n    .father {\n      width: 300px;\n      height: 300px;\n      background: red;\n      position: absolute;\n      left: 50%;\n      top: 50%;\n      transform: translate(-50%, -50%);\n    \n      .son {\n        width: 200px;\n        height: 200px;\n        background: blue;\n        position: absolute;\n        left: 50%;\n        top: 50%;\n        transform: translate(-50%, -50%);\n      }\n    }\n    \n\n而这其中有`后面四行代码是重复的`,\n\n但是如果使用混合,将重复代码包装成一个类,用到这些代码的时候,在调用,岂不美哉@~@\n\n#### less使用混合的代码:\n\n    .center {\n      position: absolute;\n      left: 50%;\n      top: 50%;\n      transform: translate(-50%, -50%);\n    }\n    \n    .father {\n      width: 300px;\n      height: 300px;\n      background: red;\n      .center();\n    \n      .son {\n        width: 200px;\n        height: 200px;\n        background: blue;\n        .center();\n      }\n    }\n    \n\n*   less中的混合的注意点:  \n      \n    如果混合名称的后面没有(),那么在预处理的时候,会保留混合的代码  \n      \n    如果混合的名称后面加上(),那么在预处理的时候,不会保留混合的代码  \n      \n    预处理时,在less的center后面加上() 的话,  \n      \n    转编译css文件的时候,就会将css中的center部分代码添加入css元素中,  \n    \n\n就比如:  \ncenter后面有`()`:  \n  \nless:\n\n    .center() {\n      position: absolute;\n      left: 50%;\n      top: 50%;\n      transform: translate(-50%, -50%);\n    }\n    .father {\n      width: 300px;\n      height: 300px;\n      background: red;\n      .center();\n      .son {\n        width: 200px;\n        height: 200px;\n        background: blue;\n        .center();\n      }\n    }\n    \n\n编译的css文件:\n\n    .father {\n      width: 300px;\n      height: 300px;\n      background: red;\n      position: absolute;\n      left: 50%;\n      top: 50%;\n      transform: translate(-50%, -50%);\n    }\n    .father .son {\n      width: 200px;\n      height: 200px;\n      background: blue;\n      position: absolute;\n      left: 50%;\n      top: 50%;\n      transform: translate(-50%, -50%);\n    }\n    \n\ncenter后面没有`()`:  \n  \nless:\n\n    .center {\n      position: absolute;\n      left: 50%;\n      top: 50%;\n      transform: translate(-50%, -50%);\n    }\n    \n    .father {\n      width: 300px;\n      height: 300px;\n      background: red;\n      .center();\n    \n      .son {\n        width: 200px;\n        height: 200px;\n        background: blue;\n        .center();\n      }\n    }\n    \n    \n\n编译的css文件:\n\n    .center {\n      position: absolute;\n      left: 50%;\n      top: 50%;\n      transform: translate(-50%, -50%);\n    }\n    .father {\n      width: 300px;\n      height: 300px;\n      background: red;\n      position: absolute;\n      left: 50%;\n      top: 50%;\n      transform: translate(-50%, -50%);\n    }\n    .father .son {\n      width: 200px;\n      height: 200px;\n      background: blue;\n      position: absolute;\n      left: 50%;\n      top: 50%;\n      transform: translate(-50%, -50%);\n    }\n    \n\n对比一下就看出来了",
        "states": "0",
        "description": "less支持混合什么是less混合?将需要重复使用的代码封装到一个类中,在需要的地方调用封装好的类即可,在预处理的时候,less会自动将用到的封装好的类中的代码拷贝进来本质就是ctrl+c --&gt; Ctrl+vhtml代码:&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;meta name=\"renderer\" conten.",
        "praise": "0",
        "view": "2",
        "audit": "1",
        "tag1": "less",
        "tag2": "html",
        "tag3": "css",
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/110729201",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "1",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-08T06:56:46.000Z",
        "destroyTime": null
    },
    {
        "id": 128,
        "email": "2714351312@qq.com",
        "title": "2_less中的数值运算",
        "content": "*   ### less中可以进行一些新增css3中的运算\n    \n\nhtml:\n\n    <!DOCTYPE html>\n    <html lang=\"zh-CN\">\n    <head>\n        <meta charset=\"utf-8\">\n        <meta name=\"renderer\" content=\"webkit\">\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <title></title>\n        <!--<style>\n            * {\n                margin: 0;\n                padding: 0;\n            }\n            // 使div元素水平居中\n            div {\n                // 一:\n                width: 200px;\n                height: 200px;\n                background: blue;\n                position: absolute;\n                left: 50%;\n                /*弊端:不利于编码,需要口算宽度的一半*/\n                /*margin-left: -100px;*/\n    \n                // 二:\n                /*弊端:transform是新增属性,有的浏览器不支持,所以不利于兼容,有一说一我觉得一般用的浏览器都兼容了吧*/\n                /*transform: translateX(-50%);*/\n    \n                //三:\n                /*在css3中新增了一个cala()函数,可以实现简单的运算*/\n                /*弊端:css3新增的,有的不支持*/\n                /*margin-left: calc(-200px / 2);*/\n                /*margin-left: calc(-200px / 0.5);*/\n            }\n        </style>-->\n        <link rel=\"stylesheet\" href=\"css/05.css\">\n    </head>\n    <body>\n    <div>\n        \n    </div>\n    </body>\n    </html>\n    \n\nless代码实现:\n\n    div {\n      width: 200px;\n      height: 200px;\n      background: blue;\n      position: absolute;\n      left: 50%;\n      /*less中新增的运算和css3中新增的运算一样,的支持+ - * / 运算*/\n      /*运算时要添加单位*/\n      margin-left: calc(-200px * 0.5);\n    }",
        "states": "0",
        "description": "less中可以进行一些新增css3中的运算html:&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;meta name=\"renderer\" content=\"webkit\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta nam..",
        "praise": "0",
        "view": "12",
        "audit": "1",
        "tag1": "less",
        "tag2": "note",
        "tag3": "html",
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/110729186",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-19T02:47:06.000Z",
        "destroyTime": null
    },
    {
        "id": 129,
        "email": "2714351312@qq.com",
        "title": "1_初识less&引用&变量&作用域&变量差值",
        "content": "_**之前直接上手了一些项目,接触到了less,用起来简单又方便(比CSS香多了),**_  \n  \n_**之后就想学习一下less,最近学了下,顺便也积累了写,就写个less的小结(此小结偏向于实践)**_\n\n* * *\n\n*   [less中文网](https://less.bootcss.com/)\n    \n*   less简介:Less 是一门 CSS 预处理语言,它扩展了 CSS 语言,增加了变量,Mixin,函数等特性,使 CSS 更易维护和扩展.Less 可以运行在 Node 或浏览器端\n    \n*   常见的css预处理器:Less,Sass,Stylus\n    \n\n* * *\n\n*   less编译为css:  \n    \n\n[考拉客户端](http://koala-app.com/index-zh.html)\n\n[在线编译](https://www.w3cschool.cn/tools/index?name=LESS) 这种网站就很多了\n\n(有时候运行less,想看看其编译的css样式的时候用得到)\n\n* * *\n\n*   ### less在html中使用:  \n    \n\n直接引入,莫忘了在rel里面写 `stylesheet/less`  \n  \nlink 直接 tab 不全的话,rel里是不会有后面的 /less ,此时是引入less会报错的(我用的webstrom是这样的)\n\n        <!--这两个是必须引入的-->\n        <link rel=\"stylesheet/less\" href=\"css/test.less\">\n        <script src=\"js/less.js\"></script>\n    \n\n> 补充:\n> \n> > h5的type属性中默认值就是type=“text/css” ,所以在link标签中可以不写type(当然排除个别浏览器不支持,主流浏览器都支持)\n\n* * *\n\n*   ### less的注释:\n    \n\n    // 单行注释\n    /*多行注释*/\n    \n\n* * *\n\n*   ### less中定义变量:  \n    \n\n和js中的基本概念一样\n\n        // 为w(宽)设置为300px\n        @w: 300px;\n        // 将w的值赋给h(高)\n        @h: @w;\n        // 为c(color的值)设置为red\n        @c: red;\n        .box1 {\n          @c: blue;\n          width: @w;\n          height: @h;\n          background: @c;\n          margin-bottom: 20px;\n          @c: pink;\n        }\n        .box2 {\n          width: @w;\n          height: @h;\n          background: @c;\n        }\n    \n\nHTML文件:\n\n    <!DOCTYPE html>\n    <html lang=\"zh-CN\">\n    <head>\n        <meta charset=\"utf-8\">\n        <meta name=\"renderer\" content=\"webkit\">\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <title>03_less-variable</title>\n        <style>\n            * {\n                margin: 0;\n                padding: 0;\n            }\n        </style>\n        <link rel=\"stylesheet/less\" href=\"css/03_less-vairable.less\">\n        <script src=\"js/less.js\"></script>\n    </head>\n    <body>\n    <div class=\"box1\"></div>\n    <div class=\"box2\"></div>\n    \n    </body>\n    </html>\n    \n\n运行:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201205232331373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n*   less也有全局变量和局部变量之分:  \n      \n    定义在{}外面就是全局变量,什么地方都可以使用  \n      \n    定义在{}里面的就是局部变量,只能在{}中使用  \n    \n\n_**注意点:less中的变量是延迟加载的,`写到后面变量也能在前面使用`**_\n\n*   less中访问变量的原则与js一样:  \n      \n    和js一样不同作用域的变量不会互相影响,只有相同作用域的变量才会互相影响  \n      \n    和js一样在访问变量时会采用就近原则\n    \n*   在less中可以自定义变量名\n    \n\n        @size: 200px;\n        @w: width;\n        @s: div;\n        @{s} {\n          /*在less中变量名如果想要用自定义的变量,那么必须使用变量差值的方法\n          @{变量名}\n          */\n            @{w}: @size;\n          height: @size;\n          background: red;\n        }\n    \n\nhtml代码:\n\n    <!DOCTYPE html>\n    <html lang=\"zh-CN\">\n    <head>\n        <meta charset=\"utf-8\">\n        <meta name=\"renderer\" content=\"webkit\">\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <title>04_less-Variable-interpolation</title>\n        <style>\n            * {\n                margin: 0;\n                padding: 0;\n            }\n        </style>\n        <link rel=\"stylesheet/less\" href=\"css/04_less-Variable-interpolation.less\">\n        <script src=\"js/less.js\"></script>\n    </head>\n    <body>\n    <div></div>\n    \n    </body>\n    </html>\n    \n\n运行:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201205232400975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)",
        "states": "0",
        "description": "之前直接上手了一些项目,接触到了less,用起来简单又方便(比CSS香多了), 之后就想学习一下less,最近学了下,顺便也积累了写,就写个less的小结(此小结偏向于实践)less中文网less简介:Less 是一门 CSS 预处理语言,它扩展了 CSS 语言,增加了变量,Mixin,函数等特性,使 CSS 更易维护和扩展.Less 可以运行在 Node 或浏览器端常见的css预处理器:Less,Sass,Stylusless编译为css:考拉客户端在线编译 这种网站",
        "praise": "0",
        "view": "38",
        "audit": "1",
        "tag1": "less",
        "tag2": "html",
        "tag3": "css",
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/110729161",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-07T08:09:52.000Z",
        "destroyTime": null
    },
    {
        "id": 130,
        "email": "2714351312@qq.com",
        "title": "利用CSS使元素在水平方向或水平,竖直同时居中",
        "content": "水平居中  \n三种方法,参考:\n\n    \n    <!DOCTYPE html>\n    <html lang=\"zh-CN\">\n    <head>\n        <meta charset=\"utf-8\">\n        <meta name=\"renderer\" content=\"webkit\">\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <title></title>\n        <style>\n            * {\n                margin: 0;\n                padding: 0;\n            }\n    \n            div {\n                // 一:\n                width: 200px;\n                height: 200px;\n                background: blue;\n                position: absolute;\n                left: 50%;\n                /*弊端:不利于编码,需要口算宽度的一半*/\n                /*margin-left: -100px;*/\n    \n                // 二:\n                /*弊端:transform是新增属性,有的浏览器不支持,所以不利于兼容*/\n                transform: translateX(-50%);\n    \n                //三:\n                /*在css3中新增了一个cala()函数,可以实现简单的运算*/\n                /*弊端:css3新增的,有的不支持*/\n                /*margin-left: calc(-200px / 2);*/\n                /*margin-left: calc(-200px / 0.5);*/\n            }\n        </style>\n    </head>\n    <body>\n    \n    <div></div>\n    \n    </body>\n    </html>\n    \n\n效果:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201204170000732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n* * *\n\n水平,竖直方向居中,一种方法:\n\n    <!DOCTYPE html>\n    <html lang=\"zh-CN\">\n    <head>\n        <meta charset=\"utf-8\">\n        <meta name=\"renderer\" content=\"webkit\">\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <title></title>\n        <style>\n            * {\n                margin: 0;\n                padding: 0;\n            }\n    \n            .father {\n                width: 300px;\n                height: 300px;\n                background: red;\n                position: absolute;\n                top: 50%;\n                left: 50%;\n                transform: translate(-50%, -50%);\n            }\n    \n            .father .son {\n                width: 200px;\n                height: 200px;\n                background: blue;\n                position: absolute;\n                top: 50%;\n                left: 50%;\n                transform: translate(-50%, -50%);\n            }\n    \n        </style>\n    </head>\n    <body>\n    <div class=\"father\">\n        <div class=\"son\"></div>\n    </div>\n    </body>\n    </html>\n    \n\n效果:\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201204230014507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)",
        "states": "0",
        "description": "三张方法,参考:&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;meta name=\"renderer\" content=\"webkit\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"",
        "praise": "0",
        "view": "2",
        "audit": "1",
        "tag1": "demo",
        "tag2": "css",
        "tag3": "less",
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/110662086",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-07T08:11:24.000Z",
        "destroyTime": null
    },
    {
        "id": 131,
        "email": "2714351312@qq.com",
        "title": "python安装第三方库时报错 SyntaxError: invalid syntax",
        "content": "如图:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201204120828333.png)  \n原因是我在Python里面用了pip installxxx  \n这个命令应该是在cmd中使用的  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201204120924531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)",
        "states": "0",
        "description": "如图:原因是我在Python里面用了pip installxxx这个命令应该是在cmd中使用的",
        "praise": "0",
        "view": "10",
        "audit": "1",
        "tag1": "python",
        "tag2": "note",
        "tag3": "bug",
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/110632675",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "4",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-08T06:46:29.000Z",
        "destroyTime": null
    },
    {
        "id": 132,
        "email": "2714351312@qq.com",
        "title": "ES6_proxy_note",
        "content": "*   proxy:代理\n\n> Proxy 用于修改某些操作的默认行为,等同于在语言层面做出修改，所以属于一种“元编程”(meta programming),即对编程语言进行编程  \n>   \n> Proxy 可以理解成,在目标对象之前架设一层“拦截”,外界对该对象的访问,都必须先通过这层拦截,因此提供了一种机制,可以对外界的访问进行过滤和改写.Proxy 这个词的原意是代理,用在这里表示由它来“代理”某些操作,可以译为“代理器”\n\n> 主要是扩展 / 增强 对象的一些功能\n\n> 比如说 Vue中的 Vue.key.Codes.enter=65\n\n* * *\n\n> proxy作用:  \n>   \n> Vue中的拦截,上报,扩展功能,统计,增强功能等的\n\n> proxy是设计模式的一中,代理模式\n\n* * *\n\n> 语法:  \n> new Proxy(target,handler);  \n>   \n> let obj = new Proxy(被代理的对象,对对立对象的操作)\n> \n> *   注意:被代理的对象可以是null  \n>       \n>     hander是一个json:\n> \n>     <script >\n>        {\n>        set(){},//设置的时候干的事\n>        get(){},// 获取对象属性\n>        deleteProperty(){},//删除\n>        has(){},//判断有没有\n>        apply(){}//调用函数的处理\n>        // 等等\n>        }\n>     </script>\n>     \n\n> 如:利用proxy创建元素:\n> \n>     <script >\n>        const DOM = new Proxy({}, {\n>            get(target, property) {\n>                // property 就是 DOM.xx 里面的xxx\n>                // console.log(target, property);\n>                // ...:扩展剩余参数\n>                return function (attr = {}, ...children) {\n>                    // console.log(attr, children);\n>                    const el = document.createElement(property);\n>                    for (let key of Object.keys(attr)) {\n>                        // 为el添加属性\n>                        el.setAttribute(key, attr[key]);\n>                    }\n>                    //再添加子元素\n>                    for (let child of children) {\n>                        if (typeof child == 'string') {\n>                            child = document.createTextNode(child);\n>                        }\n>                        el.appendChild(child);\n>                    }\n>                    return el;\n>                }\n>            }\n>        });\n>        let oDiv = DOM.div({id: 'div1', class: 'aaa'}, '我是div', '呵呵呵');\n>        console.log(oDiv);\n>     </script>\n>     \n> \n> 利用proxy创建元素及其子元素:\n> \n>     <script >\n>        const DOM = new Proxy({}, {\n>            get(target, property) {\n>                // property 就是 DOM.xx 里面的xxx\n>                // console.log(target, property);\n>                // ...:扩展剩余参数\n>                return function (attr = {}, ...children) {\n>                    // console.log(attr, children);\n>                    const el = document.createElement(property);\n>                    for (let key of Object.keys(attr)) {\n>                        // 为el添加属性\n>                        el.setAttribute(key, attr[key]);\n>                    }\n>                    //再添加子元素\n>                    for (let child of children) {\n>                        if (typeof child == 'string') {\n>                            child = document.createTextNode(child);\n>                        }\n>                        el.appendChild(child);\n>                    }\n>                    return el;\n>                }\n>            }\n>        });\n>        //只要用DOM创建元素就调用了代理\n>        let oDiv = DOM.div({id: 'div1', class: 'aaa'}, '我是div', '呵呵呵');\n>        console.log(oDiv);\n>     </script>\n>     \n\n* * *\n\n> 使用set进行拦截 和  \n> 实现一个,访问对象身上的属性,默认不存在的时候返回undefined,希望如果不存在,返回错误(警告)信息,如:\n> \n>     <script >\n>        { // 使用set进行拦截\n>            let obj = new Proxy({}, {\n>                set(target, prop, value) {\n>                    console.log(target, prop, value);\n>                }\n>            });\n>            obj.a = 132;\n>            console.log(\"split---\");\n>        }\n>        // 设置一个年龄保证为整数,大于18,不能超过200\n>        let obj = new Proxy({}, {\n>            set(target, prop, value) {\n>                if (prop == 'age') {\n>                    if (!Number.isInteger(value)) {\n>                        throw new TypeError(`年龄必须为整数`);\n>                    }\n>                    if (value > 200) {\n>                        throw new RangeError(`年龄超标了,必须小于200岁`);\n>                    }\n>                }\n>                target[prop] = value;\n>            }\n>        });\n>        obj.a = 123;\n>        obj.name = 'kirin';\n>        console.log(obj);\n>        // 报错\n>        // obj.age = 13.5;\n>        obj.age = 13;\n>     \n>        /*\n>        deleteProperty():删除,拦截\n>        has():检测有没有\n>        * */\n>     </script>\n>     \n\n* * *\n\n> 利用proxy删除与判断:\n> \n>     <script >\n>        let json = {\n>            a: 1,\n>            b: 2\n>        };\n>        let newJson = new Proxy(json, {\n>            deleteProperty(target, property) {\n>                console.log(`你要删除${property}属性`);\n>                //TODO\n>                delete target[property];\n>            },\n>            has(target, property) {\n>                console.log(`你判断是否存在,调用has方法了`);\n>                //TODO\n>                return property in target;\n>            }\n>        });\n>        console.log('a' in newJson);\n>        delete newJson.a;\n>        console.log(newJson);\n>     </script>\n>     \n\n* * *\n\n> apply():拦截方法\n> \n>     <script >\n>        function fn() {\n>            return `我是函数`;\n>        }\n>     \n>        let newFn = new Proxy(fn, {\n>            apply(target, thisArg, argArray) {\n>                return `函数吗?`\n>            }\n>        });\n>        console.log(newFn());\n>     </script>\n>     \n\n* * *\n\n> Reflect.apply(调用的函数,this指向,参数数组);  \n> 利用apply进行拦截方法:\n> \n>     <script >\n>        function sum(a, b) {\n>            return a + b;\n>        }\n>     \n>        let newSum = new Proxy(sum, {\n>            apply(target, context, args) {\n>                // context:指向\n>                // console.log(target, context, args);\n>                // console.log(...arguments)\n>                // Reflect:反射\n>                return Reflect.apply(...arguments)**2;\n>            }\n>        })\n>        console.log(newSum(2, 3));\n>     </script>\n>     \n> \n> 还有:\n> \n>     <script >\n>        // console.log(Math.ceil(5.4));\n>     \n>        // let rel = Reflect.apply(Math.ceil, null, [9.8]);\n>        // console.log(rel);\n>     \n>        function show(...args) {\n>            console.log(this)\n>            console.log(args);\n>        }\n>     \n>        // show(1,2,3,4);\n>        // show.call('abc', 1, 2, 3, 4);\n>        // show.apply('abc', [1, 2, 3, 4]);\n>        Reflect.apply(show, 'aaaa', [1, 2, 3, 4]);\n>     </script>\n>     \n\n* * *\n\n> Reflect:反射\n> \n>     <script >\n>        // 之前的检测方法\n>        console.log('assign' in Object);\n>        // 以后的检测方法可能一直是:\n>        console.log(Reflect.has(Object, 'assign'));\n>     </script>\n>     \n> \n> 还有:\n> \n>     <script >\n>        let json = {a: 1, b: 2};\n>        /*delete json.a;//删除\n>        console.log(json);*/\n>        Reflect.deleteProperty(json, 'a');//删除\n>        console.log(json);\n>     </script>\n>     \n\n* * *\n\nObject.xxxx 语言内部的方法\n\nObject.defineProperty  \n  \n放到Reflect对象身上  \n  \n通过Reflect对象身上直接拿到语言内部东西",
        "states": "0",
        "description": "proxy:代理Proxy 用于修改某些操作的默认行为,等同于在语言层面做出修改，所以属于一种“元编程”(meta programming),即对编程语言进行编程Proxy 可以理解成,在目标对象之前架设一层“拦截”,外界对该对象的访问,都必须先通过这层拦截,因此提供了一种机制,可以对外界的访问进行过滤和改写.Proxy 这个词的原意是代理,用在这里表示由它来“代理”某些操作,可以译为“代理器”主要是扩展 / 增强 对象的一些功能比如说 Vue中的 Vue.key.Codes.ente.",
        "praise": "0",
        "view": "2",
        "audit": "1",
        "tag1": "note",
        "tag2": "es6",
        "tag3": "javascript",
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/110594369",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-10T09:01:50.000Z",
        "destroyTime": null
    },
    {
        "id": 133,
        "email": "2714351312@qq.com",
        "title": "CSS练习_无限滚动",
        "content": "之前写的一个练习,还算是一个demo吧,为一些初学者提供一个无限滚动的思路\n\n效果:\n\n*   图片会无限匀速滚动,由右到左\n*   鼠标停留图片时,滚动会暂停\n*   鼠标停留在图片上时,其他图片会变暗\n*   就这了,没得了\n\n效果图:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201203184827297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201203184846914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)  \n鼠标移上去时:\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201203185009437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n代码:\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>6_动画模块_无限滚动</title>\n        <style>\n            * {\n                margin: 0;\n                padding: 0;\n            }\n            ul {\n                width: 2000px;\n                height: 188px;\n                background: #000000;\n                border: 1px solid #000;\n                margin: 0 auto;\n                animation: move 10s linear 0s infinite normal;\n            }\n            ul:hover{\n             animation-play-state: paused;\n            }\n            ul:hover li{\n                opacity: 0.5;\n            }\n            ul li:hover{\n                opacity: 1;\n            }\n            @keyframes move {\n                from {\n                    margin-left: 0;\n                }\n                to {\n                    margin-left: -1200px;\n                }\n            }\n            ul li {\n                list-style: none;\n                width: 300px;\n                height: 188px;\n                border: 1px solid #000;\n                box-sizing: border-box;\n                float: left;\n            }\n            div {\n                width: 600px;\n                height: 188px;\n                border: 1px solid #000;\n                margin: 100px auto;\n                overflow: hidden;\n            }\n            img{\n                width: 90px;\n                height: 188px;\n            }\n        </style>\n    </head>\n    <body>\n    <div>\n        <ul>\n            <li><img src=\"pic/1.jpg\"></li>\n            <li><img src=\"pic/2.jpg\"></li>\n            <li><img src=\"pic/3.jpg\"></li>\n            <li><img src=\"pic/4.jpg\"></li>\n            <li><img src=\"pic/1.jpg\"></li>\n            <li><img src=\"pic/2.jpg\"></li>\n        </ul>\n    </div>\n    </body>\n    </html>\n    \n\n图片就自己整吧,整啥图片都差不多,比例和我的差不多就行",
        "states": "0",
        "description": "之前写的一个练习,还算是一个demo吧,为一些初学者提供一个无限滚动的思路效果:图片会无限匀速滚动,由右到左鼠标停留图片时,滚动会暂停鼠标停留在图片上时,其他图片会变暗就这了,没得了效果图:鼠标移上去时:代码:&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;title&gt;6_动画模块_无限滚动&lt;/title&gt;   ",
        "praise": "0",
        "view": "5",
        "audit": "1",
        "tag1": "css",
        "tag2": "demo",
        "tag3": "html",
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/110560250",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-07T08:03:54.000Z",
        "destroyTime": null
    },
    {
        "id": 134,
        "email": "2714351312@qq.com",
        "title": "CSS练习_云层效果",
        "content": "之前练习的一个网页,只利用css完成,算是一个小demo吧\n\n想要的效果:\n\n*   云层无限滚动\n*   背景天空会由白变黑再变白\n*   云层滚动有视差(速度不同)\n\n效果图:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201203184053653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201203184104371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201203184119470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)  \n代码:\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>5_动画模块_云层效果</title>\n        <style>\n            * {\n                margin: 0;\n                padding: 0;\n            }\n            ul {\n                height: 400px;\n                background-color: skyblue;\n                margin-top: 100px;\n                animation: change 5s linear 0s infinite alternate;\n                position: relative;\n                overflow: hidden;\n            }\n            ul li {\n                width: 400%;\n                height: 100%;\n                position: absolute;\n                left: 0;\n                top: 0;\n                list-style: none;\n            }\n            ul li:nth-child(1) {\n                background-image: url(\"pic/yun1.png\");\n                animation: one 30s linear 0s infinite alternate;\n            }\n            @keyframes one {\n                from{margin-left: 0px;\n                }\n                to{margin-left: -100%;\n                }\n            }\n            ul li:nth-child(2) {\n                background-image: url(\"pic/yun2.png\");\n                animation: two 30s linear 0s infinite alternate;\n            }\n            @keyframes two {\n                from {margin-left: 0px;\n                }\n                to {margin-left: -200%;\n                }\n            }\n            ul li:nth-child(3) {\n                background-image: url(\"pic/yun3.png\");\n                animation: three 30s linear 0s infinite alternate;\n            }\n            @keyframes three {\n                from {margin-left: 0px;\n                }\n                to {margin-left: -300%;\n                }\n            }\n            @keyframes change {\n                from {\n                    background-color: skyblue;\n                }\n                to {\n                    background-color: black;\n                }\n            }\n        </style>\n    </head>\n    <body>\n    <ul>\n        <li></li>\n        <li></li>\n        <li></li>\n    </ul>\n    </body>\n    </html>\n    \n    \n\nyun1.png,到yun3.png:  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201203184420649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201203184425376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201203184431127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)  \nps扣的,不咋滴",
        "states": "0",
        "description": "之前练习的一个网页,只利用css完成,算是一个小demo吧想要的效果:云层无限滚动背景天空会由白变黑再变白云层滚动有视差(速度不同)效果图:代码:&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;title&gt;5_动画模块_云层效果&lt;/title&gt;    &lt;style&gt;        * {       ",
        "praise": "0",
        "view": "8",
        "audit": "1",
        "tag1": "demo",
        "tag2": "css",
        "tag3": "html",
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/110559785",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-19T06:31:39.000Z",
        "destroyTime": null
    },
    {
        "id": 135,
        "email": "2714351312@qq.com",
        "title": "ES6_Set和WeakSet_note",
        "content": "[该笔记部分参考](https://www.jianshu.com/p/4efa7675834c)\n\n> > set数据结构: 本身是一种构造函数,用于生成Set数据结构\n\n    <script >\n        new Set([iterable])\n    </script>\n    \n\n> Set属性中有size\n\n> Set对立面的元素进行比较时,使用的算法叫做\"Same-value-zero equality\"，类似于精确相等运算符\"===\"，主要的区别是NaN等于自身,而精确相等运算符认为NaN不等于自身\n> \n> > 类似于数组,但是里面不能有重复值,如:\n> \n>     <script >\n>        let arr = ['a', 'b', 'c', 'd', 'a'];\n>        console.log(arr);\n>        console.log(\"split---\");\n>        // set数据结构不能重复\n>        let setArr = new Set(['a', 'b', 'c', 'a', 'b']);\n>        console.log(setArr);\n>     </script>\n>     \n\n> set创建:\n> \n>     script\n>        let setArr = new Set();\n>     \n\n> set()可以使用 add() delete() has() 有size属性  \n> add()方法可以连续使用(使用add方法是添加元素后创建set并返回一个新的,delete()不可以) 如:\n> \n>     <script >\n>        let setArr = new Set(['a', 'b']);\n>        // add()其实是添加完成之后将其返回,可以连续使用add()\n>        setArr.add('sdf')\n>        setArr.add('sdghkn')\n>        console.log(setArr);\n>        console.log(\"split---\");\n>        setArr.delete('a')\n>        console.log(setArr);\n>        console.log(\"split---\");\n>        console.log(setArr.has('a'));\n>        console.log(setArr.has('b'));\n>        console.log(\"split---\");\n>        // size 个数\n>        console.log(setArr.size);\n>        console.log(\"split===\");\n>        console.log(setArr);\n>        setArr.delete('sdf');\n>        console.log(setArr);\n>     </script>\n>     \n\n> 数组利用Set去除重复数组:\n> \n>     <script >\n>        let arr = [1, 2, 3, 4, 3, 4, 1, 5]\n>        console.log([...new Set(arr)])      // [1, 2, 3, 4, 5]\n>     </script>\n>     \n\n> 清除set中的所有元素:\n> \n>     <script >\n>        let setArr = new Set();\n>        setArr.add('a')\n>        setArr.add('b')\n>        setArr.add('c')\n>        console.log(setArr);\n>        console.log('split---');\n>        // 清除所有set中的数组\n>        setArr.clear();\n>        console.log(setArr);\n>     </script>\n>     \n\n* * *\n\n*   Set结构可以利用 Array.from 或者 扩展运算符 转化为数组\n\n> set中添加数组会有key,value属性,可以分别使用或者一起使用,如:\n> \n>     <script >\n>        let setArr = new Set(['a', 'b', 'c', 'd']);\n>        // 不加keys后者value的话,默认返回的是value\n>        for (let item of setArr.keys()) {\n>            console.log(item);\n>        }\n>        console.log('split---');\n>        for (let item of setArr.values()) {\n>            console.log(item);\n>        }\n>        console.log('split---');\n>        for (let item of setArr.entries()) {\n>            console.log(item);\n>        }\n>        console.log('split---');\n>        for (let [key, value] of setArr.entries()) {\n>            console.log(key, value);\n>        }\n>        console.log('split------');\n>     \n>        setArr.forEach((k, v) => {\n>            console.log(k, v);\n>        })\n>     </script>\n>     \n\n> set的应用:可以使用…将其转为数组再进行map filter操作:\n> \n>     <script >\n>        let arr = [1, 2, 3, 4, 6, 6, 5, 5, 98, 54, 45, 4, 4, 4, 4, 4,];\n>        // let set = new Set(arr);\n>        //去重，然后利用 ... 进行转为数组\n>        let newArray = [...new Set(arr)]\n>        console.log(newArray);\n>        /*\n>        使用 [] 将set数据结构变为数组\n>        可以使用 map filter来进行循环\n>        * */\n>     </script>\n>     \n> \n> set使用filter进行逻辑处理的例子:\n> \n>     <script >\n>        let set = new Set([1, 2, 3, 6, 9, 10]);\n>        // let set2 = new Set();\n>        // for (let value of set.values()) {\n>        //     set2.add(value * 2)\n>        // }\n>        // set = new Set([...set].map(val => val * 2));\n>        set = new Set([...set].filter(val => val % 2 === 0));\n>        console.log(set);\n>     </script>\n>     \n\n> 如果要重复在set中添加元素可以(此时仅仅是添加的对象不同):\n> \n>     <script >\n>        let set = new Set();\n>        let json = {\n>            a: 1, b: 2\n>        };\n>        let json2 = {\n>            a: 1, b: 2\n>        };\n>        set.add(json);\n>        set.add(json2);\n>     \n>        // console.log(set);\n>        set.forEach(item => {\n>            // console.log(item);\n>            console.log(item.a);\n>        })\n>     </script>\n>     \n\n*   遍历:\n\n> keys()： 返回一个包含集合中所有键的迭代器  \n>   \n> values()：返回一个包含集合中所有值的迭代器  \n>   \n> entries(): 返回一个包含Set对象中所有元素  \n>   \n> forEach(callback, thisArg): 用于对集合成员执行callbackFn操作，如果提供了thisArg参数，回调中的this会是这个参数，回调中的this会是这个参数，没有返回值  \n\n> Set()和WeakSet()\n\n*   两者区别:\n\n> WeakSet 只能储存对象引用，不能存放值，而 Set 对象都可以  \n>   \n> WeakSet 对象中储存的对象值都是被弱引用的，则这个对象将会被垃圾回收掉（不考虑该对象还存放于 WeakSet 中），所以 WeakSet 对象里有多少个成员元素，取决于垃圾回收机制有没有运行，运行前后成员个数可能不一致，遍历结束之后，有的成员可能被垃圾回收了，WeakSet 对象是无法被遍历的（ES6 规定 WeakSet 不可遍历），也没有办法拿到它包含的所有元素  \n> \n> *   属性：  \n>       \n>     constructor: 构造函数，任何一个具有 Iterable 接口的对象，都可以作为参数  \n>     \n> *   方法：  \n>       \n>     add(value): 在 WeakSet 对象中添加一个元素value  \n>       \n>     has(value): 判断WeakSet 对象中是否包含value  \n>       \n>     delete(value): 删除元素value  \n>     \n\n> WeakSet()创建:\n> \n>     <script >\n>        let ws = new WeakSet()\n>     </script>\n>",
        "states": "0",
        "description": "该笔记部分参考set数据结构: 本身是一种构造函数,用于生成Set数据结构&lt;script &gt;    new Set([iterable])&lt;/script&gt;Set属性中有sizeSet对立面的元素进行比较时,使用的算法叫做\"Same-value-zero equality\"，类似于精确相等运算符\"===\"，主要的区别是NaN等于自身,而精确相等运算符认为NaN不等于自身类似于数组,但是里面不能有重复值,如:&lt;script &gt;   le",
        "praise": "0",
        "view": "12",
        "audit": "1",
        "tag1": "es6",
        "tag2": "javascript",
        "tag3": "note",
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/110506008",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-07T08:02:46.000Z",
        "destroyTime": null
    },
    {
        "id": 136,
        "email": "2714351312@qq.com",
        "title": "ES6_symbol和generator_note",
        "content": "ES6新增数据类型:  \n  \nSymbol 使用情况一般\n\n用 typeof 检测出来的类型是: symbol\n\n> 注意:\n> \n> > 1.Symbol不能new出来  \n> > 2.Symbol()返回的是一个唯一的值  \n> > \n> > > 使用可以做一个key,定义一些唯一或者私有的一些东西  \n> > > 3.symbol 是一个单独的数据类型,就叫symbol,属于基本数据类型  \n> > > 4.如果symbol作为key,用 for in 循环,出不来\n\n> Symbol的定义和使用\n\n    <script >\n        let syml = Symbol('aaa');\n        console.log(syml);\n        console.log(typeof syml);\n    </script>\n    \n\n> Symbol可用于json中:\n\n    <script >\n        let symbol = Symbol('kirin');\n        let json = {\n            a: 'apple',\n            b: 'banana',\n            [symbol]: 'aaa'\n        };\n        console.log(json['a']);\n        console.log(json[symbol]);\n        console.log(\"split---\");\n    \n        for (let item in json) {\n            console.log(item);\n        }\n    </script>\n    \n\n* * *\n\n箭头函数:\n\n    <script >\n        ()=>{\n                }\n    </script>\n    \n\ngenerator 函数:生成器\n\n是为了解决异步深度嵌套的问题\n\ngenerator函数语法:\n\n    <script >\n    function * show() {\n      //只能配合generator函数来使用\n            yield \n    }\n    //如:\n    function* gen() {\n            yield 'welcome';\n            yield 'to';\n            yield 'school';+\n        }\n    </script>\n    \n\n*   调用:\n\n>     <script >\n>        function* gen() {\n>            yield 'welcome';\n>            yield 'to';\n>            return 'school';-\n>        }\n>     \n>        let g1 = gen();\n>        console.log(g1.next()); // {value: \"welcome\", done: false} value:值 , done:后面是否为空\n>        console.log(g1.next());\n>        console.log(g1.next());// 此时返回的是最后一个,done:true\n>     </script>\n>     \n> \n> 上述调用为手动调用\n\n*   for…of…自动便利generator,但是不会遍历到generator,如:\n\n>     <script >\n>        function* gen() {\n>            yield 'welcome';\n>            yield 'to';\n>            return 'school';\n>        }\n>     \n>        let g1 = gen();\n>        for (let val of g1) {\n>            // 此时不会输出return的东西\n>            console.log(val);\n>        }\n>     </script>\n>     \n\n还可以使用解构赋值(它解构并不会解构return的东西),如:\n\n    <script >\n        function* gen() {\n            yield 'welcome';\n            yield 'to';\n            return 'school';\n        }\n    \n        let [a, b] = gen();\n        console.log(a, b);\n    </script>\n    \n\n或者配合解构:\n\n    <script >\n        function* gen() {\n            yield 'welcome';\n            yield 'to';\n            yield '51.cnm';\n            return 'school';\n        }\n    \n        let [a, ...b] = gen();\n        console.log(a, b);\n    </script>\n    \n\n或者使用扩展运算符:\n\n    <script >\n        function* gen() {\n            yield 'welcome';\n            yield 'to';\n            yield '51.cnm';\n            return 'school';\n        }\n        console.log(...gen());\n    </script>\n    \n\n也可以配合Array.from()来使用:\n\n    <script >\n        function* gen() {\n            yield 'welcome';\n            yield 'to';\n            yield '51.cnm';\n            return 'school';\n        }\n    \n        console.log(Array.from(gen()));\n    </script>\n    \n\n* * *\n\n异步:不连续,上一个操作没有执行完,下一个操作照样开始  \n  \n同步:连续执行,上一个操作没有执行完,下一个没法开始  \n\n> 关于异步的解决方案:  \n> \n> > 回调函数  \n> >   \n> > 事件监听  \n> >   \n> > 发布/订阅  \n> >   \n> > Promise对象  \n\n* * *\n\n    <script >\n        async function fn() {\n          let result=await xxx; //表示后面结果需要等待\n        }\n    </script>\n    \n\n补充:async特点:  \n  \n1.await只能放到async函数  \n  \n2.相比generator语义化更强了  \n  \n3.await后面可以是promise对象,也可以是数字,字符串等等  \n  \n4.async返回的是promise对象  \n  \n5.只要await语句后面promise状态变成一个reject时,整个async函数就会中断执行,如:  \n\n>     <script >\n>        async function fn() {\n>          throw new Error('Error出错了');\n>        }\n>        fn().then(res=>{\n>        \n>        console.log(res)},err=>{\n>        \n>        console.log(err);})\n>     </script>\n>     \n> \n> async函数中解决抛错:影响后续代码:使用try{}catch(){}  \n> 推荐在任何有await的地方,都用try,catch",
        "states": "0",
        "description": "ES6新增数据类型:Symbol 使用情况一般用 typeof 检测出来的类型是: symbol注意:1.Symbol不能new出来2.Symbol()返回的是一个唯一的值使用可以做一个key,定义一些唯一或者私有的一些东西3.symbol 是一个单独的数据类型,就叫symbol,属于基本数据类型4.如果symbol作为key,用 for in 循环,出不来Symbol的定义和使用&lt;script &gt;    let syml = Symbol('aaa');",
        "praise": "0",
        "view": "6",
        "audit": "1",
        "tag1": "note",
        "tag2": "es6",
        "tag3": "javascript",
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/110456646",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-05T17:40:29.000Z",
        "destroyTime": null
    },
    {
        "id": 137,
        "email": "2714351312@qq.com",
        "title": "ES6_类_note",
        "content": "程序中的类:\n\n*   注意:  \n    \n\n> 1.es6中class没有哦提升功能,在es5中,函数模拟可以,默认函数提升\n\n> 2.this\n> \n> > 矫正this:  \n> >   \n> > 1.fn.call(this指向谁,args1,args2…)  \n> >   \n> > 2.fn.apply(this指向,\\[args1,args2…\\])  \n> >   \n> > 3.fn.bind()  \n\nclass中取值函数(getter),存执函数(setter)\n\n静态方法:类身上的方法,如:\n\n    <script >\n        class Person {\n            constructor() {\n            }\n            showName() {\n                return '这是showName方法';\n            }\n            // 定义静态方法\n            static aaa() {\n                return '这是静态方法';\n            }\n        }\n        let p1 = new Person();\n        console.log(p1.showName());\n        // 调用静态方法\n        console.log(Person.aaa());\n    </script>\n    </script>\n    \n\n* * *\n\n父类\n\n子类\n\n继承:\n\n之前使用继承(很累):\n\n    <script >\n        //  父类\n        function Person(name) {\n            this.name = name;\n        }\n    \n        Person.prototype.showName = function () {\n            return `名字是:${this.name}`;\n        };\n    \n        // 子类\n        function Student(name, skill) {\n            Person.call(this, name); // 继承属性\n            this.skill = skill;\n        }\n    \n        Student.prototype = new Person(); // 继承方法\n    \n        // 调用\n        let stu1 = new Student(\"kirin\", \"逃学\");\n        console.log(stu1.showName());\n    </script>\n    \n\n> 现在:\n\n    <script >\n        class Person {\n            constructor(name) {\n                this.name = name;\n            }\n    \n            showName() {\n                console.log(\"父类的showName\");\n                return `名字为: ${this.name}`;\n            }\n        }\n    \n        class Student extends Person {\n            // 子类继承父类必须在其中写 super()\n            // constructor:构造函数\n            /*constructor(args) {\n                super(args);\n            }*/\n            constructor(name, skill) {\n                super(name);\n                this.skill = skill;\n            }\n            // 如果子类中有覆盖了父类的方法,则子类方法中必须写super()\n            showName() {\n                super.showName(); // 父类的方法执行,后面子类的代码还会继续执行\n                console.log(\"子类里的showName\");\n            }\n    \n            showSkill() {\n                return `技能为${this.skill}`;\n            }\n        }\n    \n        let stu1 = new Student(\"kirin\", \"逃学\");\n        // console.log(stu1.showName());\n        // console.log(stu1.showSkill());\n        stu1.showName();\n    </script>",
        "states": "0",
        "description": "程序中的类:注意:1.es6中class没有哦提升功能,在es5中,函数模拟可以,默认函数提升2.this矫正this:1.fn.call(this指向谁,args1,args2…)2.fn.apply(this指向,[args1,args2…])3.fn.bind()class中取值函数(getter),存执函数(setter)静态方法:类身上的方法,如:&lt;script &gt;    class Person {        constructor() {",
        "praise": "2",
        "view": "12",
        "audit": "1",
        "tag1": "es6",
        "tag2": "javascript",
        "tag3": "note",
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/110456593",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-27T03:01:59.000Z",
        "destroyTime": null
    },
    {
        "id": 138,
        "email": "2714351312@qq.com",
        "title": "ES6_模块化_note",
        "content": "#### 模块化\n\n> js不支持模块化  \n> 在es6之前,社区制定了一套规范:\n\n规范\n\n作用\n\nCommonjs\n\n主要用于服务端 nodejs require(‘http’)\n\nAMD\n\nrequireJs,culJs\n\nCMD\n\nseaJs\n\n> es出来,统一服务端和客户端模块规范  \n>   \n> 注意:使用模块化需要放在服务器环境\n\n#### 如何定义模块:\n\n> \n>     // 此处可以是 let / const\n>     export const a=12;\n>     \n\n> 或者\n> \n>     <script >\n>     // 使用 export default 出来的东西,则不需要使用 {}\n>     export default 12;\n>     export const e = 13;\n>     export const b = 14;\n>     export const c = 1;\n>     </script>\n>     \n\n> 或者\n> \n>     <script >\n>     let a = 12;\n>     let b = 13;\n>     export {a, b};\n>     </script>\n>     \n\n* * *\n\n> *   如何使用模块:\n> *   注意:只要是 export 导出的东西,在使用时都要使用 {}\n> *   如果是使用 export default 出来的东西,则不需要\n\n> *   import优点:  \n>     \n> *   无论一个库导入多少次,只会执行一次\n> *   import可以是绝对路径或者是相对路径\n> *   import ‘./model.1.js’; 如果这样用,相当于引入文件\n> *   有提升效果,import会自动提升到顶部,首先执行\n> *   导入的模块,如果里面js的内容改了,外面的也会跟着改\n\n*   在HTML中写入:\n\n>        <script type=\"module\">\n>            import 绝对路径 / 相对路径    \n>            // 或者\n>            import {aaa, bbb, ccc} from './module/2.js';\n>            // 或者\n>            import * as modTwo from './module/2.js';\n>        </script>\n>     \n\n*   在导入时起别名:\n\n>     <script >\n>         import {aaa, bbb, ccc} from './module/2.js';\n>         console.log(aaa);\n>         console.log(bbb);\n>         console.log(ccc);\n>         console.log(\"split---\");\n>         // 也可以在导入时起别名:\n>         import {aaa as a, bbb as b, ccc as c} from './module/2.js';\n>         console.log(a);\n>         console.log(b);\n>         console.log(c);\n>     </script>\n>     \n\n*   为模块起别名:\n\n>     <script >\n>     import * as modTwo from './module/2.js';\n>        console.log(modTwo);\n>     </script>\n>     \n\n*   一起使用 export default 导出东西的时候\n\n>     <scripot>\n>        // import a from './module/3.js';\n>        //要使用 export default 和 export导出的东西的时候:\n>        import a, {e, b, c} from './module/3.js';\n>        console.log(a);\n>        console.log(e);\n>        console.log(b);\n>        console.log(c);\n>     </scripot>\n>     \n\n*   可以在导入的js源文件中再导入另一个js:  \n      \n    html文件:\n\n>     <script type=\"module\">\n>        import mod, {show, sum, e, f} from './module/4.js';\n>     \n>        let p1 = new mod.Person('张三', 18);\n>        console.log(p1.showName());\n>        show();\n>        sum();\n>        console.log('split---');\n>        console.log(e, f);\n>     </script>\n>     \n\n4.js文件:\n\n>     import {e, f} from './5.js';\n>     \n>     console.log('split---');\n>     \n>     const a = 12;\n>     const b = 15;\n>     \n>     export {\n>        a,\n>        b,\n>        sum,\n>        show,\n>        e,\n>        f\n>     }\n>     const sum = () => {\n>        console.log(a + b);\n>        return a + b;\n>     }\n>     const show = () => {\n>        console.log('执行了show');\n>        return 1;\n>     }\n>     \n>     class Person {\n>        constructor(name, age) {\n>            this.name = name;\n>            this.age = age;\n>        }\n>     \n>        showName() {\n>            return `我的名字是${this.name}`;\n>        }\n>     }\n>     \n>     export default {\n>        Person\n>     }\n>     \n\n5.js文件:\n\n>     export const e = 101;\n>     export const f = 4;\n>     \n\n*   import有提升效果:\n\n>     <script type=\"module\">\n>        // 验证提升效果\n>        console.log('提升了吗');\n>        import mod, {show, sum, e, f} from './module/4.js';\n>     \n>        console.log(e);\n>     </script>\n>     \n\n*   导入的模块,如果里面js的内容改了,外面的也会跟着改,不像common规范如:  \n      \n    html文件:\n\n>     <script type=\"module\">\n>        import {a, b} from './module/6.js';\n>        // 导入的模块,如果里面js的内容改了,外面的也会跟着改\n>        console.log(a, b);\n>        setTimeout(() => {\n>            console.log(a, b);\n>        }, 3000);\n>     </script>\n>     \n\n6.js:\n\n>     let a = 12;\n>     let b = 13;\n>     \n>     setTimeout(() => {\n>        a = 11111;\n>     }, 2000);\n>     \n>     export {a, b};\n>     \n\n*   import可以动态引入:\n\n> import()类似于node里面的require,可以动态引入  \n>   \n> 默认import语法不能写入if等语句里  \n> 可以使用按需加载的方式来加载:  \n> \n>     <script >\n>        import ('https://code.jquery.com/jquery-1.12.4.js').then(res => {\n>                $(function () {\n>                    $('body').css({\n>                        background: 'red'\n>                    })\n>                })\n>            })\n>     </script>\n>     \n> \n> 此种方法的优点:\n> \n> *   按需加载\n> *   可以写在if中\n> *   路径也可以是动态的\n\n> import() 的返回值是一个promise对象\n\n* * *\n\n*   模块化的动态引入:\n\n> 不能在if中直接引入 import 语法,  \n>   \n> import() 的返回值是一个promise对象  \n>   \n> 可以使用 import() 来引入,如:\n> \n>     <script >\n>        // 也可以引入绝对地址\n>        import('./module/1.js').then(res => {\n>            console.log(res.a+res.b);\n>        });\n>     </script>\n>     \n\n> 可以进行动态加载,如:\n> \n>     <script >\n>        let sign = 1;\n>        function config() {\n>            switch (sign) {\n>                case 1:\n>                    return './module/1.js';\n>                    break;\n>                case 2:\n>                    return './module/2.js';\n>                    break;\n>            }\n>        }\n>        import(config(1)).then(res => {\n>        });\n>     </script>\n>     \n\n> 也可以使用promise.all(),如:\n\n    <script >\n        Promise.all([\n            import('./module/1.js'),\n            import('./module/2.js'),\n    \n        ]).then(([mod1,mod2])=>{\n            console.log(mod1);\n            console.log(mod2);\n        })\n    </script>",
        "states": "0",
        "description": "####模块化js不支持模块化在es6之前,社区制定了一套规范:规范作用Commonjs主要用于服务端 nodejs require(‘http’)AMDrequireJs,culJsCMDseaJses出来,统一服务端和客户端模块规范注意:使用模块化需要放在服务器环境如何定义模块:// 此处可以是 let / constexport const a=12;或者&lt;script &gt;// 使用 export d.",
        "praise": "1",
        "view": "18",
        "audit": "1",
        "tag1": "es6",
        "tag2": "javascript",
        "tag3": "note",
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/110456566",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-25T05:08:16.000Z",
        "destroyTime": null
    },
    {
        "id": 139,
        "email": "2714351312@qq.com",
        "title": "ES6_对象简洁语法_note",
        "content": "#### 对象简洁语法,如:\n    \n\n    <script >\n        let name = 'kirin';\n            let age = 18;\n            let json = {\n                // 前面是简写\n                name,// name:name,\n                age,// age:age,\n            }\n            console.log(json);\n    </script>\n    \n\n#### 方法简写:\n\n    <script >\n        let name = 'kirin';\n            let age = 18;\n            let json = {\n                name,// name:name,\n                age,// age:age,\n        \n                /*showA: function () {\n                    return this.name;\n                },*/\n                //等价于上面的写法\n                showA() {\n                    return this.name;\n                },\n            }\n    </script>\n    \n\n#### 简洁语法中不要写箭头函数:\n\n    <script >\n        // 千万不要在里面用箭头函数,因为已经使用了简写,而且使用箭头函数的话,箭头函数内的对象并没有指定\n        let name = 'kirin';\n        let age = 18;\n        let json = {\n            name,// name:name,\n            age,// age:age,\n            showA: () => {\n                return this.name;\n            }\n        }\n        console.log(json.showA());\n    </script>\n    \n\n#### 对象简洁语法:\n\n    <script >\n        let x = 10;\n            let y = 20;\n            function show({x, y}) {\n                console.log(x, y);\n            }\n            show({x: 10, y: 20})\n    </script>\n    \n\n####",
        "states": "0",
        "description": "对象简洁语法,如:&lt;script &gt;    let name = 'kirin';        let age = 18;        let json = {            // 前面是简写            name,// name:name,            age,// age:age,        }        console.log(json);&lt;/script&gt;方法简写:&lt;script &gt;   ..",
        "praise": "6",
        "view": "29",
        "audit": "1",
        "tag1": "es6",
        "tag2": "javascript",
        "tag3": "note",
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/110456521",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-05T17:45:36.000Z",
        "destroyTime": null
    },
    {
        "id": 140,
        "email": "2714351312@qq.com",
        "title": "ES6_有关数组的函数_note",
        "content": "#### 循环:\n\n> es5新增的一些东西:\n> \n> > 循环:  \n> >   \n> > 1.for  \n> >   \n> > for(let i=0;i<arr.length;i++){}  \n> >   \n> > 2.while  \n> >   \n> > while  \n> \n> arr.forEach()  \n>   \n> arr.map()  \n>   \n> arr.filter()  \n>   \n> arr.some()  \n>   \n> arr.every()  \n>   \n> arr.reduce()  \n>   \n> arr.reduceRight()  \n\n* * *\n\n*   #### forEach()函数:\n    \n\n> //forEach()是用来代替for的  \n>   \n> // 以下几个使用方法一样  \n>   \n> // arr.forEach()  \n>   \n> // arr.map()  \n>   \n> // arr.filter()  \n>   \n> // arr.some()  \n>   \n> // arr.every()  \n> \n> //接收两个参数:  \n>   \n> //forEach(回调函数,this)  \n>   \n> // 此时this是指定forEach()中的this,例如:  \n\n    <script >\n    let arr = ['apple', 'banana', 'orange', 'tomato'];\n         for (let i = 0; i < arr.length; i++) {\n             console.log(arr[i]);\n         }\n         console.log(\"------------\");\n         //此处的forEach()接收三个参数:\n         //val:数组当前遍历的元素,默认从左往右依次获取数组元素\n         //index:数组当前元素的索引,第一个元素索引为0,依次类推\n         //arr:当前遍历的数组\n         //this:回调函数中this指向\n         arr.forEach(function (val, index, arr) {\n             console.log(val, index, arr);\n         },this);\n     </script>\n    \n\n> forEach()中可以指定this对象:  \n> 如:\n\n    <script >\n        let arr = ['apple', 'banana', 'orange', 'tomato'];\n            //此时没有指定this:\n            {\n                arr.forEach(function (val, index, arr) {\n                    console.log(this, val, index, arr);\n                });\n            }\n            ///指定this后输出\n            {\n                arr.forEach(function (val, index, arr) {\n                    console.log(this, val, index, arr);\n                }, 123);\n            }\n    </script>\n    \n\n> 使用forEach()循环输出数组,如:\n\n    <script >\n        let arr = ['apple', 'banana', 'orange', 'tomato'];\n         //要依次输出数组中全部对象时\n            {\n                arr.forEach(function (val, index, arr) {\n                    console.log(arr[index]);\n                })\n            }\n    </script>\n    \n\n> 在forEach()中使用箭头函数无法指定this对象,如:\n\n    <script >\n        let arr = ['apple', 'banana', 'orange', 'tomato'];\n        //使用箭头函数时:\n            {\n                arr.forEach((val, index, arr) => {\n        \n                    console.log(arr[index]);\n                });\n            }\n            console.log(\"-----------------\");\n             //但是此时在箭头函数中输出this时,指定的是此时的window对象(此时无法指定this):\n             {\n                 arr.forEach((val, index, arr) => {\n                     console.log(this, val, index, arr);\n                 },123)\n             }\n    </script>\n    \n\n* * *\n\n*   #### map()函数:\n    \n\n> arr.map()非常有用,用以做数据 映射,正常情况下,需要配合return,如:  \n\n    <script >\n        let arr=[\n                {title:'aaa',read:100,hot:true},\n                {title:'bbb',read:100,hot:true},\n                {title:'ccc',read:100,hot:true},\n                {title:'ddd',read:100,hot:true}\n            ]\n            let newArr = arr.map((item, index, arr) => {\n                console.log(item, index, arr);\n                return 1;\n            })\n            console.log(newArr);\n    </script>\n    \n\n> 如果没有return,那么功能相当于forEach()  \n>   \n> 注意:_使用map()了,就一定要用return,要不然还不如用forEach()_  \n\n> map()可以用来_重新整理数据结构_,如:  \n\n    <script >\n        let arr = [\n                {title: 'aaa', read: 100, hot: true},\n                {title: 'bbb', read: 100, hot: true},\n                {title: 'ccc', read: 100, hot: true},\n                {title: 'ddd', read: 100, hot: true}\n            ]\n            let newArr = arr.map((item, index, arr) => {\n                let json = {}\n                json.t = `^_^{item.title}----------`;\n                json.r = item.read + 200;\n                json.hot = item.hot == true && \"真棒!!!\";\n                return json;\n            });\n            console.log(newArr);\n    </script>\n    \n\n*   #### filter()函数:\n    \n\n> 过滤,过滤掉一些不合格的元素,如果回调函数返回true,就留下来,如:\n\n    <script >\n        let arr = [\n                {title: 'aaa', read: 100, hot: true},\n                {title: 'bbb', read: 100, hot: false},\n                {title: 'ccc', read: 100, hot: true},\n                {title: 'ddd', read: 100, hot: true}\n            ]\n            let newArr = arr.filter((item, index, arr) => {\n                // return item.hot == true;\n                return item.hot;\n            })\n            console.log(newArr);\n    </script>\n    \n\n* * *\n\n*   #### some()函数:\n    \n\n> 类似查找,数组里面某一个元素符合条件就返回true,如:\n\n    <script >\n        let arr = ['apple', 'banana', 'orange'];\n            let b = arr.some((val, index, arr) => {\n                return val == 'banana';\n            })\n            console.log(b);\n    </script>\n    \n\n*   关于some()的应用:\n\n    <script >\n        {\n                // 实现查找某一元素是否属于该数组\n                let arr = ['apple', 'banana', 'orange'];\n        \n                function findInArray(arr, item) {\n                    return arr.some((val, index, arr) => {\n                        return val == item;\n                    });\n                }\n        \n                console.log(findInArray(arr, 'orange'));\n            }\n    </script>\n    \n\n*   #### every()函数:\n    \n\n> 数组里面所有的元素符合条件才返回true,如:\n\n    <script >\n        let arr = [1, 3, 5, 7, 9]\n            var b = arr.every((val, index, arr) => {\n                return val % 2 == 1;\n            });\n            console.log(b);\n    </script>\n    \n\n*   #### reduce()函数:\n    \n\n> 用于求数组的和 / 阶乘,并接收四个参数\n\n    <script >\n    // 求和:\n        let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n            /*\n            prev:前一个元素\n            cur:当前循环的元素\n            index:当前循环索引\n            arr:整个循环的数组\n            * */\n            let res = arr.reduce((prev, cur, index, arr) => {\n                return prev + cur;\n            })\n            console.log(res);\n    </script>\n    \n\n    <script >\n    // 求阶乘\n        let arr = [2, 2, 3];\n            let res = arr.reduce((prev, cur, index, arr) => {\n                //Math.pow(a,b) ,a的b次方\n                // return Math.pow(prev, cur);\n                // 或者:\n                return prev ** cur;\n            });\n            console.log(res);\n    </script>\n    \n\n*   #### reduceRight()函数:\n    \n\n> 就是reduce从右到左开始的序列,如:\n\n    <script >\n        let arr = [2, 2, 3];\n            let res = arr.reduceRight((prev, cur, index, arr) => {\n                return prev ** cur;\n            });\n            console.log(res);\n    </script>\n    \n\n*   #### for…of…循环:\n    \n\n> for…of…中,数组多了几个对象:  \n>   \n> arr.keys() 数组下标  \n>   \n> arr.entries() 数组某一项  \n\n    <script >\n        \n            let arr = ['apple', 'banana', 'orange']\n            for (let val of arr) {\n                console.log(val);\n            }\n            console.log(\"--------\");\n            // 循环索引:\n            for (let index of arr.keys()) {\n                console.log(index);\n            }\n            console.log(\"--------\");\n            // 循环值和index\n            for (let item of arr.entries()) {\n                console.log(item);\n            }\n            console.log(\"或者\");\n            //或者:\n            for ([key, value] of arr.entries()) {\n                console.log([key, value]);\n            }\n    </script>\n    \n\n* * *\n\n补充:\n\n*   ES2017新增一个运算符: \\*\\* 幂  \n    如: 2\\*\\*3 相当于 Math.pow(2,3)\n\n* * *\n\n数组新增的东西:\n\n#### Array.from():\n\n> 作用:把类数组(获取的一组元素,arguments…)对象转成数组,如:\n\n        <body>\n        <script>\n            window.onload = function () {\n                let aLi = document.querySelectorAll(\"ul li\");\n                //ES5之前使用:\n                // let arrLi = [].slice.call(aLi);\n                // 快速转为数组,方便操作\n                let arrLi = Array.from(aLi);\n                arrLi.pop();\n                arrLi.push('items');\n                console.log(arrLi);\n            }\n        </script>\n        <ul>\n            <li>01</li>\n            <li>02</li>\n            <li>03</li>\n            <li>04</li>\n        </ul>\n        </body>\n    \n\n> 将类数组转为数组,如:  \n> 一般具备length这个属性就靠谱\n\n        <script >\n            // 不使用Array.from(),并且此时不是数组,无法使用push等:\n            function show() {\n                console.log(arguments);\n            }\n        show(1,2,3,4,5)\n        </script>\n    \n\n    <script>\n        // 使用Array.from(),此时是数组,可以使用push:\n        function show() {\n            // console.log(arguments);\n            let arr = Array.from(arguments);\n            arr.push('6')\n            console.log(arr);\n        }\n        show(1, 2, 3, 4, 5)\n    </script>\n    \n\n* * *\n\n*   #### fill()函数:\n    \n\n> arr.fill() 用以填充,  \n>   \n> 参数: arr.fill(填充的东西,开始的位置,结束的位置),如:\n\n    <script >\n        let arr = new Array(10);\n            arr.fill(\"默认值\",1,3)\n            console.log(arr);\n    </script>\n    \n\n* * *\n\n*   #### includes()函数:\n    \n\n> 为es2016新增\n\n    <script >\n        let arr=['apple','banana','orange','peach']\n            console.log(arr.includes('orange'));\n    </script>\n    \n\n* * *\n\n*   #### Object.is()函数与 == 和 ===:\n    \n\n> Object.is():比较两个东西是否相等\n\n    <script >\n        // console.log(NaN == NaN);\n        // console.log(Number.isNaN(NaN));\n        let b = Object.is(NaN, NaN);\n        console.log(b);\n    </script>\n    \n\n*   1.  \\== ：等于，两边值类型不同的时候，先进行类型转换，再比较；\n*   2.  \\=== ：严格等于，只有当类型和值都相等时，才相等；\n*   3.  Object.is() ：与 === 的作用基本一样，但有些许不同。\n*   #### 对于严格相等，有以下规则，如果 x === y，那么：\n    \n\na、如果x的类型和y的类型不一样，返回false；\n\nb、如果x的类型是数字，那么：\n\n(1)：如果x是NaN，返回false；\n\n(2)：如果y是NaN，返回false；\n\n(3)：如果x和y是同一个数字值，返回true；\n\n(4)：如果x是+0，y是-0，返回true；\n\n(5)：如果x是-0，y是+0，返回true；\n\n(6)：其余返回false。\n\nc、如果x和y的类型都为undefined或者null，返回true；\n\nd、如果x和y的类型都为字符串类型，那么如果x和y是完全相同的字符编码序列，返回true，否则返回false；\n\ne、如果x和y的类型都为布尔类型，那么如果x和y同为true或者false，返回true，否则返回false；\n\nf、如果x和y是同一个对象值，返回true，否则返回false\n\n*   #### \\=== 和 Object.is() 的区别\n    \n\nObject.is() 的行为与 === 基本一致，但有两处不同：  \n  \n　　a、+0 不等于 -0；  \n  \n　　b、NaN 等于自身  \n\n**详细的可以对照下表**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201201230404545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9zdG9uZV9rYWk=,size_16,color_FFFFFF,t_70)\n\n[该表来自于](https://www.cnblogs.com/zzh0318/p/12046530.html)",
        "states": "0",
        "description": "循环:es5新增的一些东西:循环:1.forfor(let i=0;i&lt;arr.length;i++){}2.whilewhilearr.forEach()arr.map()arr.filter()arr.some()arr.every()arr.reduce()arr.reduceRight()forEach()函数://forEach()是用来代替for的// 以下几个使用方法一样// arr.forEach()// arr.map()//",
        "praise": "1",
        "view": "28",
        "audit": "1",
        "tag1": "es6",
        "tag2": "javascript",
        "tag3": "note",
        "source": null,
        "url": "https://blog.csdn.net/ice_stone_kai/article/details/110456464",
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": "1",
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-06T09:27:54.000Z",
        "destroyTime": null
    },
    {
        "id": 171,
        "email": "2714351312@qq.com",
        "title": "test,这是一个很棒很棒的标题!!!!!!!!!!!!!!!!!!!",
        "content": ">　哦吼吼吼吼\n\n渲染一下试一下咯\n\n> jinitaimei\n\n> 只因你太美\n\n##### 你干嘛!\n\n烤面筋!!!!!!!!!!\n\n",
        "states": "1",
        "description": "山本我日你先人",
        "praise": "0",
        "view": "4958",
        "audit": "1",
        "tag1": "html",
        "tag2": "javascript",
        "tag3": "test",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "1",
        "diggCount": "0",
        "articleType": null,
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-20T09:47:22.000Z",
        "destroyTime": null
    },
    {
        "id": 193,
        "email": "2714351312@qq.com",
        "title": "electron",
        "content": "#### 创建你的第一个应用:\n\n`package.json`:\n```json\n{\n  \"name\": \"my-electron-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"my demo\",\n  \"main\": \"main.js\",\n  \"scripts\": {\n    \"dev\": \"electron .  --inspect=5858\",\n    \"start\": \"electron-forge start\",\n    \"package\": \"electron-forge package\",\n    \"make\": \"electron-forge make\",\n    \"win\": \"electron-builder --win --x64\"\n  },\n  \"author\": \"icestone\",\n  \"license\": \"MIT\",\n  \"devDependencies\": {\n    \"@electron-forge/cli\": \"^6.1.1\",\n    \"electron\": \"23.1.3\",\n    \"electron-builder\": \"^23.6.0\"\n  },\n  \"win\": {\n    \"icon\": \"icons/icon.ico\",\n    \"target\": [\n      {\n        \"target\": \"nsis\",\n        \"arch\": [\n          \"x64\",\n          \"ia32\"\n        ]\n      }\n    ]\n  }\n}\n```\n\n`main.js`\n\n```javascript\nconst path = require('path');\nconst {app, BrowserWindow, ipcMain} = require('electron');\n\nconst createWindow = () => {\n    const win = new BrowserWindow({\n        width: 1000,\n        height: 900,\n        webPreferences: {\n            preload: path.join(__dirname, './preload.js'),\n        },\n    })\n    require('./src/js/menu'),\n        ipcMain.handle('ping', () => 'pong');\n    win.loadFile('index.html');\n}\n\n\n// 下面两种监听都可以\n/*app.whenReady().then(() => {\n    createWindow()\n})*/\napp.on('ready', () => {\n    createWindow()\n})\n\n//  监听关闭时调用\napp.on('window-all-closed', () => {\n    console.log('close window')\n    if (process.platform !== 'darwin') app.quit()\n})\n```\n\n`index.html`:\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Hello World!</title>\n    <meta http-equiv=\"Content-Security-Policy\" content=\"script-src 'self' 'unsafe-inline';\"/>\n</head>\n<body>\n<h1>Hello World!</h1>\n<p>\n    We are using Node.js <span id=\"node-version\"></span>,\n    Chromium <span id=\"chrome-version\"></span>,\n    and Electron <span id=\"electron-version\"></span>.\n</p>\n</body>\n</html>\n```\n\nrun:\n\n![](./images/1.png)\n\n#### 监听一个窗口的关闭:\n\n```javascript\n    win.on('close', function () {\n    console.log('window is close!')\n})\n```\n\n它的完整代码应该是:\n\n```javascript\nconst path = require('path');\nconst {app, BrowserWindow, ipcMain} = require('electron');\n\nconst createWindow = () => {\n    const win = new BrowserWindow({\n        width: 1000,\n        height: 900,\n        webPreferences: {\n            preload: path.join(__dirname, './preload.js'),\n        },\n    })\n    ipcMain.handle('ping', () => 'pong');\n    win.loadFile('index.html');\n    win.on('close', function () {\n        console.log('window is close!')\n    })\n}\n\n\n// 下面两种监听都可以\n/*app.whenReady().then(() => {\n    createWindow()\n})*/\napp.on('ready', () => {\n    createWindow()\n})\n\n//  监听关闭时调用\napp.on('window-all-closed', () => {\n    console.log('close window')\n    if (process.platform !== 'darwin') app.quit()\n})\n```\n\n#### electron的生命周期\n\n#### 生命周期事件:\n\n- ready\n    - app初始化完成时调用一次\n- dom-ready\n    - 一个窗口中的文本加载完成,此时可以执行dom操作\n- did-finsh-load\n    - 导航完成时触发\n- window-all-closed\n    - 所有窗口都被关闭时触发\n\n- before-quit\n    - 在关闭窗口之前触发\n- will-quit\n    - 在窗口关闭并且应用退出时触发\n- quit\n    - 当所有窗口被关闭时触发\n\n- closed\n    - 当所有窗口关闭时触发,此时应删除窗口引用\n\n例如下面的main.js演示:\n\n```javascript\nconst path = require('path');\nconst {app, BrowserWindow, ipcMain} = require('electron');\n\nconst createWindow = () => {\n    const win = new BrowserWindow({\n        width: 1000,\n        height: 900,\n        webPreferences: {\n            preload: path.join(__dirname, './preload.js'),\n        },\n    })\n    ipcMain.handle('ping', () => 'pong');\n    win.loadFile('index.html');\n\n    win.webContents.on('did-finish-load', () => {\n        console.log('did-finish-load');\n    })\n    win.webContents.on('dom-ready', () => {\n        console.log('dom-ready');\n    })\n\n    win.on('close', function () {\n        console.log('close')\n    })\n}\n\n\n// 下面两种监听都可以\n/*app.whenReady().then(() => {\n    createWindow()\n})*/\napp.on('ready', () => {\n    console.log('ready')\n    createWindow()\n});\n//  监听关闭时调用\napp.on('window-all-closed', () => {\n    console.log('all close window')\n    if (process.platform !== 'darwin') app.quit()\n});\napp.on('before-quit', function () {\n    console.log('before-quit')\n});\napp.on('will-quit', function () {\n    console.log('will-quit');\n});\napp.on('quit', function () {\n    console.log('quit');\n});\n```\n\nrun:\n\n![](./images/2.png)\n\n#### 窗口尺寸设置\n\n#### 使用nodemon\n\n`package.json中的script:`\n\n```json\n  \"scripts\": {\n\"dev\": \"electron .  --inspect=5858\",\n\"start\": \"electron .\",\n\"nodemon\": \"nodemon --main.js --exec npm run dev\"\n},\n```\n\n这样就可以使用nodemon监听main.js的改动了\n\n#### 相关属性\n\n每次打开窗口默认会在屏幕的中央进行显示,如果想要更改,可以在mian.js中使用`x`,`y`来更改:\n\n```javascript\nconst path = require('path');\nconst {app, BrowserWindow, ipcMain} = require('electron');\n\nconst createWindow = () => {\n    const win = new BrowserWindow({\n        x: 200,\n        y: 200,\n        width: 1000,\n        height: 900,\n        webPreferences: {\n            preload: path.join(__dirname, './preload.js'),\n        },\n    })\n    ipcMain.handle('ping', () => 'pong');\n    win.loadFile('index.html');\n\n    win.webContents.on('did-finish-load', () => {\n        console.log('did-finish-load');\n    })\n    win.webContents.on('dom-ready', () => {\n        console.log('dom-ready');\n    })\n\n    win.on('close', function () {\n        console.log('close')\n    })\n}\n\n// 下面两种监听都可以\n/*app.whenReady().then(() => {\n    createWindow()\n})*/\napp.on('ready', () => {\n    console.log('ready')\n    createWindow()\n});\n//  监听关闭时调用\napp.on('window-all-closed', () => {\n    console.log('all close window')\n    if (process.platform !== 'darwin') app.quit()\n});\napp.on('before-quit', function () {\n    console.log('before-quit')\n});\napp.on('will-quit', function () {\n    console.log('will-quit');\n});\napp.on('quit', function () {\n    console.log('quit');\n});\n```\n\n然后他就更改了:\n\n![](./images/3.png)\n\n但是此时,可能会先出现窗口,白屏一瞬间之后再加载内容,那么此时就可以使用:`show: false`设置一下\n\n```javascript\nconst win = new BrowserWindow({\n    show: false,\n    x: 200,\n    y: 200,\n    width: 1000,\n    height: 900,\n    webPreferences: {\n        preload: path.join(__dirname, './preload.js'),\n    },\n})\nwin.on(\"ready-to-show\", function () {\n    win.loadFile('index.html');\n})\n```\n\n这里监听了`ready-to-show`,在这个阶段才调用加载`index.html`\n\n#### 设置最大,最小尺寸\n\n```javascript\nconst win = new BrowserWindow({\n    show: false,\n    x: 200,\n    y: 200,\n    width: 1000,\n    height: 900,\n    maxHeight: 1000,\n    maxWidth: 1100,\n    minHeight: 500,\n    minWidth: 1000\n})\n```\n\n#### 固定尺寸\n\n使用`resizable:false`:\n\n```javascript\nconst win = new BrowserWindow({\n    show: false,\n    x: 200,\n    y: 200,\n    width: 1000,\n    height: 900,\n    maxHeight: 1000,\n    maxWidth: 1100,\n    minHeight: 500,\n    minWidth: 1000,\n    resizable: false\n})\n```\n\n#### main设置界面内容\n\n#### 设置title\n\n```javascript\nconst win = new BrowserWindow({\n    // show: false,\n    x: 200,\n    y: 200,\n    width: 1000,\n    height: 900,\n    // 设置最大尺寸\n    maxHeight: 1000,\n    maxWidth: 1100,\n    // 设置最小尺寸\n    minHeight: 500,\n    minWidth: 1000,\n    // 禁止缩放窗口\n    // resizable:false\n    title: '在main.js中设置的title'\n})\n```\n\n- 注意,此时在index.html的title应该为空\n\n##### 设置icon\n\n```javascript\nconst win = new BrowserWindow({\n    // show: false,\n    x: 200,\n    y: 200,\n    width: 1000,\n    height: 900,\n    // 设置最大尺寸\n    maxHeight: 1000,\n    maxWidth: 1100,\n    // 设置最小尺寸\n    minHeight: 500,\n    minWidth: 1000,\n    // 禁止缩放窗口\n    // resizable:false\n    title: '在main.js中设置的title',\n    icon: './lg.ico'\n})\n```\n\n如图:\n\n![](./images/4.png)\n\n##### 不显示默认的窗口和菜单\n\n`frame:false`,默认为true\n\n运行:\n\n![](./images/5.png)\n\n那么此时窗口无法进行拖动\n\n##### 透明窗体\n\n`transparent: true`\n\n运行:\n\n![](./images/6.png)\n\n##### 隐藏menu\n\n````javascript\nconst win = new BrowserWindow({\n    // show: false,\n    x: 200,\n    y: 200,\n    width: 1000,\n    height: 900,\n    // 设置最大尺寸\n    maxHeight: 1000,\n    maxWidth: 1100,\n    // 设置最小尺寸\n    minHeight: 500,\n    minWidth: 1000,\n    // 禁止缩放窗口\n    // resizable:false\n    title: '在main.js中设置的title',\n    icon: './lg.ico',\n    // 不显示默认窗口和菜单\n    // frame:false\n    // 透明窗体\n    // transparent: true\n    // 隐藏menu\n    autoHideMenuBar: true\n})\n````\n\n#### 调试面板\n\nctrl+shift+i\n\n#### 允许渲染进程和nodejs交互\n\n一般情况下,在`index.html`中引用的js文件是无法导入nodejs中的包的,例如下面的代码:\n\n`index.js`:\n\n```javascript\nconst o = require('electron');\n\n// dom加载完之后执行\nwindow.addEventListener('DOMContentLoaded', function () {\n// 点击打开一个新窗口\n    const oBtn = document.getElementById('btn')\n    oBtn.addEventListener('click', () => {\n    })\n})\n```\n\n在第一行导入了包,那么在应用的控制台中:\n\n![](./images/7.png)\n\n默认情况下是不允许渲染进程中的js直接和nodejs进行交互,那么在开发中想要和nodejs进行交互,可以在main.js中开启:\n\n```javascript\nwebPreferences: {\n    nodeIntegration: true,\n        contextIsolation\n:\n    false\n}\n```\n\n完整的main.js:\n\n```javascript\nconst path = require('path');\nconst {app, BrowserWindow, ipcMain} = require('electron');\n\nconst createWindow = () => {\n    const win = new BrowserWindow({\n        x: 200,\n        y: 200,\n        width: 1000,\n        height: 900,\n        title: '在main.js中设置的title',\n        icon: './lg.ico',\n        autoHideMenuBar: true,\n        webPreferences: {\n            nodeIntegration: true,\n            contextIsolation: false\n        }\n    })\n    win.loadFile('index.html');\n}\n\n//  监听关闭时调用\napp.on('window-all-closed', () => {\n    console.log('all close window')\n    if (process.platform !== 'darwin') app.quit()\n});\n```\n\n然后就不会报错了\n\n#### 渲染进程中不可以使用主进程的一些对象\n\n例如像下面,在渲染进程中使用了`BrowserWindow`,虽然可以导入,但是不被允许:\n\n```javascript\n// BrowserWindow 是个主进程,虽然可以导入,但是在渲染进程中是不允许这样做的\nconst {BrowserWindow} = require('electron');\n// dom加载完之后执行\nwindow.addEventListener('DOMContentLoaded', function () {\n// 点击打开一个新窗口\n    const oBtn = document.getElementById('btn')\n    oBtn.addEventListener('click', () => {\n        let indexMin = new BrowserWindow({\n            width: 1000,\n            height: 900\n        })\n        indexMin.loadFile('../views/list.html');\n        indexMin.on(\"close\", () => {\n            indexMin = null;\n        })\n    })\n})\n```\n\n报错:\n\n```shell\nindex.js:8 Uncaught TypeError: BrowserWindow is not a constructor\n    at HTMLButtonElement.<anonymous> (index.js:8:24)\n```\n\n#### 使用remote让渲染进程使用BrowserWindow\n\nmain.js中的主要代码:\n\n```javascript\nconst remote = require(\"@electron/remote/main\") //1\nremote.initialize()//2\nremote.enable(win.webContents)//3\n```\n\n`mian.js`的完整代码:\n\n```javascript\nconst {app, BrowserWindow} = require('electron');\nconst remote = require(\"@electron/remote/main\") //1\nremote.initialize()//2\n\nconst createWindow = () => {\n    const win = new BrowserWindow({\n        x: 200,\n        y: 200,\n        width: 1000,\n        height: 900,\n        title: '在main.js中设置的title',\n        icon: './lg.ico',\n        autoHideMenuBar: true,\n        webPreferences: {\n            nodeIntegration: true,\n            contextIsolation: false\n        },\n    })\n    win.loadFile('index.html');\n    remote.enable(win.webContents)//3\n}\n\napp.on('ready', () => {\n    console.log('ready')\n    createWindow()\n});\n//  监听关闭时调用\napp.on('window-all-closed', () => {\n    console.log('all close window')\n    if (process.platform !== 'darwin') app.quit()\n});\n```\n\n`index.js`:\n\n```javascript\n// BrowserWindow 是个主进程,虽然可以导入,但是在渲染进程中是不允许这样做的\nconst {BrowserWindow} = require(\"@electron/remote\");\nconsole.log('当前路径')\nconsole.log(__dirname)\n// dom加载完之后执行\nwindow.addEventListener('DOMContentLoaded', function () {\n// 点击打开一个新窗口\n    const oBtn = document.getElementById('btn')\n    oBtn.addEventListener('click', () => {\n        let indexMin = new BrowserWindow({\n            width: 1000,\n            height: 900\n        })\n        indexMin.loadFile('./src/views/list.html');\n        indexMin.on(\"close\", () => {\n            indexMin = null;\n        })\n    })\n})\n```\n\n要注意这里的引用:\n\n```javascript\nconst {BrowserWindow} = require(\"@electron/remote\");\n```\n\n![](./images/8.png)\n\n#### 自定义窗口的实现\n\n##### 最小化,最大化,关闭的实现:\n\n`index.html`:\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <!-- https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP -->\n    <meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'; script-src 'self'\">\n    <title></title>\n    <!--    <link rel=\"stylesheet/less\" type=\"text/less\" href=\"./src/css/index.less\"/>-->\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"./src/css/index.css\"/>\n</head>\n<body>\n<div class=\"container\">\n    <div class=\"header\">\n        <div class=\"btn\">minWindow</div>\n        <div class=\"btn\">maxWindow</div>\n        <div class=\"btn\">close</div>\n    </div>\n\n</div>\n\n<script src=\"./index.js\"></script>\n\n</body>\n</html>\n```\n\n`index.js`:\n\n```javascript\n// BrowserWindow 是个主进程,虽然可以导入,但是在渲染进程中是不允许这样做的\nconst {BrowserWindow, ipcMain, getCurrentWindow} = require(\"@electron/remote\");\nlet mainWin = getCurrentWindow();\n\nconsole.log('当前路径')\nconsole.log(__dirname)\n// dom加载完之后执行\nwindow.addEventListener('DOMContentLoaded', function () {\n// 点击打开一个新窗口\n    const btns = document.getElementsByClassName('btn')\n    const close = btns[2];\n    const maxWindow = btns[1];\n    const minWindow = btns[0];\n\n    close.addEventListener('click', () => {\n        console.log('关闭')\n        mainWin.close();\n    })\n    maxWindow.addEventListener('click', () => {\n        console.log('最大化')\n        /*        console.log('是否为最大化')\n                console.log(mainWin.isMaximizable());*/\n        if (!mainWin.isMaximized()) {\n            mainWin.maximize()\n        } else {\n            console.log('恢复尺寸')\n            // 让当前窗口回到原始状态\n            mainWin.restore();\n        }\n    })\n    minWindow.addEventListener('click', () => {\n        console.log('最小化')\n        if (!mainWin.isMinimized()) {\n            mainWin.minimize()\n        } else {\n            mainWin.restore();\n        }\n    })\n})\n```\n\n##### 阻止窗口关闭\n\n监听窗口关闭之前的状态:\n\n`index.js`:\n\n```javascript\n// BrowserWindow 是个主进程,虽然可以导入,但是在渲染进程中是不允许这样做的\nconst {BrowserWindow, ipcMain, getCurrentWindow} = require(\"@electron/remote\");\nlet mainWin = getCurrentWindow();\n\nconsole.log('当前路径')\nconsole.log(__dirname)\n// dom加载完之后执行\nwindow.addEventListener('DOMContentLoaded', function () {\n    window.onbeforeunload = function () {\n        console.log('关闭窗口')\n        return false;\n    }\n\n// 点击打开一个新窗口\n    const btns = document.getElementsByClassName('btn')\n    const close = btns[2];\n    const maxWindow = btns[1];\n    const minWindow = btns[0];\n\n    close.addEventListener('click', () => {\n        console.log('关闭')\n        mainWin.close();\n    })\n    maxWindow.addEventListener('click', () => {\n        console.log('最大化')\n        /*console.log('是否为最大化')\n                console.log(mainWin.isMaximizable());*/\n        if (!mainWin.isMaximized()) {\n            mainWin.maximize()\n        } else {\n            console.log('恢复尺寸')\n            // 让当前窗口回到原始状态\n            mainWin.restore();\n        }\n    })\n    minWindow.addEventListener('click', () => {\n        console.log('最小化')\n        if (!mainWin.isMinimized()) {\n            mainWin.minimize()\n        } else {\n            mainWin.restore();\n        }\n    })\n})\n```\n\n`index.html`:\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'; script-src 'self'\">\n    <title></title>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"./src/css/index.css\"/>\n</head>\n<body>\n<div class=\"container\">\n    <div class=\"header\">\n        <div class=\"btn\">minWindow</div>\n        <div class=\"btn\">maxWindow</div>\n        <div class=\"btn\">close</div>\n    </div>\n\n</div>\n<div class=\"alert\">\n    确认关闭?\n    <button class=\"close\">yes!</button>\n    <button class=\"notClose\">no!</button>\n</div>\n<script src=\"./index.js\"></script>\n</body>\n</html>\n```\n\n这里主要是`index.js`中的:\n\n```javascript\n    window.onbeforeunload = function () {\n    console.log('关闭窗口')\n    return false;\n}\n```\n\n##### 弹窗控制窗口关闭与否:\n\n`index.html`:\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'; script-src 'self'\">\n    <title></title>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"./src/css/index.css\"/>\n</head>\n<body>\n<div class=\"container\">\n    <div class=\"header\">\n        <div class=\"btn\">minWindow</div>\n        <div class=\"btn\">maxWindow</div>\n        <div class=\"btn\">close</div>\n    </div>\n</div>\n<div class=\"alert\">\n    确认关闭?\n    <button class=\"close\">yes!</button>\n    <button class=\"notClose\">no!</button>\n</div>\n<script src=\"./index.js\"></script>\n</body>\n</html>\n```\n\n`index.css`:\n\n```css\n.container {\n    display: flex;\n    flex-direction: column;\n}\n\n.header {\n    display: flex;\n    width: 100%;\n    flex-direction: row;\n    justify-content: end;\n    background: #8c8c73;\n}\n\n.header div {\n    padding-right: 20px;\n}\n\nbody {\n    background-image: linear-gradient(to top, #cfd9df 0%, #e2ebf0 100%);\n}\n\n.alert {\n    display: none;\n}\n```\n\n`index.js`:\n\n```javascript\n// BrowserWindow 是个主进程,虽然可以导入,但是在渲染进程中是不允许这样做的\nconst {BrowserWindow, ipcMain, getCurrentWindow} = require(\"@electron/remote\");\nlet mainWin = getCurrentWindow();\n\nconsole.log('当前路径')\nconsole.log(__dirname)\n// dom加载完之后执行\nwindow.addEventListener('DOMContentLoaded', function () {\n    window.onbeforeunload = function () {\n        console.log('关闭窗口')\n        const alert = document.getElementsByClassName('alert')[0];\n        alert.style.display = 'flex';\n        const yesBtn = document.getElementsByClassName('close')[0];\n        const noBtn = document.getElementsByClassName('notClose')[0];\n        yesBtn.addEventListener('click', () => {\n            mainWin.destroy();\n        })\n        noBtn.addEventListener('click', () => {\n            alert.style.display = 'none';\n        })\n        return false;\n    }\n\n// 点击打开一个新窗口\n    const btns = document.getElementsByClassName('btn')\n    const close = btns[2];\n    const maxWindow = btns[1];\n    const minWindow = btns[0];\n\n    close.addEventListener('click', () => {\n        console.log('关闭')\n        mainWin.close();\n    })\n    maxWindow.addEventListener('click', () => {\n        console.log('最大化')\n        /*console.log('是否为最大化')\n                console.log(mainWin.isMaximizable());*/\n        if (!mainWin.isMaximized()) {\n            mainWin.maximize()\n        } else {\n            console.log('恢复尺寸')\n            // 让当前窗口回到原始状态\n            mainWin.restore();\n        }\n    })\n    minWindow.addEventListener('click', () => {\n        console.log('最小化')\n        if (!mainWin.isMinimized()) {\n            mainWin.minimize()\n        } else {\n            mainWin.restore();\n        }\n    })\n})\n```\n\n`main.js`:\n\n```javascript\nconst {app, BrowserWindow} = require('electron')\nconst path = require('path')\nconst remote = require(\"@electron/remote/main\") //1\nremote.initialize()//2\nconst createWindow = () => {\n    const win = new BrowserWindow({\n        width: 800,\n        height: 600,\n        frame: false,\n        webPreferences: {\n            nodeIntegration: true,\n            contextIsolation: false\n        }\n    })\n    win.loadFile('index.html')\n    win.on('close', function () {\n        console.log('close')\n    })\n    remote.enable(win.webContents)//3\n}\napp.whenReady().then(() => {\n    createWindow()\n    app.on('activate', () => {\n        if (BrowserWindow.getAllWindows().length === 0) createWindow()\n    })\n})\napp.on('window-all-closed', () => {\n    if (process.platform !== 'darwin') app.quit()\n})\n```\n\n#### 父子及模态窗口\n\n> 一般情况下创建的子窗口,在操作子窗口时,父窗口依旧可以操作:\n\n`main.js`:\n\n```javascript\nconst {app, BrowserWindow} = require('electron')\n//1\nconst remote = require(\"@electron/remote/main\")\n//2\nremote.initialize()\n\nconst createWindow = () => {\n    // 创建浏览窗口\n    const win = new BrowserWindow({\n        width: 800,\n        height: 600,\n        title: '子窗口及模态窗口',\n        webPreferences: {\n            nodeIntegration: true,\n            contextIsolation: false\n        }\n    })\n\n    // 加载 index.html\n    win.loadFile('index.html')\n    //3\n    remote.enable(win.webContents)\n\n    // 打开开发工具\n    // mainWindow.webContents.openDevTools()\n}\n\n// 这段程序将会在 Electron 结束初始化\n// 和创建浏览器窗口的时候调用\n// 部分 API 在 ready 事件触发后才能使用。\napp.whenReady().then(() => {\n    createWindow()\n    app.on('activate', () => {\n        // 在 macOS 系统内, 如果没有已开启的应用窗口\n        // 点击托盘图标时通常会重新创建一个新窗口\n        if (BrowserWindow.getAllWindows().length === 0) createWindow()\n    })\n})\n\napp.on('window-all-closed', () => {\n    if (process.platform !== 'darwin') app.quit()\n})\n```\n\n`index.html`:\n\n```html\n<!--index.html-->\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'; script-src 'self'\">\n    <title></title>\n</head>\n<body>\n\n<div class=\"container\">\n    <button id=\"btn\">新增窗口</button>\n\n</div>\n<script src=\"./index.js\"></script>\n</body>\n</html>\n```\n\n`index.js`:\n\n```javascript\nconst {BrowserWindow, getCurrentWindow} = require(\"@electron/remote\");\nlet mainWin = getCurrentWindow();\nwindow.addEventListener('DOMContentLoaded', () => {\n    const btn = document.getElementById(\"btn\");\n    btn.addEventListener('click', () => {\n        let subWin = new BrowserWindow({\n            parent: mainWin,\n            width: 1000,\n            height: 900\n        })\n        subWin.loadFile('sub.html')\n        subWin.on('close', () => {\n            subWin = null;\n        })\n    })\n})\n```\n\nrun:\n\n![](./images/9.png)\n\n此时是可以拖动父窗口的\n\n但是使用模态窗口就可以避免这个问题,\n\n> 模态窗口\n\n`main.js`:\n\n```javascript\nconst {app, BrowserWindow} = require('electron')\n//1\nconst remote = require(\"@electron/remote/main\")\n//2\nremote.initialize()\n\nconst createWindow = () => {\n    // 创建浏览窗口\n    const win = new BrowserWindow({\n        width: 800,\n        height: 600,\n        title: '子窗口及模态窗口',\n        webPreferences: {\n            nodeIntegration: true,\n            contextIsolation: false\n        }\n    })\n\n    // 加载 index.html\n    win.loadFile('index.html')\n    //3\n    remote.enable(win.webContents)\n\n    // 打开开发工具\n    // mainWindow.webContents.openDevTools()\n}\n\n// 这段程序将会在 Electron 结束初始化\n// 和创建浏览器窗口的时候调用\n// 部分 API 在 ready 事件触发后才能使用。\napp.whenReady().then(() => {\n    createWindow()\n    app.on('activate', () => {\n        // 在 macOS 系统内, 如果没有已开启的应用窗口\n        // 点击托盘图标时通常会重新创建一个新窗口\n        if (BrowserWindow.getAllWindows().length === 0) createWindow()\n    })\n})\napp.on('window-all-closed', () => {\n    if (process.platform !== 'darwin') app.quit()\n})\n```\n\n`index.html`:\n\n```html\n<!--index.html-->\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'; script-src 'self'\">\n    <title></title>\n</head>\n<body>\n\n<div class=\"container\">\n    <button id=\"btn\">新增窗口</button>\n\n</div>\n<script src=\"./index.js\"></script>\n</body>\n</html>\n```\n\n`index.js`:\n\n```javascript\nconst {BrowserWindow, getCurrentWindow} = require(\"@electron/remote\");\nlet mainWin = getCurrentWindow();\nwindow.addEventListener('DOMContentLoaded', () => {\n\n    const btn = document.getElementById(\"btn\");\n    btn.addEventListener('click', () => {\n        let subWin = new BrowserWindow({\n            parent: mainWin,\n            width: 1000,\n            height: 900,\n            modal: true\n        })\n        subWin.loadFile('sub.html')\n        subWin.on('close', () => {\n            subWin = null;\n        })\n    })\n})\n```\n\nrun:\n\n![](./images/10.png)\n\n注意,这里主要起作用的是`index.js`的:\n\n```javascript\nmodal: true\n```\n\n#### 自定义菜单\n\n##### 自定义一个简单的菜单\n\n```javascript\nconst {app, BrowserWindow, Menu} = require('electron')\n//1\nconst remote = require(\"@electron/remote/main\")\n//2\nremote.initialize()\nconst createWindow = () => {\n    // 创建浏览窗口\n    const win = new BrowserWindow({\n        width: 800,\n        height: 600,\n        title: '自定义菜单',\n        webPreferences: {\n            nodeIntegration: true,\n            contextIsolation: false\n        }\n    })\n    // 1.定义自己需要的菜单\n    let menuMap = [\n        {label: '文件'},\n        {label: '编辑'},\n    ];\n    // 2.利用上面的模板构建菜单项:\n    let menu = Menu.buildFromTemplate(menuMap);\n    // 3.将上述的自定义菜单添加到应用\n    Menu.setApplicationMenu(menu);\n    win.loadFile('index.html')\n    //3\n    remote.enable(win.webContents)\n}\napp.whenReady().then(() => {\n    createWindow()\n    app.on('activate', () => {\n        if (BrowserWindow.getAllWindows().length === 0) createWindow()\n    })\n})\napp.on('window-all-closed', () => {\n    if (process.platform !== 'darwin') app.quit()\n})\n```\n\n主要分三步:\n\n- 定义你的菜单,数组,需要在之前引入Menu:`const {app, BrowserWindow, Menu} = require('electron')`\n\n```javascript\n// 1.定义自己需要的菜单\nlet menuMap = [\n    {label: '文件'},\n    {label: '编辑'},\n];\n```\n\n- 利用上面的模板构建菜单项:\n\n```javascript\nlet menu = Menu.buildFromTemplate(menuMap);\n```\n\n- 将上述的自定义菜单添加到应用\n\n```javascript\n// 3.将上述的自定义菜单添加到应用\nMenu.setApplicationMenu(menu);\nwin.loadFile('index.html')\n```\n\n##### 菜单的点击以及二级菜单\n\n```javascript\nconst {app, BrowserWindow, Menu} = require('electron')\n//1\nconst remote = require(\"@electron/remote/main\")\n//2\nremote.initialize()\nconst createWindow = () => {\n    // 创建浏览窗口\n    const win = new BrowserWindow({\n        width: 800,\n        height: 600,\n        title: '自定义菜单',\n        webPreferences: {\n            nodeIntegration: true,\n            contextIsolation: false\n        }\n    })\n    // 1.定义自己需要的菜单\n    let menuMap = [\n        {\n            label: '文件',\n            submenu: [\n                {\n                    label: '打开文件夹',\n                    click() {\n                        console.log('open someone dir')\n                    }\n                },\n                {\n                    label: '打开文件'\n                },\n                {\n                    label: '关于',\n                    role: 'about'\n                }\n            ]\n        },\n        {label: '编辑'},\n    ];\n    // 2.利用上面的模板构建菜单项:\n    let menu = Menu.buildFromTemplate(menuMap);\n    // 3.将上述的自定义菜单添加到应用\n    Menu.setApplicationMenu(menu);\n    // 加载 index.html\n    win.loadFile('index.html')\n    //3\n    remote.enable(win.webContents)\n}\napp.whenReady().then(() => {\n    createWindow()\n    app.on('activate', () => {\n        if (BrowserWindow.getAllWindows().length === 0) createWindow()\n    })\n})\n\napp.on('window-all-closed', () => {\n    if (process.platform !== 'darwin') app.quit()\n})\n\n```\n\n这里主要是`menuMap`发生变化,里面存储的`click`函数,在`文件`中定义的有其他的二级菜单\n\n##### 定义菜单之间的分割线\n\n```javascript\nlet menuMap = [\n    {\n        label: '文件',\n        submenu: [\n            {\n                label: '打开文件夹',\n                click() {\n                    console.log('open someone dir')\n                }\n            },\n            // 分割线\n            {\n                type: 'separator'\n            },\n            {\n                label: '打开文件',\n            },\n            {\n                label: '关于',\n                role: 'about'\n            }\n        ]\n    },\n    {label: '编辑'},\n];\n```\n\n例如上面的,传入type`的值表示不同的分割线\n\n#### 角色菜单以及类型\n\n##### 菜单中的内置角色\n\n```javascript\nlet menuMap = [\n    {\n        label: '内置角色',\n        submenu: [\n            {\n                label: '复制',\n                role: 'copy'\n            },\n            {\n                label: '剪贴',\n                role: 'cut'\n            },\n            {\n                label: '粘贴',\n                role: 'paste'\n            },\n            {\n                label: '最小化',\n                role: 'minimize'\n            }\n        ]\n    }];\n```\n\n##### 菜单中的选项卡:\n\n```javascript\nlet menuMap = [\n    {\n        label: '类型',\n        submenu: [\n            {\n                label: '选项1',\n                type: 'checkbox'\n            },\n            {\n                label: '选项2',\n                type: 'checkbox'\n            },\n            {\n                label: '选项3',\n                type: 'checkbox'\n            },\n            {\n                type: 'separator'\n            },\n            {\n                label: 'item1',\n                type: 'radio'\n            },\n            {\n                label: 'item2',\n                type: 'radio'\n            },\n            {\n                type: 'separator'\n            },\n            {\n                label: 'windows',\n                type: 'submenu',\n                role: 'windowMenu'\n            }\n        ]\n    }]\n```\n\n##### 快捷键\n\n```javascript\nlet menuMap = [\n    {\n        label: '其他',\n        submenu: [\n            {\n                label: '打开',\n                icon: './open.png',\n                accelerator: 'ctrl+o',\n                click() {\n                    console.log('open操作执行了!')\n                }\n            },\n        ]\n    }\n]\n```\n\n![](./images/11.png)\n![](./images/12.png)\n![](./images/13.png)\n\n#### 动态创建菜单\n\n`main.js`:\n\n```javascript\nconst {app, BrowserWindow} = require('electron')\n//1\nconst remote = require(\"@electron/remote/main\")\n//2\nremote.initialize()\n\nconst createWindow = () => {\n    // 创建浏览窗口\n    const win = new BrowserWindow({\n        width: 800,\n        height: 600,\n        title: 'demo页面',\n        webPreferences: {\n            nodeIntegration: true,\n            contextIsolation: false\n        }\n    })\n\n    // 加载 index.html\n    win.loadFile('index.html')\n    //3\n    remote.enable(win.webContents)\n\n    // 打开开发工具\n    // mainWindow.webContents.openDevTools()\n}\n\n// 这段程序将会在 Electron 结束初始化\n// 和创建浏览器窗口的时候调用\n// 部分 API 在 ready 事件触发后才能使用。\napp.whenReady().then(() => {\n    createWindow()\n    app.on('activate', () => {\n        // 在 macOS 系统内, 如果没有已开启的应用窗口\n        // 点击托盘图标时通常会重新创建一个新窗口\n        if (BrowserWindow.getAllWindows().length === 0) createWindow()\n    })\n})\n\napp.on('window-all-closed', () => {\n    if (process.platform !== 'darwin') app.quit()\n})\n```\n\n`index.html`:\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'; script-src 'self'\">\n    <title></title>\n</head>\n<body>\n<h1>自定义菜单</h1>\n<div class=\"container\">\n    <button id=\"add\">创建自定义菜单</button>\n    <input type=\"text\" value=\"输入自定义菜单项内容\" id=\"menuVal\">\n    <button id=\"addMenu\">添加菜单项</button>\n\n</div>\n<script src=\"./index.js\"></script>\n</body>\n</html>\n```\n\n`index.js`:\n\n```javascript\nconst {BrowserWindow, Menu, MenuItem} = require(\"@electron/remote\");\n\nconsole.log('当前路径')\nconsole.log(__dirname)\n// 自定义全局变量\nlet menuItem = new Menu();\n\nwindow.addEventListener('DOMContentLoaded', () => {\n    let addBtn = document.getElementById('add');\n    let addMenuBtn = document.getElementById('addMenu');\n    let input = document.getElementById('menuVal');\n\n// 生成自定义的菜单:\n    addBtn.addEventListener('click', () => {\n// 创建菜单\n        let menuFile = new MenuItem({label: '文件', type: 'normal'});\n        let menuEdit = new MenuItem({label: '编辑', type: 'normal'});\n        let customMenu = new MenuItem({label: '自定义菜单', submenu: menuItem});\n// 将创建好的菜单添加至menu\n        let menu = new Menu();\n        menu.append(menuFile)\n        menu.append(menuEdit)\n        menu.append(customMenu)\n// 将menu放置于app中显示\n        Menu.setApplicationMenu(menu);\n    })\n\n    addMenuBtn.addEventListener('click', () => {\n        // 获取当前input输入框的内容\n        const con = input.value.trim();\n        if (con) {\n            menuItem.append(new MenuItem({\n                label: con, type: 'normal'\n            }))\n            input.value = '';\n        }\n    })\n})\n```\n\n运行:\n\n![](./images/14.png)\n\n#### 右键菜单\n\n`mian.js`:\n\n```javascript\nconst {app, BrowserWindow} = require('electron')\n//1\nconst remote = require(\"@electron/remote/main\")\n//2\nremote.initialize()\n\nconst createWindow = () => {\n    // 创建浏览窗口\n    const win = new BrowserWindow({\n        width: 800,\n        height: 600,\n        title: '右键菜单',\n        webPreferences: {\n            nodeIntegration: true,\n            contextIsolation: false\n        }\n    })\n\n    // 加载 index.html\n    win.loadFile('index.html')\n    //3\n    remote.enable(win.webContents)\n\n    // 打开开发工具\n    // mainWindow.webContents.openDevTools()\n}\n\n// 这段程序将会在 Electron 结束初始化\n// 和创建浏览器窗口的时候调用\n// 部分 API 在 ready 事件触发后才能使用。\napp.whenReady().then(() => {\n    createWindow()\n    app.on('activate', () => {\n        // 在 macOS 系统内, 如果没有已开启的应用窗口\n        // 点击托盘图标时通常会重新创建一个新窗口\n        if (BrowserWindow.getAllWindows().length === 0) createWindow()\n    })\n})\n\napp.on('window-all-closed', () => {\n    if (process.platform !== 'darwin') app.quit()\n})\n\n```\n\n`index.html`:\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'; script-src 'self'\">\n    <title></title>\n</head>\n<body>\n<h1>你好!</h1>\n<div class=\"container\">\n\n</div>\n<script src=\"./index.js\"></script>\n</body>\n</html>\n```\n\n`index.js`:\n\n```javascript\nconst {Menu, getCurrentWindow} = require(\"@electron/remote\");\nconst remote = require(\"@electron/remote/main\")\nlet mainWin = getCurrentWindow();\n\n\n// 创建一个自定义的菜单内容\nlet contextTemp = [\n    {label: 'Run Code'},\n    {label: '转到定义'},\n    {type: 'separator'},\n    {\n        label: '其他功能',\n        click() {\n            console.log('其他功能被点击了')\n        }\n    },\n]\n// 依据上面模板来创建menu\nlet menu = Menu.buildFromTemplate(contextTemp);\n\n// 在鼠标右击行为后显示出来\nwindow.addEventListener('DOMContentLoaded', () => {\n// 监听右击\n    window.addEventListener('contextmenu', (ev) => {\n        ev.preventDefault();\n        menu.popup({\n            window: mainWin\n        })\n    }, false)\n})\n```\n\n运行:\n![](./images/15.png)\n\n#### 主进程与渲染进程之间通讯\n\n\n\n> 监听页面元素点击,渲染进程向主进程发消息:\n\n##### 渲染进程向主进程发送消息\n\n`index.html`\n\n```html\n<button id=\"one\">渲染到主异步操作</button>\n    <br>\n    <button id=\"two\">渲染到主同步操作</button>\n```\n`index.js`\n```javascript\nconst {\n    ipcRenderer\n} = require('electron')\n\nwindow.onload = function () {\n    const aBtn = document.getElementById('one');\n    const twoBtn = document.getElementById('two');\n// 异步发送消息\n// 通过异步api在渲染进程中给主进程发送消息\n    aBtn.addEventListener('click', () => {\n        ipcRenderer.send('msg1', '来自渲染进程的异步消息');\n    })\n// 接收来自主进程的异步消息\n    ipcRenderer.on('msg1Re', (ev, data) => {\n        console.log('来自主进程的data:')\n        console.log(data)\n    })\n// 同步发送消息\n    twoBtn.addEventListener('click', () => {\n        let val = ipcRenderer.sendSync('msg2', '同步消息')\n        console.log(\"val:\")\n        console.log(val)\n    })\n}\n```\n\n`main.js`\n\n```javascript\nconst {app, BrowserWindow, ipcMain, Menu} = require('electron')\n//1\nconst remote = require(\"@electron/remote/main\")\n//2\nremote.initialize()\n\nlet temp = [\n    {\n        label: 'send',\n        click() {\n            BrowserWindow.getFocusedWindow().webContents.send('mtp','来自于主进程的消息')\n        }\n    }\n]\nlet menu = Menu.buildFromTemplate(temp);\nMenu.setApplicationMenu(menu);\n\nconst createWindow = () => {\n    // 创建浏览窗口\n    const win = new BrowserWindow({\n        width: 800,\n        height: 600,\n        title: '主进程与渲染进程之间通讯',\n        webPreferences: {\n            nodeIntegration: true,\n            contextIsolation: false\n        }\n    })\n\n    // 加载 index.html\n    win.loadFile('index.html')\n    win.webContents.openDevTools();\n    //3\n    remote.enable(win.webContents)\n\n    // 打开开发工具\n    // mainWindow.webContents.openDevTools()\n}\n\n// 这段程序将会在 Electron 结束初始化\n// 和创建浏览器窗口的时候调用\n// 部分 API 在 ready 事件触发后才能使用。\napp.whenReady().then(() => {\n    createWindow()\n    app.on('activate', () => {\n        // 在 macOS 系统内, 如果没有已开启的应用窗口\n        // 点击托盘图标时通常会重新创建一个新窗口\n        if (BrowserWindow.getAllWindows().length === 0) createWindow()\n    })\n})\n\napp.on('window-all-closed', () => {\n    if (process.platform !== 'darwin') app.quit()\n})\n\n// 主进程接受消息\nipcMain.on('msg1', (ev, data) => {\n    console.log('data:')\n    console.log(data)\n// 给渲染进程发送消息\n    ev.sender.send('msg1Re', '这是一条来自主进程的异步消息')\n})\nipcMain.on('msg2', (ev, data) => {\n    console.log(data)\n    ev.returnValue = '来自于主进程的同步消息'\n})\n```\n\n上面代码中主要是`ipcMain.on`来接收渲染进程发送来的消息\n\n##### 主进程接收消息后向渲染进程发送消息\n\n主进程可以这样接收并返回:\n\n```javascript\nipcMain.on('msg1', (ev, data) => {\n    console.log('data:')\n    console.log(data)\n\t// 给渲染进程发送消息\n    ev.sender.send('msg1Re', '这是一条来自主进程的异步消息')\n})\nipcMain.on('msg2', (ev, data) => {\n    console.log(data)\n    // 给渲染进程发送消息\n    ev.returnValue = '来自于主进程的同步消息'\n})\n```\n\n渲染进程的接收:\n\n```javascript\n ipcRenderer.on('msg1Re', (ev, data) => {\n        console.log('来自主进程的data:')\n        console.log(data)\n    })\n// 同步发送消息\n    twoBtn.addEventListener('click', () => {\n        let val = ipcRenderer.sendSync('msg2', '同步消息')\n        console.log(\"val:\")\n        console.log(val)\n    })\n```\n\n上面的代码中,渲染进程向主进程发送消息,并接收\n\n##### 主线程向渲染进程发送消息\n\n`主线程`:\n\n```javascript\nlet temp = [\n    {\n        label: 'send',\n        click() {\n            BrowserWindow.getFocusedWindow().webContents.send('mtp','来自于主进程的消息')\n        }\n    }\n]\nlet menu = Menu.buildFromTemplate(temp);\nMenu.setApplicationMenu(menu);\n```\n\n上面的代码中,设置了一个点击事件,点击触发向当前获取焦点的窗口发送消息\n\n渲染进程:\n\n```javascript\n    ipcRenderer.on('mtp', (ev, data) => {\n        console.log(data)\n    })\n```\n\n完成代码:\n\n`main.js`\n\n```javascript\nconst {app, BrowserWindow, ipcMain, Menu} = require('electron')\n//1\nconst remote = require(\"@electron/remote/main\")\n//2\nremote.initialize()\n\nlet temp = [\n    {\n        label: 'send',\n        click() {\n            BrowserWindow.getFocusedWindow().webContents.send('mtp','来自于主进程的消息')\n        }\n    }\n]\nlet menu = Menu.buildFromTemplate(temp);\nMenu.setApplicationMenu(menu);\n\nconst createWindow = () => {\n    // 创建浏览窗口\n    const win = new BrowserWindow({\n        width: 800,\n        height: 600,\n        title: '主进程与渲染进程之间通讯',\n        webPreferences: {\n            nodeIntegration: true,\n            contextIsolation: false\n        }\n    })\n\n    // 加载 index.html\n    win.loadFile('index.html')\n    win.webContents.openDevTools();\n    //3\n    remote.enable(win.webContents)\n\n    // 打开开发工具\n    // mainWindow.webContents.openDevTools()\n}\n\n// 这段程序将会在 Electron 结束初始化\n// 和创建浏览器窗口的时候调用\n// 部分 API 在 ready 事件触发后才能使用。\napp.whenReady().then(() => {\n    createWindow()\n    app.on('activate', () => {\n        // 在 macOS 系统内, 如果没有已开启的应用窗口\n        // 点击托盘图标时通常会重新创建一个新窗口\n        if (BrowserWindow.getAllWindows().length === 0) createWindow()\n    })\n})\n\napp.on('window-all-closed', () => {\n    if (process.platform !== 'darwin') app.quit()\n})\n\n// 主进程接受消息\nipcMain.on('msg1', (ev, data) => {\n    console.log('data:')\n    console.log(data)\n// 给渲染进程发送消息\n    ev.sender.send('msg1Re', '这是一条来自主进程的异步消息')\n})\nipcMain.on('msg2', (ev, data) => {\n    console.log(data)\n    ev.returnValue = '来自于主进程的同步消息'\n})\n```\n\n`index.js`\n\n```javascript\nconst {\n    ipcRenderer\n} = require('electron')\n\nwindow.onload = function () {\n    const aBtn = document.getElementById('one');\n    const twoBtn = document.getElementById('two');\n// 异步发送消息\n// 通过异步api在渲染进程中给主进程发送消息\n    aBtn.addEventListener('click', () => {\n        ipcRenderer.send('msg1', '来自渲染进程的异步消息');\n    })\n// 接收来自主进程的异步消息\n    ipcRenderer.on('msg1Re', (ev, data) => {\n        console.log('来自主进程的data:')\n        console.log(data)\n    })\n// 同步发送消息\n    twoBtn.addEventListener('click', () => {\n        let val = ipcRenderer.sendSync('msg2', '同步消息')\n        console.log(\"val:\")\n        console.log(val)\n    })\n    ipcRenderer.on('mtp', (ev, data) => {\n        console.log(data)\n    })\n}\n```\n\n`index.html`\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'; script-src 'self'\">\n    <title></title>\n</head>\n<body>\n<h1>渲染进程与主进程通信</h1>\n<div class=\"container\">\n    <button id=\"one\">渲染到主异步操作</button>\n    <br>\n    <button id=\"two\">渲染到主同步操作</button>\n</div>\n<script src=\"./index.js\"></script>\n</body>\n</html>\n```\n\n#### 基于本地存储的渲染进程通信\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
        "states": "1",
        "description": "这个是electron的笔记描述",
        "praise": "9",
        "view": "141",
        "audit": "1",
        "tag1": "electron",
        "tag2": "javacsript",
        "tag3": "note",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "2",
        "diggCount": null,
        "articleType": null,
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-12T18:13:53.000Z",
        "destroyTime": null
    },
    {
        "id": 199,
        "email": "2714351312@qq.com",
        "title": "demo",
        "content": "> 有一点内容哦,但是不多撒飞洒发撒阿萨德",
        "states": "1",
        "description": null,
        "praise": "4",
        "view": "150",
        "audit": "1",
        "tag1": "不存在的tag1",
        "tag2": "存在的tag2",
        "tag3": "没用的tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "2",
        "diggCount": null,
        "articleType": null,
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-07-07T02:11:58.000Z",
        "destroyTime": "2023-05-15T08:38:05.000Z"
    },
    {
        "id": 200,
        "email": "2714351312@qq.com",
        "title": "android中gradle下载失败",
        "content": "> hello world!\n\ntype you first line code\n",
        "states": "1",
        "description": null,
        "praise": "7",
        "view": "46",
        "audit": "1",
        "tag1": "android",
        "tag2": "note",
        "tag3": "android studio",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "2",
        "diggCount": null,
        "articleType": null,
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-11T17:08:48.000Z",
        "destroyTime": null
    },
    {
        "id": 201,
        "email": "2714351312@qq.com",
        "title": "kotlin笔记",
        "content": "#### kotlin的跨平台特性\n\n不仅像java一样支持javaJava虚拟机跨平台,也支持生成二进制代码跨平台\n\n#### kotlin必知必会\n\n- 为什么要优先使用kotlin进行android开发\n- google宣布kotlin-first意味着什么\n- 有哪些人都在使用kotlin\n- kotlin十问\n- kotlin必知必会的7打模块--本章课程体系介绍\n\n#### kotlin是什么\n\nkotlin是一门用于现代多平台应用的静态编程语言,其中被广泛用于android平台的开发,被称之为android世界的swift,它由jetbrains公司设计开发并开源,著名的ide工具idea就是他们的产品,所以无疑他们是对编程语言设计领域最为熟悉的专家\n\n##### kotlin的优点\n\n- 富有表现力且简介:\n> 可以使用更少的代码实现更多的功能,少编写样板代码,在使用kotlin的专业开发者中,有67%的人反映其工作效率有所提高\n- 更安全的代码:\n> kotlin有许多语言功能,可帮助避免null指针异常等等常见编程错误,包含kotlin代码的android应用发生崩溃的可能性降低了20%\n- 可交互操作:\n> 可以在kotlin代码中调用java代码,或者在java代码中调用kotlin代码,kotlin可完全与java编程语言互操作,因此可以根据需要在项目中添加任意数量的kotlin代码\n- 结构化并发:\n> kotlin协程让异步代码像阻塞代码一样易用,协程可大幅简化后台任务管理,例如网络调用,本地数据访问等任务的管理\n\n##### kotlin优先意味着什么\n\n在构建新的android开发工具和内容(例如jetPack库,示例,文档和培训内容)时,google会在设计层面考虑到kotlin用户\n| | java语言 | kotlin语言 |\n|-|-|-|\n|平台SDK支持|是|是|\n|Lint|是|是|\n|--引导式文档支持|是|是|\n|API文档支持|是|是|\n|androidX kotlin特有api(KTX,协程等)|无|是|\n|示例|是|是|\n|多平台项目|否|是|\n|jetpack compose|否|是|\n\n#### kotlin基本数据类型\n\n- 基本数据类型\n- 浮点类型\n- 字符类型\n- 字符串类型\n- 类型强制转换\n- 数字运算\n\n> 基本数据类型\n\n| 类型   | 位宽度 |\n| :----- | :----: |\n| Double |   64   |\n| Float  |   32   |\n| Long   |   64   |\n| Int    |   32   |\n| Short  |   16   |\n| Byte   |   8    |\n\n##### 快速开始写第一个kotlin程序:\n\n在android studio中直接新建kotlin语言的空项目,\n\n`project`选项卡中切换为`Android`tab栏:\n\n我这里的项目名为`firstapp`\n\n![image-20230427151206035](./images/image-20230427151206035.png)\n\n右键,新建一个package,这里我新建的package为lesson,lesson右键,新建kotlin文件:\n\n![image-20230427151553495](./images/image-20230427151553495.png)\n\n###### 创建主函数\n\n快捷键:`psvm`\n\n```kotlin\npackage com.example.firstapp.lesson\n\n// 快捷键:psvm快速创建一个main方法\nfun main() {\n\n}\n```\n\n###### 定义变量\n\n```kotlin\npackage com.example.firstapp.lesson\n\n// 快捷键:psvm快速创建一个main方法\nfun main() {\n    // 编辑器会根据赋值,自动推断num的数据类型为int\n    // 如果超过了int的取值范围,则会自动推断为Long\n    val num = 100;\n    // 在变量的后面加上 : 加上 数据类型\n    val bateNum: Byte = 1;\n    val flotNum: Float = 3.141568421325F;\n    val doubleNum: Double = 30.2561111132;\n    // float数据类型,如果赋值超过了精度,会四舍五入,最多保留小数点后6位\n    // double最多保留小数点后16位\n    println(num)\n    println(\"flotNum:\")\n    println(flotNum)\n    println(\"doubleNum:\")\n    println(doubleNum)\n}\n```\n\n##### 字符类型\n\n```kotlin\n// 赋值的时候用单引号引起来\n    val char: Char = 'z';\n```\n\n##### boolean类型\n\n```kotlin\n// boolean类型\n    val booleanConst: Boolean = true\n    // 或者直接赋值\n    val booleanConst2=false;\n```\n\n##### 字符串类型:\n\n```kotlin\n// 字符串类型\n// 从0开始\n    val str: String = \"123456786\"\n    val strNum: Char = str[1];\n    println(\"strNum\")\n    println(strNum)\n```\n\n##### 字符串模板\n\n```kotlin\n// 字符串模板\n    println(\"-----------------\");\n    val number = 100;\n// 字符串的模板表达式,以$开始\n    println(\"the result is $number\");\n// 或者用${}括起来的表达式\n    val testStr:String=\"this is a test string\";\n    println(\"testStr's length is ${testStr.length}\")\n// 字符串与转义字符串内部都支持模板,如果你需要在原始模板字符串中表示字面量$字符串(它不支持反斜杠转义),你可以用下列语法:\n    val price=\"${'$'}9.9\";\n    println(\"price is $price\");\n// 和java一样,kotlin可以用 + 操作符连接字符串,这也适用于连接字符串与其他类型的值\n    val age=28;\n    println(\"i am \"+ age +\" years old!\");\n    println(\"i am $age years old!\")\n```\n\n#### 字符串的值\n\n###### \\n 换行\n\n```kotlin\n// \\n 换行\nval s = \"hello world!\\n\";\nprintln(s)\n```\n\nrun:\n\n```shell\nhello world!\n\n\nProcess finished with exit code 0\n```\n\n##### \\反斜杠对\"\"进行转义,保留字符串格式\n\n```kotlin\nval s2 = \"{\\\"key\\\":\\\"calue\\\"}\"\nprintln(s2)\n```\n\nrun:\n\n```shell\n{\"key\":\"calue\"}\n\nProcess finished with exit code 0\n```\n\n##### 使用 \"\"\" 包裹直接输出\n\n```kotlin\n    val text = \"\"\"\n        for (c in \"foo\")\n        print(c)\n    \"\"\";\n    println(text)\n```\n\nrun:\n\n```shel\n\n        for (c in \"foo\")\n        print(c)\n    \n\nProcess finished with exit code 0\n```\n\n#### 类型转换\n\n```kotlin\n// 声明一个整形\n    val number100: Int = 109955620;\n    println(\"转换为string${number100.toString()}\")\n```\n\nrun:\n\n```shell\n转换为string109955620\n\n\nProcess finished with exit code 0\n```\n\n#### 运算\n\n```kotlin\n    println(\"运算\")\n// 整数相除还是会得到整数\n    println(\"3/2:${3 / 2}\")\n// double相除才会有小数点后面的\n    println(\"3.0/2:${3.0 / 2}\")\n    println(\"3/2.0:${3 / 2.0}\")\n    println(\"相乘\")\n    println(\"3*2:${3 * 2}\")\n    println(\"3.0*2:${3.0 * 2}\")\n    println(\"3*2.0:${3 * 2.0}\")\n\n// 与操作\n    println(\"与操作\")\n    val flag1: Boolean = true;\n    val flag2: Boolean = false;\n    println(\"flag1.and(flag2):${flag1.and(flag2)}\")\n    println(\"有一个为true即为true\")\n    println(\"flag1.or(flag2):${flag1.or(flag2)}\")\n// 按位操作符,得了,目前用不上,太麻烦了\n```\n\n- double相除才会有小数点后面的\n\nrun:\n\n```shell\n运算\n3/2:1\n3.0/2:1.5\n3/2.0:1.5\n相乘\n3*2:6\n3.0*2:6.0\n3*2.0:6.0\n与操作\nflag1.and(flag2):false\n有一个为true即为true\nflag1.or(flag2):true\n\nProcess finished with exit code 0\n```\n\n#### kotlin数据容器\n\n> 容器用于存放数据的载体.容器分为数组,集合\n\n- kotlin数组\n- kotlin集合\n\n#### kotlin数组\n\n数组是一种初始化是指定容器大小,不可以动态调整期大小的容器,元素按顺序存储在一串连续的内存段上\n\n##### kotlin数组创建技巧\n\n> 数组中元素可以使任意类型\n\n```kotlin\n    val array1 = arrayOf(1, 2, 3, 45, 6);\n// 数组中元素可以使任意类型\n    val array2 = arrayOf(1, true, \"635\")\n    println(array1)\n    println(array2)\n```\n\n> 创建一个指定大小,所有元素都为空的数组,但必须指定集合中的元素类型\n\n```kotlin\n// 创建一个指定大小,所有元素都为空的数组,但必须指定集合中的元素类型\n    val array3:Array<String?> = arrayOfNulls<String>(5);\n    array3[0]=\"你好\";\n    array3[1]=\"你bu好\";\n    array3[2]=\"fuck you!\";\n    array3[3]=null;\n    println(\"array3:\")\n    println(array3)\n```\n\n> 用接收数组大小以及一个方法参数的Array构造方法,用作参数的方法能够返回给定索引的每个元素初始值:\n\n```kotlin\n// 用接收数组大小以及一个方法参数的Array构造方法,用作参数的方法能够返回给定索引的每个元素初始值:\n    val asc = Array(5) { i -> (i * i).toString() }\n    asc.forEach { println(it) }\n```\n\nrun:\n\n```shell\n0\n1\n4\n9\n16\n```\n\n##### 原生类型数组\n\n> Kotlin 也有无装箱开销的类来表示原生类型数组: `ByteArray`、 `ShortArray`、`IntArray` 等等。这些类与 `Array` 并没有继承关系，但是它们有同样的方法属性集。它们也都有相应的工厂方法\n\n- 直接指定存入的数组:\n\n```kotlin\nval x: IntArray = intArrayOf(1, 2, 3)\n    x[0] = x[1] + x[2]\n    println(\"x[0]\")\n    println(x[0])\n```\n\nrun:\n\n```shell\nx[0]\n5\n\nProcess finished with exit code 0\n```\n\n```kotlin\n\t// 大小为 5、值为 [0, 0, 0, 0, 0] 的整型数组\n\tval arr = IntArray(5)\n\tprintln(\"arr\")\n\tarr.forEach { println(it) }\n\n\t// 用常量初始化数组中的值的示例\n\t// 大小为 5、值为 [42, 42, 42, 42, 42] 的整型数组\n\tval arr2 = IntArray(5) { 42 }\n\tprintln(\"arr2\")\n\tarr2.forEach { println(it) }\n\t\n\n\t// 使用 lambda 表达式初始化数组中的值的示例\n\t// 大小为 5、值为 [0, 1, 2, 3, 4] 的整型数组（值初始化为其索引值）\n\tvar arr3 = IntArray(5) { it * 1 }\n\tprintln(\"arr3\")\n\tarr3.forEach { println(it) }\n```\n\nrun:\n\n```shell\narr\n0\n0\n0\n0\n0\narr2\n42\n42\n42\n42\n42\narr3\n0\n1\n2\n3\n4\n\nProcess finished with exit code 0\n```\n\n##### 遍历\n\n```kotlin\nvar arr3 = IntArray(5) { it * 1 }\n\tarr3.forEach { println(it) }\n\tprintln(\"遍历:\")\n\tfor (item in arr3){\n\t\tprintln(item)\n\t}\n```\n\nrun:\n\n```shell\n遍历:\n0\n1\n2\n3\n4\n\nProcess finished with exit code 0\n```\n\n####### 下标遍历\n\n```kotlin\nprintln(\"下标遍历\")\n\tval arr4: IntArray = intArrayOf(1, 2, 6541, 546, 1651, 1351)\n\tfor (i in arr4.indices) {\n\t\tprintln(i.toString() + \"->\" + arr4[i])\n\t}\n```\n\nrun:\n\n```shell\n下标遍历\n0->1\n1->2\n2->6541\n3->546\n4->1651\n5->1351\n\nProcess finished with exit code 0\n```\n\n####### 带索引与元素的遍历\n\n```kotlin\nprintln(\"带索引同时带元素的遍历:\")\n\tfor ((index, item) in arr4.withIndex()) {\n\t\tprintln(\"${index}->${item}\")\n\t}\n```\n\nrun:\n\n```shell\n带索引同时带元素的遍历:\n0->1\n1->2\n2->6541\n3->546\n4->1651\n5->1351\n\nProcess finished with exit code 0\n```\n\n####### forEach的增强版\n\n```kotlin\nval arr4: IntArray = intArrayOf(1, 2, 6541, 546, 1651, 1351)\nprint(\"froEach增强版\")\n\tarr4.forEachIndexed { index, item ->\n\t\tprintln(\"index:${index}->item:${item}\")\n\t}\n```\n\nrun\n\n```shell\nfroEach增强版index:0->item:1\nindex:1->item:2\nindex:2->item:6541\nindex:3->item:546\nindex:4->item:1651\nindex:5->item:1351\n\nProcess finished with exit code 0\n```\n\n#### 集合\n\n\n>  集合概述\n\nKotlin 标准库提供了一整套用于管理_集合_的工具，集合是可变数量 （可能为零）的一组条目，各种集合对于解决问题都具有重要意义，并且经常用到。\n\n集合是大多数编程语言的常见概念，因此如果熟悉像 Java 或者 Python 语言的集合，那么可以跳过这一介绍转到详细部分。\n\n集合通常包含相同类型的一些（数目也可以为零）对象。集合中的对象称为_元素_或_条目_。例如，一个系的所有学生组成一个集合，可以用于计算他们的平均年龄。\n\n以下是 Kotlin 相关的集合类型：\n\n-   _List_ 是一个有序集合，可通过索引（反映元素位置的整数）访问元素。 元素可以在 list 中出现多次。列表的一个示例是电话号码：有一组数字、这些数字的顺序很重要并且数字可以重复。\n-   _Set_ 是唯一元素的集合。它反映了集合（set）的数学抽象：一组无重复的对象。一般来说 set 中元素的顺序并不重要。例如，the numbers on lottery tickets form a set: they are unique, and their order is not important.\n-   _Map_（或者_字典_）是一组键值对。键是唯一的，每个键都刚好映射到一个值。 值可以重复。map 对于存储对象之间的逻辑连接非常有用，例如，员工的 ID 与员工的位置。\n\nKotlin 让你可以独立于所存储对象的确切类型来操作集合。换句话说，将 `String` 添加到 `String` list 中的方式与添加 `Int` 或者用户自定义类的到相应 list 中的方式相同。 因此，Kotlin 标准库为创建、填充、管理任何类型的集合提供了泛型的（通用的，双关）接口、类与函数。\n\n这些集合接口与相关函数位于 `kotlin.collections` 包中。我们来大致了解下其内容。\n\n#####  集合类型\n\n集合对于解决问题都具有重要意义,并且经常用到,与数组不同的是,可变集合的大小可以动态改变\n\nkotlin下集合分为三类:\n\n- List 是一个有序列表,可以通过索引(下标)访问元素,与数组不同的是可变集合的大小可以动态改变\n- Set 是唯一元素的集合,一组无重复的对象,一般来说set中元素的顺序并不重要,无序集合\n- Map (字典)是一组键值对,键是唯一的,每个键都刚好映射到一个值,值可以重复\n\n##### 集合创建技巧\n\n> 集合分为可变集合,显而易见,是指集合创建完成之后,可以对集合进行增删改查操作\n\n> 不可变集合,是指集合创建完成之后,不能对集合进行增删改查操作,会报异常\n\n##### 集合创建方式\n\n###### 可变集合\n\n- 必须指定元素类型\n\n> ListOf\n\n```kotlin\n    println(\"使用 mutableListOf 创建\")  \n  \n   // 这里也可以不传参,在后续操作中动态添加  \n   val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\")  \n   numbers.add(\"five\")   // 这是可以的  \n\t// 指定位置添加元素:  \n   numbers.add(2, \"二号位\")\n\tprintln(numbers)  \n\tprintln(\"使用 arrayListOf 创建\")  \n\tval num = arrayListOf<String>(\"demo\", \"array\", \"fuckkkkkkkkkkkkkkkkkkkk\", \"demoooooooooo\")  \n\tprintln(num)\n```\n\nrun:\n```shell\n创建可变集合\n使用 mutableListOf 创建\n[one, two, 二号位, three, four, five]\n\nProcess finished with exit code 0\n```\n\n注意:\n- 更改可变集合不需要它是以 [`var`](https://book.kotlincn.net/text/basic-syntax.html#%E5%8F%98%E9%87%8F) 定义的变量：写操作修改同一个可变集合对象，因此引用不会改变。 但是，如果尝试对 `val` 集合重新赋值，你将收到编译错误\n\nsuch as:\n```kotlin\n    val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\")  \n  \n   //numbers = mutableListOf(\"six\", \"seven\")      // 编译错误\n```\n\n> MapOf\n\n创建一个MapOf\n```kotlin\n   val array = mutableMapOf(Pair(\"key\", \"一个value\"));  \n   println(array)\n```\nrun:\n```shell\n{key=一个value}\n\nProcess finished with exit code 0\n```\n\n初始化时不传参:\n```kotlin\nval array3 = mutableMapOf<String, String>();;  \narray3[\"0\"] = \"zero\";  \narray3[\"1\"] = \"one first\";  \narray3[\"2\"] = \"second\";  \narray3[\"3\"] = \"second\";  \narray3[\"3\"] = \"third\";  \nprintln(\"array3:\")  \nprintln(array3)\n```\nrun:\n```shell\narray3:\n{0=zero, 1=one first, 2=second, 3=third}\n\nProcess finished with exit code 0\n```\n\n注意\n- 这里的`array3[\"3\"]`覆盖了前一个的value\n- 不同的key可以有不同的value\n\n\n\n\n> SetOf\n创建一个可变set:\n```kotlin\nval set1 = mutableSetOf<String>()  \n   set1.add(\"132\");  \n// 下面这个添加不进去  \n   set1.add(\"132\");  \n   set1.add(\"2\");  \n   set1.add(\"3\");  \n   set1.add(\"4\");  \n   println(\"set1\")  \n   println(set1)\n```\n\nrun:\n```shell\nset1\n[132, 2, 3, 4]\n\n\nProcess finished with exit code 0\n```\n\n\n使用arraySetOf 创建的set2:\n\n```kotlin\nval set2 = arraySetOf<String>(\"阜成门骚粉\", \"asasfsad\", \"safasfa\", \"地方大法师\")  \nprintln(\"使用arraySetOf 创建的set2:\")\n```\nrun:\n```shell\n使用arraySetOf 创建的set2:\n{asasfsad, 地方大法师, safasfa, 阜成门骚粉}\n\nProcess finished with exit code 0\n```\n\n\nset的遍历:\n```kotlin\n    val set1 = mutableSetOf<String>()  \n   set1.add(\"132\");  \n// 下面这个添加不进去  \n   set1.add(\"132\");  \n   set1.add(\"2\");  \n   set1.add(\"3\");  \n   set1.add(\"3\");  \n   set1.add(\"4\"); \n   for (item in set1) {  \n      println(item)  \n   }\n```\nrun:\n```shell\n132\n2\n3\n4\n\nProcess finished with exit code 0\n```\n\n注意:\n- set中重复的元素是添加不进去的\n\n\n###### 不可变集合\n\n- 必须指定元素类型  \n- 必须指定初始化数据元素\n\n> ListOf\n\n\n```kotlin\nval numbers2 = listOf<String>(\"你好\", \"fuck you\", \"demo\")  \nprintln(\"numbers2;\")  \nprintln(numbers2)  \n// 编译错误  \n// numbers2.add(\"in\")\n```\n\n\n> mapOf\n\n创建不可变的Map集合\n```kotlin\nval array4 = mapOf<String, String>(Pair(\"nihao\", \"这个是个tag\"))  \nprintln(\"array4;\")  \nprintln(array4)\n```\n\nrun:\n```shell\narray4;\n{nihao=这个是个tag}\n\nProcess finished with exit code 0\n```\n\n当然,你也可以使用to来创建一个mapOf:\n```kotlin\nval numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key4\" to 1)  \nprintln(\"numbersMap;\")  \nprintln(numbersMap)\n```\nrun:\n```shell\nnumbersMap;\n{key1=1, key2=2, key3=3, key4=1}\n\nProcess finished with exit code 0\n```\n注意\n- `to` 符号创建了一个短时存活的 `Pair` 对象,因此建议仅在性能不重要时才使用它,为避免过多的内存使用，请使用其他方法。例如，可以创建可写 Map 并使用写入操作填充它。 [`apply()`](https://book.kotlincn.net/text/scope-functions.html#apply) 函数可以帮助保持初始化流畅。\n例如:\n```kotlin\nprintln(\"---使用apply来创建:\")  \nval numbersMap2 = mutableMapOf<String, String>().apply { this[\"one\"] = \"1\"; this[\"two\"] = \"2\" }  \nprintln(\"numbersMap2:\")  \nprintln(numbersMap2)\n```\nrun:\n```shell\n---使用apply来创建:\nnumbersMap2:\n{one=1, two=2}\n\nProcess finished with exit code 0\n```\n\n\n\n> setOf\n\n创建一个不可变的set:\n```kotlin\nval set3 = setOf<String>(\"不可变\", \"nosadsadsa\", \"sasadsdsa\")  \nprintln(set3)\n```\n\nrun:\n```shell\n[不可变, nosadsadsa, sasadsdsa]\n\nProcess finished with exit code 0\n```\n\n\n##### 一些常用操作:\n\n###### isEmpty\n> 是否为空,返回一个boolean\n\n```kotlin\n    val arr1 = mutableListOf<String>(\"fuck\", \"attribute\", \"6\", \"null\")  \n// 是否为空,返回一个boolean  \n   println(\"arr1.isEmpty()\")  \n   println(arr1.isEmpty())\n```\n\nrun:\n```shell\narr1.isEmpty()\nfalse\n\nProcess finished with exit code 0\n```\n\n###### contains\n\n> 判断是否包含某一个元素,返回boolean\n\n```kotlin\nval arr1 = mutableListOf<String>(\"fuck\", \"attribute\", \"6\", \"null\")\nprintln(\"arr1.contains(\" + 6 + \"):\")  \nprintln(arr1.contains(\"6\"))\n```\n\nrun:\n```shell\narr1.contains(6):\ntrue\n\nProcess finished with exit code 0\n```\n\n> indexOf,lastIndexOf\n\n```kotlin\nval arr1 = mutableListOf<String>(\"fuck\", \"attribute\", \"6\", \"null\")\nprintln(\"arr1.indexOf(\\\"6\\\"):${arr1.indexOf(\"6\")}\")  \nprintln(\"arr1.lastIndexOf(\\\"6\\\"):${arr1.lastIndexOf(\"6\")}\")\n```\nrun:\n```shell\narr1.indexOf(\"6\"):2\narr1.lastIndexOf(\"6\"):2\n\nProcess finished with exit code 0\n```\n\n> iterator\n\n```kotlin\nval arr1 = mutableListOf<String>(\"fuck\", \"attribute\", \"6\", \"null\")\nprintln(\"通过迭代器迭代:\")  \nval iterator = arr1.iterator();  \niterator.forEach { it ->  \n   println(\"it:${it}\")  \n}\n```\nrun:\n```shell\n通过迭代器迭代:\nit:fuck\nit:attribute\nit:6\nit:null\n\nProcess finished with exit code 0\n```\n\n###### clear\n> 清空元素\n```kotlin\nval arr1 = mutableListOf<String>(\"fuck\", \"attribute\", \"6\", \"null\")\nprintln(\"清空元素\")  \narr1.clear();  \nprintln(\"arr1.isEmpty():${arr1.isEmpty()}\")\n```\nrun:\n```shell\n清空元素\narr1.isEmpty():true\n\nProcess finished with exit code 0\n```\n\n> 注意\n\n- 在集合中想要修改某个元素,可以这样写:`ar1[0]=\"0\"`\n\n###### add\n> 在指定index插入指定元素:\n\n```kotlin\nval arr1 = mutableListOf<String>(\"fuck\", \"attribute\", \"6\", \"null\")\narr1.clear();\narr1.add(0, \"6\")  \nprintln(\"arr1使用add之后:\")  \nprintln(arr1)\n```\nrun:\n```shell\narr1使用add之后:\n[6]\n\nProcess finished with exit code 0\n```\n\n###### removeAt\n> 移除指定index的元素\n\n```kotlin\nval arr1 = mutableListOf<String>(\"fuck\", \"attribute\", \"6\", \"null\")\nprintln(\"使用removeAt移除指定元素\")\narr1.removeAt(0)  \nprintln(\"arr1.isEmpty():${arr1.isEmpty()}\")\n```\nrun:\n```shell\n使用removeAt移除指定元素\n[fuck, attribute, 6, null]\n\nProcess finished with exit code 0\n```\n\n###### reverse\n> 翻转\n\n```kotlin\nval arr1 = mutableListOf<String>(\"fuck\", \"attribute\", \"6\", \"null\")\nprintln(\"翻转\")  \narr1.reverse()  \nprintln(arr1)\n```\nrun;\n```shell\n翻转\n[null, 6, attribute, fuck]\n\nProcess finished with exit code 0\n```\n\n\n###### shuffle\n> 随机排列元素\n\n```kotlin\nval arr2 = mutableListOf<String>(\"fuck\", \"attribute\", \"6\", \"null\")  \nprintln(\"随机排列元素\")  \narr2.shuffle()  \nprintln(arr2)\n```\n\nrun:\n```shell\n随机排列元素\n[fuck, null, attribute, 6]\n\nProcess finished with exit code 0\n```\n\n###### sort\n> 排序\n\n```kotlin\nval arr3 = mutableListOf<Int>(5, 8, 46, 952, 1329, 54)  \narr3.sort()  \nprintln(arr3)\n```\nrun:\n```shell\n[5, 8, 46, 54, 952, 1329]\n\nProcess finished with exit code 0\n```\n\n#### kotlin的函数和lambda表达式\n\n##### 函数\n\n> Kotlin 函数使用 `fun` 关键字声明\n\n```kotlin\nfun double(x: Int): Int {  \n   return 2 * x  \n}  \nprintln(double(8))\n```\nrun;\n```shell\n16\n\nProcess finished with exit code 0\n```\n> 调用成员函数使用点表示法\n\n```kotlin\n// 方法  \nclass Function {  \n   fun demo(x: Int): Int {  \n      return x * 99  \n   }  \n}  \n  \nfun main() {  \n   println(\"调用成员函数:\")  \n   val demo = com.example.firstapp.lesson.Function();  \n   println(demo.demo(10))  \n}\n```\nrun:\n```shell\n调用成员函数:\n990\n\nProcess finished with exit code 0\n```\n\n###### 参数\n\n> 函数参数使用 Pascal 表示法定义——_name_: _type_。参数用逗号隔开， 每个参数必须有显式类型\n```kotlin\nfun powerOf(obj: String, someThing: String = \"power\"): String {  \n   return \"$obj need more $someThing\"  \n}  \n  \nprintln(powerOf(\"I\"))\n```\nrun:\n```shell\nI need more power\n\nProcess finished with exit code 0\n```\n\n###### 默认参数\n\n函数参数可以有默认值，当省略相应的参数时使用默认值。这可以减少重载数量：\n\n```kotlin\nfun powerOf(obj: String, someThing: String = \"power\"): String {  \n   return \"$obj need more $someThing\"  \n}  \n  \nprintln(powerOf(\"I\"))\n```\nrun:\n```shell\nI need more power\n\nProcess finished with exit code 0\n```\n\n###### 普通类和静态类的方法\n普通类调用其方法需要创建一个实例,通过实例调用它的方法\n```kotlin\n// 方法  \nclass Function {  \n   fun demo(x: Int): Int {  \n      return x * 99  \n   }  \n}  \n  \nfun main() {  \n   println(\"调用成员函数:\")  \n   val demo = com.example.firstapp.lesson.Function();  \n   println(demo.demo(10))  \n}\n```\n静态类无需创建实例,可以直接调用它的方法:\n使用`object`关键字来创建\n```kotlin\n// 下面这个是静态类:  \nobject st {  \n   fun print(x: String): String {  \n      return \"$x i need more power!\"   }  \n}\n  \nfun main() {  \n   println(\"静态方法:\")  \n   println(st.print(\"你好\"))  \n}\n```\nrun:\n```shell\n静态方法:\n你好 i need more power!\n\nProcess finished with exit code 0\n```\n\n> 覆盖方法总是使用与基类型方法的默认参数值。 当覆盖一个有默认参数值的方法时，必须从签名中省略默认参数值`\n\n```kotlin\nopen class A {  \n   open fun foo(i: Int = 10) {  \n      println(\"这是A中的foo\")  \n   }  \n}  \n  \nclass B : A() {  \n   override fun foo(i: Int) {  \n      println(\"这是B中的foo 传来的参数: $i\")  \n   }  // 不能有默认值。  \n}\nfun main() {\n    println(\"---覆盖方法\")  \n   val bDemo=B();  \n// 不传参  \n   bDemo.foo()  \n// 传参  \n   bDemo.foo(153)\n}\n```\nrun:\n```shell\n---覆盖方法\n这是B中的foo 传来的参数: 10\n这是B中的foo 传来的参数: 153\n\nProcess finished with exit code 0\n```\n\n###### 具名参数\n\n> 如果一个默认参数在一个无默认值的参数之前，那么该默认值只能通过使用[具名参数](https://book.kotlincn.net/text/functions.html#%E5%85%B7%E5%90%8D%E5%8F%82%E6%95%B0)调用该函数来使用\n\n```kotlin\nprintln(\"---具名参数\")  \nfun foo(  \n   bar: Int = 0,  \n   baz: Int,  \n) { /*……*/  \n   println(\"bar:$bar,baz:$baz\")  \n}  \n  \nfoo(baz = 1) // 使用默认值 bar = 0\n```\nrun:\n```shell\n---具名参数\nbar:0,baz:1\n\nProcess finished with exit code 0\n```\n\n> 如果在默认参数之后的最后一个参数是 [lambda 表达式](https://book.kotlincn.net/text/lambdas.html#lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95)，那么它既可以作为具名参数在括号内传入，也可以在[括号外](https://book.kotlincn.net/text/lambdas.html#%E4%BC%A0%E9%80%92%E6%9C%AB%E5%B0%BE%E7%9A%84-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F)传入\n\n```kotlin\nfun foo(  \n   bar: Int = 0,  \n   baz: Int = 1,  \n   qux: () -> Unit,  \n) {  \n   println(\"bar:$bar,baz:$baz\")  \n   println(\"qux:\")  \n   qux()  \n  \n}  \n  \nfoo(1) { println(\"hello\") }     // 使用默认值 baz = 1foo(qux = { println(\"hello\") }) // 使用两个默认值 bar = 0 与 baz = 1foo { println(\"hello\") }        // 使用两个默认值 bar = 0 与 baz = 1\n```\n\nrun:\n```shell\nbar:1,baz:1\nqux:\nhello\nbar:0,baz:1\nqux:\nhello\nbar:0,baz:1\nqux:\nhello\n\nProcess finished with exit code 0\n```\n\n注意;\n- 如果参数类型是() 说明该参数是一个方法类型\n- 方法参数的返回值使用 -> String\n- 方法体的最后一行就是该方法的返回值\n\n###### 可变数量的参数（varargs）\n\n>函数的参数（通常是最后一个）可以用 `vararg` 修饰符标记\n\n```kotlin\nfun <T> asList(vararg ts: T): List<T> {  \n   val result = ArrayList<T>()  \n   for (t in ts) // ts is an Array  \n      result.add(t)  \n   return result  \n}  \n  \nval arr = asList(\"你好\", \"大意了\")  \nprintln(arr)\n```\nrun:\n```shell\n[你好, 大意了]\n\nProcess finished with exit code 0\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
        "states": "1",
        "description": "kotlin的学习笔记",
        "praise": "4",
        "view": "550",
        "audit": "1",
        "tag1": "kotlin",
        "tag2": "android",
        "tag3": "android studio",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "2",
        "diggCount": null,
        "articleType": null,
        "recommendLevel": "",
        "createdAt": "2023-04-27T07:57:48.000Z",
        "updatedAt": "2023-05-12T07:08:25.000Z",
        "destroyTime": null
    },
    {
        "id": 202,
        "email": "2714351312@qq.com",
        "title": "demo_0222222222",
        "content": "文章内容",
        "states": "1",
        "description": null,
        "praise": null,
        "view": "3",
        "audit": "1",
        "tag1": "不存在的tag1",
        "tag2": "存在的tag2",
        "tag3": "没用的tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "2",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-03T06:22:28.000Z",
        "updatedAt": "2023-05-03T06:26:58.000Z",
        "destroyTime": "2023-05-03T06:45:10.000Z"
    },
    {
        "id": 203,
        "email": "2714351312@qq.com",
        "title": "demo",
        "content": "文章内容",
        "states": "1",
        "description": null,
        "praise": null,
        "view": "2",
        "audit": "1",
        "tag1": "不存在的tag1",
        "tag2": "存在的tag2",
        "tag3": "没用的tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "2",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-03T06:25:19.000Z",
        "updatedAt": "2023-05-03T06:26:01.000Z",
        "destroyTime": "2023-05-03T06:45:10.000Z"
    },
    {
        "id": 204,
        "email": "2714351312@qq.com",
        "title": "demo",
        "content": "> Hello World!\n.>>>new!!!!!!!!!!!!!!!!!!1\n> ceddddddddddddddddddddd",
        "states": "1",
        "description": null,
        "praise": null,
        "view": "2",
        "audit": "1",
        "tag1": "不存在的tag1",
        "tag2": "存在的tag2",
        "tag3": "没用的tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "2",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-03T06:26:06.000Z",
        "updatedAt": "2023-05-03T06:26:59.000Z",
        "destroyTime": "2023-05-03T06:45:10.000Z"
    },
    {
        "id": 205,
        "email": "2714351312@qq.com",
        "title": "demo",
        "content": "1. 必备快捷键\nCtrl+/：注释当前行\nCtrl+Shift+/：当前位置插入注释\nCtrl+Alt+/：块注释，并Focus到首行，写注释说明用的\nCtrl+Shift+A：选择当前标签前后，修改标签用的\nF11：全屏\nShift+F11：全屏免打扰模式，只编辑当前文件\nAlt+F3：选择所有相同的词\nAlt+.：闭合标签\nAlt+Shift+数字：分屏显示\nAlt+数字：切换打开第N个文件\nShift+右键拖动：光标多不，用来更改或插入列内容\n鼠标的前进后退键可切换Tab文件\n按 Ctrl，依次点击或选取，可需要编辑的多个位置\n按 Ctrl+Shift+上下键，可替换行\nCtrl+Shift+P：打开命令面板\nCtrl+P：搜索项目中的文件\nCtrl+G：跳转到第几行\nCtrl+W：关闭当前打开文件\nCtrl+Shift+W：关闭所有打开文件",
        "states": "1",
        "description": null,
        "praise": null,
        "view": "3",
        "audit": "1",
        "tag1": "不存在的tag1",
        "tag2": "存在的tag2",
        "tag3": "没用的tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "2",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-03T06:33:36.000Z",
        "updatedAt": "2023-05-03T06:34:31.000Z",
        "destroyTime": "2023-05-03T06:45:10.000Z"
    },
    {
        "id": 206,
        "email": "2714351312@qq.com",
        "title": "demo",
        "content": "1. 必备快捷键  \nCtrl+/：注释当前行  \nCtrl+Shift+/：当前位置插入注释  \nCtrl+Alt+/：块注释，并Focus到首行，写注释说明用的  \nCtrl+Shift+A：选择当前标签前后，修改标签用的  \nF11：全屏  \nShift+F11：全屏免打扰模式，只编辑当前文件  \nAlt+F3：选择所有相同的词  \nAlt+.：闭合标签  \nAlt+Shift+数字：分屏显示   \nAlt+数字：切换打开第N个文件  \nShift+右键拖动：光标多不，用来更改或插入列内容  \n鼠标的前进后退键可切换Tab文件  \n按 Ctrl，依次点击或选取，可需要编辑的多个位置  \n按 Ctrl+Shift+上下键，可替换行  \nCtrl+Shift+P：打开命令面板  \nCtrl+P：搜索项目中的文件  \nCtrl+G：跳转到第几行  \nCtrl+W：关闭当前打开文件\nCtrl+Shift+W：关闭所有打开文件",
        "states": "1",
        "description": null,
        "praise": null,
        "view": "7",
        "audit": "1",
        "tag1": "不存在的tag1",
        "tag2": "存在的tag2",
        "tag3": "没用的tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "2",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-03T06:34:21.000Z",
        "updatedAt": "2023-05-03T06:46:44.000Z",
        "destroyTime": "2023-05-03T06:45:10.000Z"
    },
    {
        "id": 207,
        "email": "2714351312@qq.com",
        "title": "demo",
        "content": "> Hello World!",
        "states": "1",
        "description": null,
        "praise": null,
        "view": "2",
        "audit": "1",
        "tag1": "不存在的tag1",
        "tag2": "存在的tag2",
        "tag3": "没用的tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "2",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-03T06:51:59.000Z",
        "updatedAt": "2023-05-03T06:53:26.000Z",
        "destroyTime": "2023-05-03T06:52:16.000Z"
    },
    {
        "id": 208,
        "email": "2714351312@qq.com",
        "title": "请输入你的标题",
        "content": "> hello world!\n\ntype you first line code\n",
        "states": "1",
        "description": null,
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "测试tag!!!!!!!!!!!",
        "tag2": "",
        "tag3": "",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "2",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-08T03:26:14.000Z",
        "updatedAt": "2023-05-08T03:26:14.000Z",
        "destroyTime": "2023-05-08T03:28:45.000Z"
    },
    {
        "id": 209,
        "email": "2714351312@qq.com",
        "title": "请输入你的标题",
        "content": "> hello world!\n\ntype you first line code\n",
        "states": "1",
        "description": null,
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "测试tag!!!!!!!!!!!",
        "tag2": "",
        "tag3": "",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "2",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-08T03:26:17.000Z",
        "updatedAt": "2023-05-08T03:26:17.000Z",
        "destroyTime": "2023-05-08T03:28:45.000Z"
    },
    {
        "id": 210,
        "email": "2714351312@qq.com",
        "title": "请输入你的标题",
        "content": "> hello world!\n\ntype you first line code\n",
        "states": "1",
        "description": null,
        "praise": null,
        "view": "1",
        "audit": "1",
        "tag1": "",
        "tag2": "",
        "tag3": "",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "2",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-08T03:26:47.000Z",
        "updatedAt": "2023-05-08T03:26:48.000Z",
        "destroyTime": "2023-05-08T03:28:45.000Z"
    },
    {
        "id": 211,
        "email": "2714351312@qq.com",
        "title": "请输入你的标题",
        "content": "> hello world!\n\ntype you first line code\n",
        "states": "1",
        "description": null,
        "praise": null,
        "view": "1",
        "audit": "1",
        "tag1": "测试1",
        "tag2": "测试2",
        "tag3": "测试3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "2",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-08T03:28:04.000Z",
        "updatedAt": "2023-05-08T03:28:06.000Z",
        "destroyTime": "2023-05-08T03:28:45.000Z"
    },
    {
        "id": 212,
        "email": "2714351312@qq.com",
        "title": "kotlin的泛型",
        "content": "\n#### 泛型\n\nKotlin 中的类可以有类型参数，与 Java 类似：\n\n```kotlin\nclass Box<T>(t: T) {\n    var value = t\n}\n```\n\n创建这样类的实例只需提供类型参数即可：\n\n```kotlin\nval box: Box<Int> = Box<Int>(1)\n```\n\n但是如果类型参数可以推断出来，例如从构造函数的参数或者从其他途径， 就可以省略类型参数\n\n##### 泛型接口\n\n```kotlin\nfun main() {\n\tval drinkApple = DrinkApple()\n\tdrinkApple.drink(\"drink\")\n\n}\n\ninterface Drink<T> {\n\tfun drink(t: T)\n}\n\nclass DrinkApple : Drink<String> {\n\toverride fun drink(t: String) {\n\t\tprintln(\"drink:${t}\")\n\t}\n}\n```\n\nrun:\n\n```shell\ndrink:drink\n\nProcess finished with exit code 0\n```\n\n##### 泛型类\n\n```kotlin\nfun main() {\n//\t泛型类\n\tval blueColor = BlueColor(\"blue\");\n\tblueColor.printColor()\n}\n\n// 抽象类\nabstract class Color<T>(val t: T) {\n\tabstract fun printColor()\n}\n\nclass BlueColor(val color: String) : Color<String>(color) {\n\toverride fun printColor() {\n\t\tprintln(\"printColor:$color\")\n\t}\n}\n```\n\nrun:\n\n```shell\nprintColor:blue\n\nProcess finished with exit code 0\n```\n\n#### 泛型方法:\n\n```kotlin\nfun main() {\n//\t泛型方法\n\tfromJson(\"{}\", String::class.java);\n}\n\n// 泛型方法\nfun <T> fromJson(json: String, tClass: Class<T>): T? {\n\tval t: T? = tClass.newInstance();\n\treturn t\n}\n```\n\n##### 泛型约束\n\n```kotlin\nfun main() {\n// 泛型约束\n\tfromJson2(\"{}\", JSONObject::class.java)\n}\n// 泛型约束\n// 所传递的类型T必须满足JSONObject的子类,或JSONObject类\nfun <T : JSONObject> fromJson2(json: String, tClass: Class<T>): T? {\n\tval t: T? = tClass.newInstance();\n\treturn t\n}\n```\n\n##### out,限定泛型的上限\n\n在 Kotlin 中，有一种方法向编译器解释这种情况。这称为*声明处型变*： 可以标注 `Source` 的*类型参数* `T` 来确保它仅从 `Source<T>` 成员中*返回*（生产），并从不被消费。 为此请使用 `out` 修饰符：\n\n```kotlin\ninterface Source<out T> {\n    fun nextT(): T\n}\n\nfun demo(strs: Source<String>) {\n    val objects: Source<Any> = strs // 这个没问题，因为 T 是一个 out-参数\n    // ……\n}\n```\n\n> 在使用处使用out,声明泛型上限\n\n```kotlin\nopen class Animale\nclass DogAnimal : Animale()\n\nclass CatAnimal : Animale()\n\nclass WhiteAnimal : Animale()\nfun animalFuns() {\n\n// kotlin无法进行集合的强制转换,如果要使用,那么可以加上out关键字进行强转\n// val animalList: ArrayList<Animale> = ArrayList<DogAnimal>()\n\n// 这里传入的类型就可以是Animale或Animale的子类\n// 在使用处使用out,声明泛型上限\n\tval animalList: ArrayList<out Animale> = ArrayList<DogAnimal>()\n//但是每次这么写会很麻烦\n\n}\n```\n\n> 在定义处使用out关键字来声明,允许传入的泛型参数可以是T以及T的子类\n\n```kotlin\nopen class Animale\nclass DogAnimal : Animale()\n\nclass CatAnimal : Animale()\n\nclass WhiteAnimal : Animale()\nclass ArrayList<out T> {\n\tval animalList: ArrayList<Animale> = ArrayList<DogAnimal>()\n}\n```\n\n\n\n##### in,约束泛型参数的类型下限\n\n> 在使用处约束\n\n```kotlin\nopen class Animale\nclass DogAnimal : Animale()\nfun animalFuns() {\n\tval animalList2: InArrayList<in DogAnimal> = InArrayList<Animale>()\n}\n```\n\n> 在定义处使用in关键字来声明,允许传入的泛型参数可以是T以及T的父类\n\n```kotlin\nclass InArrayList<in T> {\n}\n```\n",
        "states": "1",
        "description": null,
        "praise": null,
        "view": "24",
        "audit": "1",
        "tag1": "kotlin",
        "tag2": "泛型",
        "tag3": "note",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "2",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-08T06:52:48.000Z",
        "updatedAt": "2023-07-05T06:42:31.000Z",
        "destroyTime": null
    },
    {
        "id": 213,
        "email": "2714351312@qq.com",
        "title": "kotlin的条件与循环",
        "content": "\n#### 条件与循环\n\n\n\n##### if\n\n>  在 Kotlin 中，`if` 是一个表达式：它会返回一个值。 因此就不需要三元运算符（`条件 ? 然后 : 否则`），因为普通的 `if` 就能胜任这个角色。\n\n```kotlin\nval a = 2\n\tval b = 3\n\n\t//sampleStart\n\tvar max = a\n\tif (a < b) max = b\n\n\t// With else\n\tif (a > b) {\n\t\tmax = a\n\t} else {\n\t\tmax = b\n\t}\n\n\t// 作为表达式\n\tmax = if (a > b) a else b\n\n\t// You can also use `else if` in expressions:\n\tval maxLimit = 1\n\tval maxOrLimit = if (maxLimit > a) maxLimit else if (a > b) a else b\n\n\t//sampleEnd\n\tprintln(\"max is $max\")\n\tprintln(\"maxOrLimit is $maxOrLimit\")\n```\n\nrun:\n\n```shell\nmax is 3\nmaxOrLimit is 3\n\nProcess finished with exit code 0\n```\n\n> `if` 表达式的分支可以是代码块，这种情况最后的表达式作为该块的值：\n\n```kotlin\nval a = 2\n\tval b = 3\nval max2 = if (a > b) {\n\t\tprintln(\"Choose a\")\n\t\ta\n\t} else {\n\t\tprintln(\"Choose b\")\n\t\tb\n\t}\n\tprintln(\"max2:$max2\")\n```\n\nrun:\n\n```shell\nChoose b\nmax2:3\n\nProcess finished with exit code 0\n```\n\n##### When 表达式\n\n> `when` 将它的参数与所有的分支条件顺序比较，直到某个分支满足条件。\n\n```kotlin\n\tval x:Int = 5;\n\twhen (x) {\n\t\t1 -> print(\"x == 1\")\n\t\t2 -> print(\"x == 2\")\n\t\telse -> {\n\t\t\tprint(\"x is neither 1 nor 2\")\n\t\t}\n\t}\n```\n\nrun:\n\n```shell\nx is neither 1 nor 2\nProcess finished with exit code 0\n```\n\n`when` 既可以作为表达式使用也可以作为语句使用。如果它被当做表达式， 第一个符合条件的分支的值就是整个表达式的值，如果当做语句使用， 则忽略个别分支的值。 类似于 `if`，每一个分支可以是一个代码块，它的值是块中最后的表达式的值。\n\n如果其他分支都不满足条件将会求值 `else` 分支。 如果 `when` 作为一个*表达式*使用，那么必须有 `else` 分支， 除非编译器能够检测出所有的可能情况都已经覆盖了， 例如，对于 [枚举（`enum`）类](https://book.kotlincn.net/text/enum-classes.html)条目与[密封（`sealed`）类](https://book.kotlincn.net/text/sealed-classes.html)子类型］。\n\n```kotlin\nfun eval2(number: Number): String = when (number) {\n\t\tis Int -> \"this is Int number\"\n\t\tis Double -> \"this is Double\"\n\t\tis Float -> \"this is Float\"\n\t\tis Long -> \"this is Long\"\n\t\tis Byte -> \"this is Byte\"\n\t\tis Short -> \"this is Short\"\n\t\telse -> \"invalid number\"\n\t}\n\tprintln(\"eval2(5):\")\n\tprintln(eval2(5))\n```\n\nrun:\n\n```shell\neval2(5):\nthis is Int number\n\nProcess finished with exit code 0\n```\n\n> when也可以接受动态传参:\n\n```kotlin\nfun getValue(): Any {\n\t\treturn 100\n\t}\n\n\tfun eval3(): String {\n\t\treturn when (val value = getValue()) {\n\t\t\tis Int -> \"this is Int $value\".apply(::println)\n\t\t\tis String -> \"this is String $value\".apply(::println)\n\t\t\tis Double -> \"this is Double $value\".apply(::println)\n\t\t\tis Float -> \"this is Float $value\".apply(::println)\n\t\t\telse -> \"unknown type $value\".apply(::println)\n\t\t}\n\t}\n\teval3()\n```\n\nrun:\n\n```shell\nthis is Int 100\n\nProcess finished with exit code 0\n```",
        "states": "1",
        "description": null,
        "praise": null,
        "view": "14",
        "audit": "1",
        "tag1": "kotlin",
        "tag2": "note",
        "tag3": "条件与循环",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "2",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-08T06:54:10.000Z",
        "updatedAt": "2023-05-12T06:58:45.000Z",
        "destroyTime": null
    },
    {
        "id": 214,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "1",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-08T10:44:43.000Z",
        "updatedAt": "2023-05-26T14:13:36.000Z",
        "destroyTime": null
    },
    {
        "id": 215,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-08T10:56:05.000Z",
        "updatedAt": "2023-05-08T10:56:05.000Z",
        "destroyTime": null
    },
    {
        "id": 216,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-08T10:56:44.000Z",
        "updatedAt": "2023-05-08T10:56:44.000Z",
        "destroyTime": null
    },
    {
        "id": 217,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-08T10:57:37.000Z",
        "updatedAt": "2023-05-08T10:57:37.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 218,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-08T10:57:59.000Z",
        "updatedAt": "2023-05-08T10:57:59.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 219,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-08T10:58:26.000Z",
        "updatedAt": "2023-05-08T10:58:26.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 220,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-08T11:01:05.000Z",
        "updatedAt": "2023-05-08T11:01:05.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 221,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-08T11:09:10.000Z",
        "updatedAt": "2023-05-08T11:09:10.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 222,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-08T11:10:43.000Z",
        "updatedAt": "2023-05-08T11:10:43.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 223,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-08T11:10:54.000Z",
        "updatedAt": "2023-05-08T11:10:54.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 224,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-08T11:11:02.000Z",
        "updatedAt": "2023-05-08T11:11:02.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 225,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-08T11:11:18.000Z",
        "updatedAt": "2023-05-08T11:11:18.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 226,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-08T11:11:23.000Z",
        "updatedAt": "2023-05-08T11:11:23.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 227,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-08T11:12:46.000Z",
        "updatedAt": "2023-05-08T11:12:46.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 228,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-08T11:13:39.000Z",
        "updatedAt": "2023-05-08T11:13:39.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 229,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-08T15:47:58.000Z",
        "updatedAt": "2023-05-08T15:47:58.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 230,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-08T15:48:15.000Z",
        "updatedAt": "2023-05-08T15:48:15.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 231,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-08T15:48:36.000Z",
        "updatedAt": "2023-05-08T15:48:36.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 232,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-08T15:48:51.000Z",
        "updatedAt": "2023-05-08T15:48:51.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 233,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T03:10:37.000Z",
        "updatedAt": "2023-05-09T03:10:37.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 234,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T03:18:05.000Z",
        "updatedAt": "2023-05-09T03:18:05.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 235,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T03:18:15.000Z",
        "updatedAt": "2023-05-09T03:18:15.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 236,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T03:18:18.000Z",
        "updatedAt": "2023-05-09T03:18:18.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 237,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T03:18:33.000Z",
        "updatedAt": "2023-05-09T03:18:33.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 238,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T03:18:47.000Z",
        "updatedAt": "2023-05-09T03:18:47.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 239,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T03:18:59.000Z",
        "updatedAt": "2023-05-09T03:18:59.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 240,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T03:19:34.000Z",
        "updatedAt": "2023-05-09T03:19:34.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 241,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T03:19:56.000Z",
        "updatedAt": "2023-05-09T03:19:56.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 242,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T03:20:10.000Z",
        "updatedAt": "2023-05-09T03:20:10.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 243,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "1",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T03:20:20.000Z",
        "updatedAt": "2023-05-09T06:18:19.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 244,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T06:35:49.000Z",
        "updatedAt": "2023-05-09T06:35:49.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 245,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T06:35:57.000Z",
        "updatedAt": "2023-05-09T06:35:57.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 246,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T06:38:03.000Z",
        "updatedAt": "2023-05-09T06:38:03.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 247,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T06:38:11.000Z",
        "updatedAt": "2023-05-09T06:38:11.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 248,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T06:38:17.000Z",
        "updatedAt": "2023-05-09T06:38:17.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 249,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T06:38:28.000Z",
        "updatedAt": "2023-05-09T06:38:28.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 250,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T06:40:46.000Z",
        "updatedAt": "2023-05-09T06:40:46.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 251,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T06:43:43.000Z",
        "updatedAt": "2023-05-09T06:43:43.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 252,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T06:44:22.000Z",
        "updatedAt": "2023-05-09T06:44:22.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 253,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T06:45:38.000Z",
        "updatedAt": "2023-05-09T06:45:38.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 254,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T06:46:09.000Z",
        "updatedAt": "2023-05-09T06:46:09.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 255,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T06:46:24.000Z",
        "updatedAt": "2023-05-09T06:46:24.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 256,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T06:47:33.000Z",
        "updatedAt": "2023-05-09T06:47:33.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 257,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T06:48:07.000Z",
        "updatedAt": "2023-05-09T06:48:07.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 258,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T06:48:32.000Z",
        "updatedAt": "2023-05-09T06:48:32.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 259,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T06:49:45.000Z",
        "updatedAt": "2023-05-09T06:49:45.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 260,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T06:50:02.000Z",
        "updatedAt": "2023-05-09T06:50:02.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 261,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T06:50:13.000Z",
        "updatedAt": "2023-05-09T06:50:13.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 262,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T06:51:38.000Z",
        "updatedAt": "2023-05-09T06:51:38.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 263,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T06:52:10.000Z",
        "updatedAt": "2023-05-09T06:52:10.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 264,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T06:53:52.000Z",
        "updatedAt": "2023-05-09T06:53:52.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 265,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T06:54:32.000Z",
        "updatedAt": "2023-05-09T06:54:32.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 266,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T06:55:11.000Z",
        "updatedAt": "2023-05-09T06:55:11.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 267,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T06:55:24.000Z",
        "updatedAt": "2023-05-09T06:55:24.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 268,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T06:55:34.000Z",
        "updatedAt": "2023-05-09T06:55:34.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 269,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T06:55:43.000Z",
        "updatedAt": "2023-05-09T06:55:43.000Z",
        "destroyTime": "2023-05-09T10:33:33.000Z"
    },
    {
        "id": 270,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T06:55:53.000Z",
        "updatedAt": "2023-05-09T06:55:53.000Z",
        "destroyTime": "2023-05-09T10:32:36.000Z"
    },
    {
        "id": 271,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T06:56:23.000Z",
        "updatedAt": "2023-05-09T06:56:23.000Z",
        "destroyTime": "2023-05-09T10:32:36.000Z"
    },
    {
        "id": 272,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T06:56:42.000Z",
        "updatedAt": "2023-05-09T06:56:42.000Z",
        "destroyTime": "2023-05-09T10:32:36.000Z"
    },
    {
        "id": 273,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T06:57:09.000Z",
        "updatedAt": "2023-05-09T06:57:09.000Z",
        "destroyTime": "2023-05-09T10:32:36.000Z"
    },
    {
        "id": 274,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T06:57:35.000Z",
        "updatedAt": "2023-05-09T06:57:35.000Z",
        "destroyTime": "2023-05-09T10:32:36.000Z"
    },
    {
        "id": 275,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T06:58:01.000Z",
        "updatedAt": "2023-05-09T06:58:01.000Z",
        "destroyTime": "2023-05-09T10:32:36.000Z"
    },
    {
        "id": 276,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T06:58:18.000Z",
        "updatedAt": "2023-05-09T06:58:18.000Z",
        "destroyTime": "2023-05-09T10:32:36.000Z"
    },
    {
        "id": 277,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T06:58:39.000Z",
        "updatedAt": "2023-05-09T06:58:39.000Z",
        "destroyTime": "2023-05-09T10:32:36.000Z"
    },
    {
        "id": 278,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T06:58:51.000Z",
        "updatedAt": "2023-05-09T06:58:51.000Z",
        "destroyTime": "2023-05-09T10:32:36.000Z"
    },
    {
        "id": 279,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T06:59:28.000Z",
        "updatedAt": "2023-05-09T06:59:28.000Z",
        "destroyTime": "2023-05-09T10:32:36.000Z"
    },
    {
        "id": 280,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T07:00:14.000Z",
        "updatedAt": "2023-05-09T07:00:14.000Z",
        "destroyTime": "2023-05-09T10:32:36.000Z"
    },
    {
        "id": 281,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T07:00:54.000Z",
        "updatedAt": "2023-05-09T07:00:54.000Z",
        "destroyTime": "2023-05-09T10:32:36.000Z"
    },
    {
        "id": 282,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T07:00:56.000Z",
        "updatedAt": "2023-05-09T07:00:56.000Z",
        "destroyTime": "2023-05-09T10:32:36.000Z"
    },
    {
        "id": 283,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T07:02:41.000Z",
        "updatedAt": "2023-05-09T07:02:41.000Z",
        "destroyTime": "2023-05-09T10:32:36.000Z"
    },
    {
        "id": 284,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T07:03:22.000Z",
        "updatedAt": "2023-05-09T07:03:22.000Z",
        "destroyTime": "2023-05-09T10:32:36.000Z"
    },
    {
        "id": 285,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T07:03:29.000Z",
        "updatedAt": "2023-05-09T07:03:29.000Z",
        "destroyTime": "2023-05-09T10:32:36.000Z"
    },
    {
        "id": 286,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T07:06:22.000Z",
        "updatedAt": "2023-05-09T07:06:22.000Z",
        "destroyTime": "2023-05-09T10:32:36.000Z"
    },
    {
        "id": 287,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T07:17:17.000Z",
        "updatedAt": "2023-05-09T07:17:17.000Z",
        "destroyTime": "2023-05-09T10:32:36.000Z"
    },
    {
        "id": 288,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T08:35:02.000Z",
        "updatedAt": "2023-05-09T08:35:02.000Z",
        "destroyTime": "2023-05-09T10:32:36.000Z"
    },
    {
        "id": 289,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T09:02:40.000Z",
        "updatedAt": "2023-05-09T09:02:40.000Z",
        "destroyTime": "2023-05-09T10:31:59.000Z"
    },
    {
        "id": 290,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T09:02:53.000Z",
        "updatedAt": "2023-05-09T09:02:53.000Z",
        "destroyTime": "2023-05-09T10:31:59.000Z"
    },
    {
        "id": 291,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T09:03:38.000Z",
        "updatedAt": "2023-05-09T09:03:38.000Z",
        "destroyTime": "2023-05-09T10:31:59.000Z"
    },
    {
        "id": 292,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T10:20:33.000Z",
        "updatedAt": "2023-05-09T10:20:33.000Z",
        "destroyTime": "2023-05-09T10:31:59.000Z"
    },
    {
        "id": 293,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T10:21:11.000Z",
        "updatedAt": "2023-05-09T10:21:11.000Z",
        "destroyTime": "2023-05-09T10:31:36.000Z"
    },
    {
        "id": 294,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T10:28:36.000Z",
        "updatedAt": "2023-05-09T10:28:36.000Z",
        "destroyTime": "2023-05-09T10:31:36.000Z"
    },
    {
        "id": 295,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T10:29:29.000Z",
        "updatedAt": "2023-05-09T10:29:29.000Z",
        "destroyTime": "2023-05-09T10:31:36.000Z"
    },
    {
        "id": 296,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T10:30:19.000Z",
        "updatedAt": "2023-05-09T10:30:19.000Z",
        "destroyTime": "2023-05-09T10:31:36.000Z"
    },
    {
        "id": 297,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T10:30:45.000Z",
        "updatedAt": "2023-05-09T10:30:45.000Z",
        "destroyTime": "2023-05-09T10:31:59.000Z"
    },
    {
        "id": 298,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T10:31:10.000Z",
        "updatedAt": "2023-05-09T10:31:10.000Z",
        "destroyTime": "2023-05-09T10:31:59.000Z"
    },
    {
        "id": 299,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T10:31:34.000Z",
        "updatedAt": "2023-05-09T10:31:34.000Z",
        "destroyTime": "2023-05-09T10:31:59.000Z"
    },
    {
        "id": 300,
        "email": "adminEmail",
        "title": "Hello World",
        "content": "> hello world!",
        "states": "0",
        "description": "",
        "praise": null,
        "view": "0",
        "audit": "1",
        "tag1": "tag1",
        "tag2": "tag2",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "blog",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T10:31:46.000Z",
        "updatedAt": "2023-05-09T10:31:46.000Z",
        "destroyTime": "2023-05-09T10:31:59.000Z"
    },
    {
        "id": 301,
        "email": "2714351312@qq.com",
        "title": "测试",
        "content": "> hello world!\n\ntype you first line code\n\n> 这个是普通用户测试的\n\n\n\n\nblog文章",
        "states": "1",
        "description": null,
        "praise": null,
        "view": "3",
        "audit": "1",
        "tag1": "测试",
        "tag2": "测试",
        "tag3": "测试",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "2",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T10:36:08.000Z",
        "updatedAt": "2023-05-09T10:53:49.000Z",
        "destroyTime": "2023-05-09T10:36:21.000Z"
    },
    {
        "id": 302,
        "email": "2714351312@qq.com",
        "title": "kotlin扩展",
        "content": "kotlin扩展\n#### 作用\n- 提供架构的易用性\n- 减少代码量,让代码更加简洁,纯粹\n- 提高编码的效率.生产力提高\n\n在kotlin中提供了大量的扩展,使得我们的代码更加简洁,开发出来的框架更加易用\n\nkotlin的扩展函数可以让你作为一个类成员进行调用的函数,这样可以很方便的扩展一个已经存在的类,为它添加额外的方法,在kotlin源码中,有大量的扩展函数来扩展java,这样使得kotlin比java更方便使用,效率更高\n#### 定义一个扩展方法:\n```kotlin\npackage com.example.firstapp.lesson\n\nclass Jump {\n\tfun test() {\n\t\tprintln(\"jump test\")\n// 在扩展类中被使用\n\t\tdoubleJump(1f)\n\t}\n}\n\n// 扩展方法:\nfun Jump.doubleJump(howLong: Float): Boolean {\n\tprintln(\"jump;$howLong\")\n\tprintln(\"jump:$howLong\")\n\treturn true\n}\n\nfun main() {\n\tJump().doubleJump(2f)\n\tJump().test()\n}\n```\n注意,这里的文件名为:`KTExtentions.kt`\n\n##### 在java中引用该kotlin的扩展方法:\n\n```java\npackage com.example.firstapp.lesson;\n\npublic class KTExtentions {\n    public static void main(String[] args) {\n        KTExtentionsKt.doubleJump(new Jump(), 2.0f);\n\n\n    }\n}\n```\n注意,这里的java名为:`KTExtentions`\n\n#### 扩展泛型方法\n\n\n定义一个泛型的扩展方法:\n```kotlin\nfun <T> MutableList<T>.swap(index: Int, index2: Int) {\n\tval temp = this[index];\n\tthis[index] = this[index2];\n\tthis[index2] = temp;\n}\nfun main() {\n\tval list = mutableListOf<Int>(1, 2, 3, 4, 5)\n\tlist.swap(0, 2)\n\n\tfor (i in list) {\n\t\tprintln(\"index ;$i\")\n\t}\n}\n```\nrun:\n```shell\nindex;3\nindex;2\nindex;1\nindex;4\nindex;5\n\nProcess finished with exit code 0\n```\n\n#### 扩展属性\n\n扩展属性提供了一种方法能通过属性语句进行访问的API来扩展,尽管它们被叫做属性,但是他们不能拥有任何状态,它不能添加额外的字段到现有的java对象实例\n```kotlin\nfun main() {\n\tval str = \"android\";\n\tprintln(str.lastChar)\n}\n\nval String.lastChar: Char get() = this.get(length - 1)\n```\nrun:\n```shell\nd\n\nProcess finished with exit code 0\n```\n#### let扩展函数\n\n\n```kotlin\nfun testLet(str: String?) {\n\tstr.let {\n\t\tval str2 = \"android\";\n\t\tprintln(str2 + it)\n\t}\n//\tstr2在外面访问不到\n//\t判空用法,当str为空时,则不会触发闭包里面的逻辑\n\tstr?.let {\n\t\tval str2 = \"android\"\n\t\tprintln(str2 + it)\n\t}\n}\nfun main() {\n\ttestLet(\"anzhuo\")\n}\n``` \nrun:\n```shell\nandroidanzhuo\nandroidanzhuo\n\nProcess finished with exit code 0\n```\n\n#### run\n扩展函数,返回值为最后一行的值,或者指定的return的表达式,在run函数中可以直接访问到实例的共有属性和方法\n```kotlin\nfun testRun(jump: Jump): String {\n\tjump.run {\n\t\ttest()\n\t\tprintln(\"12222222\")\n\t\treturn \"3333333\"\n\t}\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
        "states": "1",
        "description": "kotlin的扩展,笔记之类的东西",
        "praise": null,
        "view": "283",
        "audit": "1",
        "tag1": "kotlin",
        "tag2": "note",
        "tag3": "android",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "2",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T13:00:47.000Z",
        "updatedAt": "2023-06-03T17:54:37.000Z",
        "destroyTime": null
    },
    {
        "id": 303,
        "email": "2714351312@qq.com",
        "title": "kotlin扩展",
        "content": "kotlin扩展\n#### ",
        "states": "1",
        "description": null,
        "praise": null,
        "view": "2",
        "audit": "1",
        "tag1": "kotlin",
        "tag2": "note",
        "tag3": "android",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "2",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-09T13:00:54.000Z",
        "updatedAt": "2023-05-09T13:01:38.000Z",
        "destroyTime": "2023-05-09T13:01:50.000Z"
    },
    {
        "id": 304,
        "email": "2714351312@qq.com",
        "title": "vue的打包优化方案",
        "content": "#### 使用插件去除console\n\n安装一下:\n```shell\ncnpm install uglifyjs-webpack-plugin\n```\n\n`vue.config.js`文件中添加:\n```javascript\n//打包配置自动忽略console.log等\nconst UglifyJsPlugin = require('uglifyjs-webpack-plugin')\n```\n\n`vue.config.js`中添加插件:\n```javascript\n//打包环境去掉console.log等\n            new UglifyJsPlugin({\n                uglifyOptions: {\n                    compress: {\n                        //warnings: false, 注释不然打包会报错如图下图\n                        drop_console: true,  //注释console\n                        drop_debugger: true, //注释debugger\n                        pure_funcs: ['console.log'], //移除console.log\n                    },\n                },\n            })\n```\n`vue.config.js`全部:\n```javascript\nconst {defineConfig} = require('@vue/cli-service')\nconst webpack = require(\"webpack\");\n//打包配置自动忽略console.log等\nconst UglifyJsPlugin = require('uglifyjs-webpack-plugin')\n\nmodule.exports = defineConfig({\n    transpileDependencies: true,\n    //代理\n    devServer: {\n        // 指定项目启动时的默认端口号\n        port: 80,\n        historyApiFallback: true,\n        allowedHosts: 'all',\n        proxy: {\n            '/': {\n                ws: false,\n                // target: \"http://icestone.top:8090\",\n                target: \"http://localhost:89\",\n                changeOrigin: true,\n                pathRewrite: {\n                    '^/': '/'\n                }\n            }\n        },\n        // proxy: 'http://localhost:8090'\n    },\n    configureWebpack: {\n        plugins: [\n            new webpack.ProvidePlugin({\n                $: 'jquery',\n                jQuery: 'jquery',\n                'window.jQuery': 'jquery',\n                Popper: ['popper.js', 'default']\n            }),\n            //打包环境去掉console.log等\n            new UglifyJsPlugin({\n                uglifyOptions: {\n                    compress: {\n                        //warnings: false, 注释不然打包会报错如图下图\n                        drop_console: true,  //注释console\n                        drop_debugger: true, //注释debugger\n                        pure_funcs: ['console.log'], //移除console.log\n                    },\n                },\n            })\n        ],\n\n        output: {\n            libraryExport: '../behind/src/static'\n        }\n    },\n})\n```\n\n打包之前read页面的输出:\n```\nday?\nApp.vue:32 true\nrequest.js:24 token不存在\nComment.vue:60 请求的id:304\nrequest.js:24 token不存在\n```\n\n打包之后放到服务端并访问:\n\n控制台啥也没有了\n\n",
        "states": "1",
        "description": "vue3的打包优化方案,打包后太大了我受不了",
        "praise": null,
        "view": "93",
        "audit": "1",
        "tag1": "vue",
        "tag2": "打包优化",
        "tag3": "前端",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "2",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-11T06:32:38.000Z",
        "updatedAt": "2023-05-27T02:46:48.000Z",
        "destroyTime": null
    },
    {
        "id": 305,
        "email": "adminEmail",
        "title": "admin的文章",
        "content": "> hello world!\n\ntype you first line code\n",
        "states": "1",
        "description": null,
        "praise": null,
        "view": "5",
        "audit": "1",
        "tag1": "admin",
        "tag2": "测试",
        "tag3": "tag3",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "2",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-12T02:32:17.000Z",
        "updatedAt": "2023-05-18T08:46:55.000Z",
        "destroyTime": "2023-05-19T02:46:19.000Z"
    },
    {
        "id": 306,
        "email": "2714351312@qq.com",
        "title": "强缓存和协商缓存",
        "content": "#### HTTP Cache\n`HTTP Cache` 是我们开发中接触最多的缓存，它分为强缓存和协商缓存。\n\n强缓存：直接从本地副本比对读取，不去请求服务器，返回的状态码是 200。\n协商缓存：会去服务器比对，若没改变才直接读取本地缓存，返回的状态码是 304。\n\n#### 强缓存\n> 强缓存主要包括 expires 和 cache-control。\n\n> expires\n\n`expires`是 HTTP1.0 中定义的缓存字段。当我们请求一个资源，服务器返回时，可以在 Response Headers 中增加 expires 字段表示资源的过期时间。\n\n```shell\nexpires: Thu, 03 Jan 2019 11:43:04 GMT\n```\n它是一个时间戳（准确点应该叫格林尼治时间），当客户端再次请求该资源的时候，会把客户端时间与该时间戳进行对比，如果大于该时间戳则已过期，否则直接使用该缓存资源。\n\n但是，有个大问题，发送请求时是使用的客户端时间去对比。一是客户端和服务端时间可能快慢不一致，另一方面是客户端的时间是可以自行修改的(比如浏览器是跟随系统时间的，修改系统时间会影响到),所以不一定满足预期\n\n> cache-control\n\n正由于上面说的可能存在的问题，HTTP1.1 新增了 `cache-control` 字段来解决该问题，所以当 `cache-control` 和 `expires` 都存在时，`cache-control` 优先级更高。该字段是一个时间长度，单位秒，表示该资源过了多少秒后失效。当客户端请求资源的时候，发现该资源还在有效时间内则使用该缓存，它不依赖客户端时间。`cache-control` 主要有 `max-age` 和 `s-maxage`、`public` 和 `private`、`no-cache` 和 `no-store` 等值。\n```shell\ncache-control: public, max-age=3600, s-maxage=3600 \n```\n\n##### max-age 和 s-maxage\n两者是 `cache-control` 的主要字段，它们是一个数字，表示资源过了多少秒之后变为无效。在浏览器中，`max-age` 和 `s-maxage` 都起作用，而且 `s-maxage` 的优先级高于 `max-age`。在代理服务器中，只有 `s-maxage` 起作用。 可以通过设置 `max-age` 为 0 表示立马过期来向服务器请求资源。\n\n##### public 和 private\npublic 表示该资源可以被所有客户端和代理服务器缓存，而 private 表示该资源仅能客户端缓存。默认值是 private，当设置了 s-maxage 的时候表示允许代理服务器缓存，相当于 public。\n\n##### no-cache 和 no-store\n`no-cache` 表示的是不直接询问浏览器缓存情况，而是去向服务器验证当前资源是否更新（即协商缓存）。`no-store` 则更狠，完全不使用缓存策略，不缓存请求或响应的任何内容，直接向服务器请求最新。由于两者都不考虑缓存情况而是直接与服务器交互，所以当 `no-cache` 和 `no-store` 存在时会直接忽略 `max-age` 等。\n\n##### pragma\n\n既然讲到了 no-cache 和 no-store，就顺便把 pragma 也讲了。他的值有 no-cache 和 no-store，表示意思同 cache-control，优先级高于 cache-control 和 expires，即三者同时出现时，先看 pragma -> cache-control -> expires。\n```shell\npragma: no-cache\n```\n\n#### 协商缓存\n\n上面的 `expires` 和 `cache-contro`l 都会访问本地缓存直接验证看是否过期，如果没过期直接使用本地缓存，并返回 200。但如果设置了 `no-cache` 和 `no-store` 则本地缓存会被忽略，会去请求服务器验证资源是否更新，如果没更新才继续使用本地缓存，此时返回的是 304，这就是协商缓存。协商缓存主要包括 `last-modified` 和 `etag`。\n\n##### last-modified\n\nlast-modified 记录资源最后修改的时间。启用后，请求资源之后的响应头会增加一个 last-modified 字段，如下：\n```shell\nlast-modified: Thu, 20 Dec 2018 11:36:00 GMT\n```\n当再次请求该资源时，请求头中会带有 `if-modified-since` 字段，值是之前返回的 `last-modified` 的值，如：`if-modified-since:Thu, 20 Dec 2018 11:36:00 GMT`。服务端会对比该字段和资源的最后修改时间，若一致则证明没有被修改，告知浏览器可直接使用缓存并返回 304；若不一致则直接返回修改后的资源，并修改 last-modified 为新的值。\n\n但 last-modified 有以下两个缺点：\n\n只要编辑了，不管内容是否真的有改变，都会以这最后修改的时间作为判断依据，当成新资源返回，从而导致了没必要的请求响应，而这正是缓存本来的作用即避免没必要的请求。\n时间的精确度只能到秒，如果在一秒内的修改是检测不到更新的，仍会告知浏览器使用旧的缓存。\n\n##### etag\n\n为了解决 `last-modified` 上述问题，有了 `etag`。 `etag` 会基于资源的内容编码生成一串唯一的标识字符串，只要内容不同，就会生成不同的 `etag`。启用 `etag` 之后，请求资源后的响应返回会增加一个 `etag` 字段，如下：\n```shell\netag: \"FllOiaIvA1f-ftHGziLgMIMVkVw_\"\n```\n当再次请求该资源时，请求头会带有 `if-none-match` 字段，值是之前返回的 `etag` 值，如：`if-none-match:\"FllOiaIvA1f-ftHGziLgMIMVkVw_\"`。服务端会根据该资源当前的内容生成对应的标识字符串和该字段进行对比，若一致则代表未改变可直接使用本地缓存并返回 304；若不一致则返回新的资源（状态码200）并修改返回的 etag 字段为新的值。\n\n可以看出 `etag` 比 `last-modified` 更加精准地感知了变化，所以 `etag` 优先级也更高。不过从上面也可以看出 `etag` 存在的问题，就是每次生成标识字符串会增加服务器的开销。所以要如何使用 `last-modified` 和 `etag` 还需要根据具体需求进行权衡。\n\n#### 访问刷新分析\n我们将访问和刷新分为以下三种情况：\n\n- 标签进入、输入url回车进入\n- 按刷新按钮、F5 刷新、网页右键“重新加载”\n- ctrl + F5 强制刷新\n\n假设当前有这么一个 index 页面，返回的响应信息如下:\n```shell\ncache-control: max-age=72000\nexpires: Tue, 20 Nov 2018 20:41:14 GMT\nlast-modified: Tue, 20 Nov 2018 00:41:14 GMT\n```\n##### 标签进入、输入url回车进入\n这种情况下会根据实际设计的缓存策略去判断。\n\n由于该例没有设置 `no-cache` 和 `no-store`，所以默认先走强缓存路线。根据 `cache-control`(`expires` 优先级低)判断缓存是否过期，若没有过期则此时返回 200(from cache)\n若本地缓存已经过期再走协商缓存路线，根据之前的 last-modified 值去与服务器比对，若这个时间之后没有改过则去读取本地缓存，返回 304(not modified)。\n否则返回新的资源，状态码 200(ok)，并更新返回响应的 last-modified 值。\n##### 按刷新按钮、F5 刷新、网页右键“重新加载”\n这种情况下，实际是浏览器将 `cache-control` 的 max-age 直接设置成了 0，让缓存立即过期，直接走协商缓存路线。发送的请求头如下：\n```shell\ncache-control: max-age=0\nif-modified-since: Tue, 20 Nov 2018 00:41:14 GMT\n```\n##### ctrl + F5 强制刷新\n强制刷新的情况下，浏览器会强行设置 `no-cache`，强制获取最新的资源，就连 `if-modified-since` 等其他缓存协议字段都会被吃掉。此时发送的请求头如下：\n\n```shell\ncache-control: no-cache\npragma: no-cache\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
        "states": "1",
        "description": "首先，什么是缓存？我的理解，缓存就是一个资源副本。当我们向服务器请求资源后，会根据情况将资源 copy 一份副本存在本地，以方便下次读取。它与本地存储 localStorage 、cookie 等不同，本地存储更多是数据记录，存储量较小，为了本地操作方便。而缓存更多是为了减少资源请求，多用于存储文件，存储量相对较大",
        "praise": null,
        "view": "43",
        "audit": "1",
        "tag1": "缓存",
        "tag2": "强缓存和协商缓存",
        "tag3": "面试",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "2",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "1",
        "createdAt": "2023-05-12T05:27:20.000Z",
        "updatedAt": "2023-06-02T06:23:08.000Z",
        "destroyTime": null
    },
    {
        "id": 307,
        "email": "2714351312@qq.com",
        "title": "sessionStorage、localStorage用法总结",
        "content": "#### 共同点\n\n存储大小为5MB，都保存在客户端，不与服务器进行交互通信，有相同的Web API\n\n#### sessionStorage、localStorage区别\n\n- localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；\n- sessionStorage 数据在当前浏览器窗口关闭后自动删除。\n\n因此sessionStorage 和 localStorage 的主要区别在于他们存储数据的生命周期，sessionStorage 存储的数据的生命周期是一个会话，而 localStorage存储的数据的生命周期是永久，除非主动删除数据，否则永远不会过期\n\n#### Web Storage API\nlocalStorage 和 sessionStorage 有着统一的API接口，下面以sessionStorage为例介绍一下 API 接口使用方法\n\n##### 添加键值对\nsetItem(key,value)：为指定key值设置一个对应的value值\n\n\n\n除了使用setItem方法，还可以使用sessionStorage.key = value或者sessionStorage['key'] = value这两种形式。\n\n\n\n// 把name值存储到name的键上\n\nsessionStorage.setItem('name', 'jacky'); // 法1\n\n// sessionStorage.name = 'jacky'; // 法2\n\n// sessionStorage['name'] = 'jacky'; // 法3\n\n##### 添加数组和对象\n\n> 需要注意的是key和value值必须是字符串形式的，如果不是字符串，会调用它们相应的toString()方法来转换成字符串再存储。\n\n> 所以要存储数组或对象时，应先转换成字符串格式（如JSON格式）再进行存储，使用JSON.stringify(obj)方法\n\n// 获取存储到 name 的键上的值\n```javascript\nvar name = sessionStorage.getItem('name');\n```\nremoveItem（key）：删除指定的key值对应的value值\n\n注意localStorage 没有数据过期的概念，所有数据如果失效了，需要开发者手动删除。\n\nclear()：删除所有存储的内容\n\n> 它和removeItem不同的地方是removeItem删除的是某一项，而clear是删除所有。\n\nvar len = sessionStorage.length; // 0\n\n> length属性用于获取 sessionStorage 中键值对的数量。\n",
        "states": "1",
        "description": "html5 中的 web Storage 包括了两种存储方式：sessionStorage 和 localStorage",
        "praise": null,
        "view": "34",
        "audit": "1",
        "tag1": "sessionStorage",
        "tag2": "localStorage",
        "tag3": "面试",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "2",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-12T06:22:12.000Z",
        "updatedAt": "2023-07-15T10:01:46.000Z",
        "destroyTime": null
    },
    {
        "id": 308,
        "email": "2714351312@qq.com",
        "title": "购物车实现过程",
        "content": "#### 购物车和用户之间的关系\n一个用户必须对应一个购物车,一个用户不管买多少商品，都会存在属于自己的购物车中\n单点登录一定要在购物车之前。\n\n#### 和购物车有关的操作都有哪些\n用户未登录状态\n  添加到什么地方？未登录将数据保存到什么地方？\n用户登录状态:\n- 存在于数据库中\n- 进入购物车时获取数据\n\n#### 展示购物车数据\n未登录状态展示\n  1.直接从cookie中取得添加的数据展示即可\n登录状态\n  1.用户一旦登录:就必须显示数据库和cookie中的购物车的数据\n  例如：\n    如果Cookie中有三条数据\n    如果Redis中有五条数据\n    那么真正展示的时候应该是Redis中的数据加上Cookie中的数据共八条数据\n\n\n",
        "states": "1",
        "description": "一个用户必须对应一个购物车,一个用户不管买多少商品，都会存在属于自己的购物车中 单点登录一定要在购物车之前。",
        "praise": null,
        "view": "27",
        "audit": "1",
        "tag1": "vue",
        "tag2": "购物车",
        "tag3": "面试",
        "source": null,
        "url": null,
        "headImg": "/upload_05e9254b5d6edb817a245bd3d6c5242b.png",
        "type": "blog",
        "hasOriginal": "2",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-12T07:08:58.000Z",
        "updatedAt": "2023-06-08T14:19:36.000Z",
        "destroyTime": null
    },
    {
        "id": 309,
        "email": "2714351312@qq.com",
        "title": "android基础布局容器",
        "content": "- LinearLayout 线性布局:横着或竖着按顺序排列\n- RelativeLayout相对布局:起始坐标是屏幕左上角,已同级或上级为参考系定位\n- FrameLayout帧布局:像千层饼一样一层压着一层\n- ConstraintLayout约束布局:不在android的基础api包里,需要额外引入\n\n> 注意,别忘了布局在哪:\n\n```shell\nPS D:\\myHomeWork\\adnroid\\firstApp\\app\\src\\main\\res\\layout> dir\n\n\n目录: D:\\myHomeWork\\adnroid\\firstApp\\app\\src\\main\\res\\layout\n\n\nMode                 LastWriteTime         Length Name\n----                 -------------         ------ ----\n-a----         2023/4/24     19:31           1485 activity_main.xml\n-a----         2023/4/24     19:31            990 fragment_dashboard.xml\n-a----         2023/4/24     19:31            975 fragment_home.xml\n-a----         2023/4/24     19:31           1002 fragment_notifications.xml\n\n\nPS D:\\myHomeWork\\adnroid\\firstApp\\app\\src\\main\\res\\layout> \n\n```\n\n> 注意:\n\n布局文件的名字不可以包含`-`或大写字母,你可以用`_`",
        "states": "1",
        "description": "- LinearLayout 线性布局:横着或竖着按顺序排列 - RelativeLayout相对布局:起始坐标是屏幕左上角,已同级或上级为参考系定位 - FrameLayout帧布局:像千层饼一样一层压着一层 - ConstraintLayout约束布局:不在android的基础api包里,需要额外引入",
        "praise": null,
        "view": "155",
        "audit": "1",
        "tag1": "android",
        "tag2": "kotlin",
        "tag3": "note",
        "source": null,
        "url": null,
        "headImg": "/upload_4c08ed5effa17c60dfa4ed27567b4e80.png",
        "type": "blog",
        "hasOriginal": "2",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-12T08:35:00.000Z",
        "updatedAt": "2023-07-20T04:30:31.000Z",
        "destroyTime": null
    },
    {
        "id": 310,
        "email": "2714351312@qq.com",
        "title": "kotlin for android 实现跳转",
        "content": "#### Date\n\n在不给Date构造函数传参数的情况下，创建的对象将保存当前日期和时间。要基于其他日期和时\n间创建日期对象，必须传人其毫秒表示(UNIX纪元1970年1月1日午夜之后的毫秒数)。ECMAScript\n为此提供了两个辅助方法:`Date.parse()`和`Date.UTC()`\n\n- Date.parse()方法接收一个表示日期的字符串参数,尝试将这个字符串转换为表示该日期的毫秒\n\n所有实现都必须支持以下日期格式:\n\n- “月/日/年”，如\"5/23/2019\";\n- “月名日，年”，如\"May 23, 2019\";\n- “周几月名日年时分秒时区”，如\"Tue May 23 2019 00:00:00 GMT- 0700\";\n\n\n\n![](/upload_b836e7bf07592b484ec18eb894782870.jpg)\n![](/upload_02e57df2eaad6f096202fbc59c282480.jpg)\n![](/upload_9f6ec247606be4ed5720b5324ae9c2cc.png)\n",
        "states": "1",
        "description": "kotlin for android的不携带参数跳转和携带参数跳转",
        "praise": null,
        "view": "666",
        "audit": "1",
        "tag1": "kotlin",
        "tag2": "android",
        "tag3": "傻逼安卓",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/2.png",
        "type": "blog",
        "hasOriginal": "2",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-12T17:26:38.000Z",
        "updatedAt": "2023-07-21T03:56:06.000Z",
        "destroyTime": null
    },
    {
        "id": 311,
        "email": "2714351312@qq.com",
        "title": "vue插槽",
        "content": "> hello world!\n\ntype you first line code\n",
        "states": "1",
        "description": null,
        "praise": null,
        "view": "5",
        "audit": "1",
        "tag1": "vue",
        "tag2": "面试",
        "tag3": "前端",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "2",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-13T04:09:54.000Z",
        "updatedAt": "2023-05-15T12:32:49.000Z",
        "destroyTime": "2023-05-15T12:33:01.000Z"
    },
    {
        "id": 312,
        "email": "2714351312@qq.com",
        "title": "Vue Router 核心原理及实现",
        "content": "> hello world!\n\ntype you first line code\n",
        "states": "1",
        "description": null,
        "praise": null,
        "view": "1",
        "audit": "1",
        "tag1": "vue",
        "tag2": "面试",
        "tag3": "前端",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "2",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-13T08:27:57.000Z",
        "updatedAt": "2023-05-13T09:53:24.000Z",
        "destroyTime": "2023-05-15T03:44:14.000Z"
    },
    {
        "id": 313,
        "email": "2714351312@qq.com",
        "title": "Vue Router 核心原理及实现",
        "content": "#### vue路由有两种方式:\n\nhash 和 history\n\n#### hash\n- 表现形式上：hash 模式 url music.163.com/#/playlist?… , 带有 # 号。\n\n\n- 原理区别：hash 模式基于锚点，以及 onhashchange 事件。 history 模式是基于 HTML5 中的 history 模式。history.pushState、replaceState 在 IE10 以后才支持，存在兼容性问题。push 会向服务器发送请求，使用 pushState 不会发送请求，但是会在浏览器端产生历史记录，形成客户端路由。\n",
        "states": "1",
        "description": null,
        "praise": null,
        "view": "8",
        "audit": "1",
        "tag1": "vue",
        "tag2": "面试",
        "tag3": "前端",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "2",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-13T08:28:39.000Z",
        "updatedAt": "2023-05-15T06:51:00.000Z",
        "destroyTime": "2023-05-15T03:44:14.000Z"
    },
    {
        "id": 314,
        "email": "2714351312@qq.com",
        "title": "Vue Router 核心原理及实现",
        "content": "#### vue路由有两种方式:\n\nhash 和 history\n\n#### hash\n- 表现形式上：hash 模式 url `http://blog.icestone.top/#/read?id=313`, 带有 # 号。\n\n\n- 原理区别：hash 模式基于锚点，以及 onhashchange 事件。 history 模式是基于 HTML5 中的 history 模式。history.pushState、replaceState 在 IE10 以后才支持，存在兼容性问题。push 会向服务器发送请求，使用 pushState 不会发送请求，但是会在浏览器端产生历史记录，形成客户端路由。\n\n#### history 模式使用\n\n",
        "states": "1",
        "description": null,
        "praise": null,
        "view": "2",
        "audit": "1",
        "tag1": "vue",
        "tag2": "面试",
        "tag3": "前端",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "2",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "",
        "createdAt": "2023-05-13T08:31:11.000Z",
        "updatedAt": "2023-05-15T03:43:54.000Z",
        "destroyTime": "2023-05-15T03:44:14.000Z"
    },
    {
        "id": 315,
        "email": "2714351312@qq.com",
        "title": "Vue Router 核心原理及实现",
        "content": "#### vue路由有两种方式:\n\nhash 和 history\n\n#### hash\n- 表现形式上：hash 模式 url `http://blog.icestone.top/#/read?id=313`, 带有 # 号。\n\n\n- 原理区别：hash 模式基于锚点，以及 onhashchange 事件。 history 模式是基于 HTML5 中的 history 模式。history.pushState、replaceState 在 IE10 以后才支持，存在兼容性问题。push 会向服务器发送请求，使用 pushState 不会发送请求，但是会在浏览器端产生历史记录，形成客户端路由。\n\n#### history 模式使用\n\n> test",
        "states": "1",
        "description": null,
        "praise": null,
        "view": "18",
        "audit": "1",
        "tag1": "vue",
        "tag2": "面试",
        "tag3": "前端",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "2",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "2",
        "createdAt": "2023-05-15T00:11:34.000Z",
        "updatedAt": "2023-06-30T18:24:10.000Z",
        "destroyTime": null
    },
    {
        "id": 316,
        "email": "2714351312@qq.com",
        "title": "一些面试题目",
        "content": "> 一些面试题目:\n\n#### vue生命周期\n\n##### 什么是vue生命周期\n\nVue实例从创建到销毁的过程,就是生命周期.也就是从开始创建,初始化数据,编译模板,挂载DOM-渲染,更新-渲染,卸载等一系列的过程,我们称这是 Vue 的生命周期\n\n##### vue生命周期的作用是什么\n\nVue所有的功能的实现都是围绕其生命周期进行的,在生命周期的不同阶段调用对应的钩子函数可以实现组件数据管理和DOM渲染两大重要功能.\n生命周期中有多个事件钩子,在控制整个vue实例的过程时更容易形成好的逻辑\n\n##### 第一次页面加载会触发哪几个钩子\n\nbeforeCreate,created,beforeMount,mounted 这几个钩子\n\n##### 简述每个周期具体适合哪些场景\n\n- beforeCreate:创建前,此阶段为实例初始化之后,this指向创建的实例,此时的数据观察事件机制都未形成,不能获得DOM节点.\n  data,computed,watch,methods 上的方法和数据均不能访问.\n  可以在这加个loading事件.\n\n\n\n- created:创建后,此阶段为实例已经创建,完成数据(data,props,computed)的初始化导入依赖项\n  可访问 data computed watch methods 上的方法和数据\n  初始化完成时的事件写在这里,异步请求也适宜在这里调用(请求不宜过多,避免白屏时间太长)\n  可以在这里结束loading事件,还做一些初始化,实现函数自执行\n  未挂载DOM,若在此阶段进行DOM操作一定要放在Vue.nextTick()的回调函数中\n\n\n\n- beforeMount:挂载前,虽然得不到具体的DOM元素,但vue挂载的根节点已经创建,下面vue对DOM的操作将围绕这个根元素继续进行\n  beforeMount这个阶段是过渡性的,一般一个项目只能用到一两次\n\n\n\n- mounted:挂载,完成创建vm.$el,和双向绑定\n  完成挂载DOM和渲染,可在mounted钩子函数中对挂载的DOM进行操作\n  可在这发起后端请求,拿回数据,配合路由钩子做一些事情\n\n\n\n- beforeUpdate:数据更新前,数据驱动DOM\n  在数据更新后虽然没有立即更新数据,但是DOM中的数据会改变,这是vue双向数据绑定的作用\n  可在更新前访问现有的DOM,如手动移出添加的事件监听器\n\n\n\n- updated:数据更新后,完成虚拟DOM的重新渲染和打补丁\n  组件DOM已完成更新,可执行依赖的DOM操作\n  注意:不要在此函数中操作数据(修改属性),会陷入死循环\n\n\n\n- activated:在使用vue-router时有时需要使用`<keep-alive></keep-alive>`来缓存组件状态,这个时候created钩子就不会被重复调用了\n  如果我们的子组件需要在每次加载的时候进行某些操作,可以使用activated钩子触发\n\n\n\n- deactivated:`<keep-alive></keep-alive>`组件被移除时使用\n\n\n\n- beforeDestroy:销毁前,\n  可做一些删除提示,如:您确定删除xx吗？\n\n\n\n- destroyed:销毁后,当前组件已被删除,销毁监听事件,组件、事件、子实例也被销毁\n  这时组件已经没有了,无法操作里面的任何东西了\n\n##### 父子组件的生命周期\n\n- 执行顺序：\n\n- - 父组件开始执行到beforeMount 然后开始子组件执行，最后是父组件mounted。\n  - 如果有兄弟组件，父组件开始执行到beforeMount，然后兄弟组件依次执行到beforeMount，然后按照顺序执行mounted，最后执行父组件的mounted。\n\n- 当子组件挂载完成后，父组件才会挂载。\n\n- 当子组件完成挂载后，父组件会主动执行一次beforeUpdated/updated钩子函数（仅首次）\n\n- 父子组件在data变化中是分别监控的，但是更新props中的数据是关联的。\n\n- 销毁父组件时，先将子组件销毁后才会销毁父组件。\n\n- 兄弟组件的初始化（mounted之前）是分开进行，挂载是从上到下依次进行\n\n- 当没有数据关联时，兄弟组件之间的更新和销毁是互不关联的\n\n\n\n#### vue中watch和computed的区别\n\n##### 计算属性computed\n\n- 支持缓存,只有依赖数据发生改变,才会重新进行计算,计算属性可用于快速计算视图(View)中显示的属性这些计算将被缓存,并且只在需要时更新computed是计算属性的; 它会根据所依赖的数据动态显示新的计算结果, 该计算结果会被缓存起来computed的值在getter执行后是会被缓存的如果所依赖的数据发生改变时候, 就会重新调用getter来计算最新的结果\n\n- 不支持异步,当computed内有异步操作时无效,无法监听数据的变化\n\n\n- computed 属性值会默认走缓存,计算属性是基于它们的响应式依赖进行缓存的,也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值\n\n\n- 如果一个属性是由其他属性计算而来的,这个属性依赖其他属性,是一个多对一或者一对一,一般用computed\n\n\n- 如果computed属性属性值是函数,那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的,属性都有一个get和一个set方法,当数据变化时,调用set方法\n\n\n- 适用于一些重复使用数据或复杂及费时的运算我们可以把它放入computed中进行计算, 然后会在computed中缓存起来, 下次就可以直接获取了\n\n\n- 如果我们需要的数据依赖于其他的数据的话, 我们可以把该数据设计为computed中\n\n\n- computed 是基于响应性依赖来进行缓存的只有在响应式依赖发生改变时它们才会重新求值, 也就是说, 当msg属性值没有发生改变时, 多次访问 reversedMsg 计算属性会立即返回之前缓存的计算结果, 而不会再次执行computed中的函数但是methods方法中是每次调用, 都会执行函数的, methods它不是响应式的\n\n\n- computed中的成员可以只定义一个函数作为只读属性, 也可以定义成 get/set变成可读写属性, 但是methods中的成员没有这样的\n\n##### 侦听属性watch\n\n- watch它是一个对data的数据监听回调, 当依赖的data的数据变化时, 会执行回调在回调中会传入newVal和oldVal两个参数Vue实列将会在实例化时调用$watch(), 他会遍历watch对象的每一个属性watch的使用场景是:当在data中的某个数据发生变化时, 我们需要做一些操作, 或者当需要在数据变化时执行异步或开销较大的操作时. 我们就可以使用watch来进行监听watch普通监听和深度监听不支持缓存,数据变,直接会触发相应的操作；\n- watch里面有一个属性为deep,含义是:是否深度监听某个对象的值, 该值默认为falsewatch支持异步；\n- 监听的函数接收两个参数,第一个参数是最新的值；第二个参数是输入之前的值；\n- 当一个属性发生变化时,需要执行对应的操作；一对多；\n- 监听数据必须是data中声明过或者父组件传递过来的props中的数据,当数据变化时,触发其他操作,函数有两个参数,\n\n- immediate:组件加载立即触发回调函数执行,\n  deep: 深度监听,为了发现对象内部值的变化,复杂类型的数据时使用,例如数组中的对象内容的改变,注意监听数组的变动不需要这么做注意:deep无法监听到数组的变动和对象的新增,参考vue数组变异,只有以响应式的方式触发才会被监听到\n\n#### 常见修饰符\n\n#####  Vue中修饰符分为以下五种\n\n1. 表单修饰符\n2. 事件修饰符\n3. 鼠标按键修饰符\n4. 键值修饰符\n5. v-bind修饰符\n\n##### 表单修饰符\n\n lazy:填完信息，光标离开标签的时候，才会将值赋予给`value,`也就是在`change`事件之后再进行信息同步\n\n```vue\n<input type=\"text\" v-model.lazy=\"value\">\n<p>{{value}}</p>\n```\n\ntrim: 自动过滤用户输入的首空格字符，而中间的空格不会过滤\n\n```vue\n<input type=\"text\" v-model.trim=\"value\">\n```\n\nnumber:自动将用户的输入值转为数值类型，但如果这个值无法被`parseFloat`解析，则会返回原来的值\n\n```html\n<input v-model.number=\"age\" type=\"number\">\n```\n\n##### 事件修饰符\n\n事件修饰符是对事件捕获以及目标进行了处理，有如下修饰符：\n\n- stop\n- prevent\n- self\n- once\n- capture\n- passive\n- native\n\nstop:阻止了事件冒泡，相当于调用了`event.stopPropagation`方法\n\n```vue\n<div @click=\"shout(2)\">\n  <button @click.stop=\"shout(1)\">ok</button>\n</div>\n//只输出1\n```\n\nprevent:阻止了事件的默认行为,相当于调用了`event.preventDefault`方法\n\n```vue\n<form v-on:submit.prevent=\"onSubmit\"></form>\n```\n\nself:只当在 `event.target` 是当前元素自身时触发处理函数\n\n```html\n<div v-on:click.self=\"doThat\">...</div>\n```\n\n> 使用修饰符时需要注意调用顺序，因为相关代码是以相同的顺序生成的.\n>\n> 因此使用 `@click.prevent.self` 会阻止元素及其子元素的所有点击事件的默认行为\n>\n> 而 `@click.self.prevent` 则只会阻止对元素本身的点击事件的默认行为.\n\n##### once\n\n绑定了事件以后只能触发一次，第二次就不会触发\n\n```vue\n<button @click.once=\"shout(1)\">ok</button>\n```\n\n##### capture\n\n添加事件监听器时，使用 `capture` 捕获模式，例如：指向内部元素的事件，在被内部元素处理前，先被外部处理。使事件触发从包含这个元素的顶层开始往下触发\n\n```vue\n<div @click.capture=\"shout(1)\">\n    obj1\n<div @click.capture=\"shout(2)\">\n    obj2\n<div @click=\"shout(3)\">\n    obj3\n<div @click=\"shout(4)\">\n    obj4\n</div>\n</div>\n</div>\n</div>\n// 输出结构: 1 2 4 3 \n```\n\n##### passive\n\n在移动端，当我们在监听元素滚动事件的时候，会一直触发`onscroll`事件会让我们的网页变卡，因此我们使用这个修饰符的时候，相当于给`onscroll`事件整了一个`.lazy`修饰符。\n\n滚动事件的默认行为 (scrolling) 将立即发生而非等待 `onScroll` 完成，以防其中包含 `event.preventDefault()`\n\n```vue\n<!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 -->\n<!-- 而不会等待 `onScroll` 完成  -->\n<!-- 这其中包含 `event.preventDefault()` 的情况 -->\n<div v-on:scroll.passive=\"onScroll\">...</div>\n```\n\n`.passive` 修饰符一般用于触摸事件的监听器，可以用来[改善移动端设备的滚屏性能](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FEventTarget%2FaddEventListener%23%E4%BD%BF%E7%94%A8_passive_%E6%94%B9%E5%96%84%E7%9A%84%E6%BB%9A%E5%B1%8F%E6%80%A7%E8%83%BD)\n\n> 请勿同时使用 `.passive` 和 `.prevent`，因为 `.passive` 已经向浏览器表明了你*不想*阻止事件的默认行为.如果你这么做了,则 `.prevent` 会被忽略,并且浏览器会抛出警告.\n\n##### native\n\n让组件变成像`html`内置标签那样监听根元素的原生事件，否则组件上使用 `v-on` 只会监听自定义事件\n\n```vue\n<my-component v-on:click.native=\"doSomething\"></my-component>\n```\n\n> 使用.native修饰符来操作普通HTML标签是会令事件失效的\n\n##### 鼠标按钮修饰符\n\n鼠标按钮修饰符针对的就是左键、右键、中键点击，有如下：\n\n- left 左键点击\n- right 右键点击\n- middle 中键点击\n\n```vue\n<button @click.left=\"shout(1)\">ok</button>\n<button @click.right=\"shout(1)\">ok</button>\n<button @click.middle=\"shout(1)\">ok</button>\n```\n\n##### 键盘修饰符\n\n键盘修饰符是用来修饰键盘事件（`onkeyup`，`onkeydown`）的，有如下：\n\n`keyCode`存在很多，但`vue`为我们提供了别名，分为以下两种：\n\n- 普通键（enter、tab、delete、space、esc、up...）\n- 系统修饰键（ctrl、alt、meta、shift...）\n\n```vue\n// 只有按键为keyCode的时候才触发 \n<input type=\"text\" @keyup.keyCode=\"shout()\">\n```\n\n##### v-bind修饰符\n\n v-bind修饰符主要是为属性进行操作，用来分别有如下：\n\n- async\n- prop\n- camel\n\n##### async\n\n能对`props`进行一个双向绑定\n\n```vue\n//父组件\n<comp :myMessage.sync=\"bar\"></comp> \n//子组件\nthis.$emit('update:myMessage',params);\n```\n\n以上这种方法相当于以下的简写\n\n```vue\n//父亲组件\n<comp :myMessage=\"bar\" @update:myMessage=\"func\"></comp>\nfunc(e){\n this.bar = e;\n}\n//子组件js\nfunc2(){\n  this.$emit('update:myMessage',params);\n}\n```\n\n使用`async`需要注意以下两点：\n\n- 使用`sync`的时候，子组件传递的事件名格式必须为`update:value`，其中`value`必须与子组件中`props`中声明的名称完全一致\n- 注意带有 `.sync` 修饰符的 `v-bind` 不能和表达式一起使用\n- 将 `v-bind.sync` 用在一个字面量的对象上，例如 `v-bind.sync=”{ title: doc.title }”`，是无法正常工作的\n\n##### props\n\n设置自定义标签属性，避免暴露数据，防止污染HTML结构\n\n```vue\n<input id=\"uid\" title=\"title1\" value=\"1\" :index.prop=\"index\">\n```\n\n##### camel\n\n将命名变为驼峰命名法，如将` view-Box`属性名转换为 `viewBox`\n\n```vue\n<svg :viewBox=\"viewBox\"></svg>\n```\n\n##### 应用场景\n\n根据每一个修饰符的功能，我们可以得到以下修饰符的应用场景：\n\n- .stop：阻止事件冒泡\n- .native：绑定原生事件\n- .once：事件只执行一次\n- .self ：将事件绑定在自身身上，相当于阻止事件冒泡\n- .prevent：阻止默认事件\n- .capture：用于事件捕获\n- .once：只触发一次\n- .keyCode：监听特定键盘按下\n- .right：右键\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### vue路由有两种方式:\n\nhash 和 history\n\n##### hash\n\n- 表现形式上:hash 模式 url `http://blog.icestone.top/#/read?id=313`, 带有 # 号\n\n\n- 原理区别:hash 模式基于锚点,以及 onhashchange 事件 history 模式是基于 HTML5 中的 history 模式history.pushState、replaceState 在 IE10 以后才支持,存在兼容性问题push 会向服务器发送请求,使用 pushState 不会发送请求,但是会在浏览器端产生历史记录,形成客户端路由\n\n##### history 模式使用\n\n- 该模式需要服务器端的支持\n\n- 单页应用中,服务端不存在 [www.testurl.com/login](https://link.juejin.cn?target=http%3A%2F%2Fwww.testurl.com%2Flogin),地址会返回 404,提示找不到页面\n\n- `history` 模式下前后端工作过程:history 模式下,刷新页面会向服务器进行网络请求,后端处理 `history` 模式,需要将默认的 `html` 文件返回给前端,前端获取到文件后再根据路由自行处理\n\n#### XSS攻击\n\n> 简述\n\n跨站脚本(Cross-site scripting,简称为:CSS, 但这会与层叠样式表(Cascading Style Sheets,CSS)的缩写混淆因此,跨站脚本攻击缩写为XSS)是一种网站应用程序的安全漏洞攻击\n\nXSS攻击通常指的是通过利用网页开发时留下的漏洞,通过巧妙的方法注入恶意指令代码到网页,使用户加载并执行攻击者恶意制造的网页程序这些恶意网页程序通常是JavaScript,但实际上也可以包括Java、 VBScript、 LiveScript、ActiveX、 Flash 或者甚至是普通的HTML攻击成功后,攻击者可能得到包括但不限于更高的权限(如执行一些操作)、私密网页内容、会话和cookie等各种内容\n\n最常见的几种分类:**反射型(非持久型)XSS**、**存储型(持久型)XSS**、**DOM型XSS**、**通用型XSS**、**突变型XSS**\n\n##### 反射型XSS\n\n反射型XSS只是简单的把用户输入的数据从服务器反射给用户浏览器,要利用这个漏洞,攻击者必须以某种方式诱导用户访问一个精心设计的URL(恶意链接),才能实施攻击\n\n举例来说,当一个网站的代码中包含类似下面的语句:\n\n```php\nphp复制代码\n<?php echo \"<p>hello,$_GET['user']</p>\"; ?>\n```\n\n如果未做防范XSS,用户名设为`<script>alert(\"Tz\")</script>`,则会执行预设好的JavaScript代码\n\n##### 反射型XSS\n\n存储型(或 HTML 注入型/持久型)XSS 攻击最常发生在由社区内容驱动的网站或 Web 邮件网站,不需要特制的链接来执行黑客仅仅需要提交 XSS 漏洞利用代码(反射型XSS通常只在url中)到一个网站上其他用户可能访问的地方这些地区可能是`博客评论,用户评论,留言板,聊天室,HTML 电子邮件,wikis`,和其他的许多地方一旦用户访问受感染的页,执行是自动的\n\n##### DOM型XSS\n\n通过修改页面的DOM节点形成的XSS,称之为DOM Based XSS\n\nDOM型XSS是基于DOM文档对象模型的对于浏览器来说,DOM文档就是一份XML文档,当有了这个标准的技术之后,通过JavaScript就可以轻松的访问DOM当确认客户端代码中有DOM型XSS漏洞时,诱使(钓鱼)一名用户访问自己构造的URL,利用步骤和反射型很类似,但是唯一的区别就是,构造的URL参数不用发送到服务器端,可以达到绕过WAF、躲避服务端的检测效果\n\n##### 通用型XSS\n\n通用型XSS,也叫做UXSS或者Universal XSS,全称Universal Cross-Site Scripting\n\n上面三种XSS攻击的是因为客户端或服务端的代码开发不严谨等问题而存在漏洞的目标网站或者应用程序这些攻击的先决条件是访问页面存在漏洞,但是UXSS是一种利用浏览器或者浏览器扩展漏洞来制造产生XSS的条件并执行代码的一种攻击类型\n\n#### Vue 中 store 基本用法\n\n\n\n\n\n\n\n\n\n#### 如何在JavaScript中为多个元素添加一个事件监听器\n\n在JavaScript中,你用这种语法给单个元素添加一个[事件监听器](https://link.juejin.cn/?target=https%3A%2F%2Fflaviocopes.com%2Fjavascript-events%2F)\n\n```javascript\ndocument.querySelector('.my-element').addEventListener('click', event => {\n  //handle click\n})\n```\n\n同一个事件附加到多个元素上\n\n- 在所有具有特定类别的元素上调用`querySelectorAll()`,然后使用`forEach()` 来迭代它们\n\n```javascript\ndocument.querySelectorAll('.some-class').forEach(item => {\n  item.addEventListener('click', event => {\n    //handle click\n  })\n})\n```\n\n- 元素没有一个共同的类,你可以在空中建立一个数组\n\n```javascript\n[document.querySelector('.a-class'), document.querySelector('.another-class')].forEach(item => {\n  item.addEventListener('click', event => {\n    //handle click\n  })\n})\n```\n\n- 使用事件冒泡\n\n另一个选择是依靠[事件冒泡](https://link.juejin.cn/?target=https%3A%2F%2Fflaviocopes.com%2Fjavascript-events%2F%23event-bubbling-and-event-capturing),将事件监听器附在`body` 元素上\n\n该事件总是由最具体的元素管理,所以你可以立即检查这是否是应该处理该事件的元素之一\n\n```javascript\nconst element1 = document.querySelector('.a-class')\nconst element2 = document.querySelector('.another-class')\n\nbody.addEventListener('click', event => {\n  if (event.target !== element1 && event.target !== element2) {\n    return\n  }\n  //handle click\n}\n```\n\n#### vue2和vue3的区别\n\n##### 生命周期\n\n对于生命周期来说，整体上变化不大，只是大部分生命周期钩子名称上 + “on”，功能上是类似的。不过有一点需要注意，Vue3 在组合式API（Composition API，下面展开）中使用生命周期钩子时需要先引入，而 Vue2 在选项API（Options API）中可以直接调用生命周期钩子\n\n```vue\n// vue3\n<script setup>     \nimport { onMounted } from 'vue';   // 使用前需引入生命周期钩子\n \nonMounted(() => {\n  // ...\n});\n \n// 可将不同的逻辑拆开成多个onMounted，依然按顺序执行，不会被覆盖\nonMounted(() => {\n  // ...\n});\n</script>\n \n// vue2\n<script>     \nexport default {         \n  mounted() {   // 直接调用生命周期钩子            \n    // ...         \n  },           \n}\n</script> \n```\n\n常用生命周期对比如下表所示:\n\n| vue2          | vue3            |\n| ------------- | --------------- |\n| beforeCreate  |                 |\n| created       |                 |\n| beforeMount   | onBeforeMount   |\n| mounted       | onMounted       |\n| beforeUpdate  | onBeforeUpdate  |\n| updated       | onUpdated       |\n| beforeDestroy | onBeforeUnmount |\n| destroyed     | onUnmounted     |\n\n setup 是围绕 beforeCreate 和 created 生命周期钩子运行的，所以不需要显式地去定义\n\n#####  多根节点\n\nVue2在模板中如果使用多个根节点时会报错，如下所示\n\n```vue\n// vue2中在template里存在多个根节点会报错\n<template>\n  <header></header>\n  <main></main>\n  <footer></footer>\n</template>\n \n// 只能存在一个根节点，需要用一个<div>来包裹着\n<template>\n  <div>\n    <header></header>\n    <main></main>\n    <footer></footer>\n  </div>\n</template>\n```\n\nVue3 支持多个根节点，也就是 fragment。即以下多根节点的写法是被允许的\n\n```vue\n<template>\n  <header></header>\n  <main></main>\n  <footer></footer>\n</template>\n```\n\n##### Composition API\n\nVue2 是选项API（Options API），一个逻辑会散乱在文件不同位置（data、props、computed、watch、生命周期钩子等），导致代码的可读性变差。当需要修改某个逻辑时，需要上下来回跳转文件位置。\n\nVue3 组合式API（Composition API）则很好地解决了这个问题，可将同一逻辑的内容写到一起，增强了代码的可读性、内聚性，其还提供了较为完美的逻辑复用性方案\n\n##### 异步组件(Suspense)\n\nVue3 提供 Suspense 组件，允许程序在等待异步组件加载完成前渲染兜底的内容，如 loading ，使用户的体验更平滑。使用它，需在模板中声明，并包括两个命名插槽：default 和 fallback。Suspense 确保加载完异步内容时显示默认插槽，并将 fallback 插槽用作加载状态\n\n```vue\n<tempalte>\n  <suspense>\n    <template #default>\n      <List />\n    </template>\n    <template #fallback>\n      <div>\n        Loading...\n      </div>\n    </template>\n  </suspense>\n</template>\n```\n\n在 List 组件（有可能是异步组件，也有可能是组件内部处理逻辑或查找操作过多导致加载过慢等）未加载完成前，显示 Loading...（即 fallback 插槽内容），加载完成时显示自身（即 default 插槽内容）\n\n##### Teleport\n\nVue3 提供 Teleport 组件可将部分 DOM 移动到 Vue app 之外的位置。比如项目中常见的 Dialog 弹窗\n\n```vue\n<button @click=\"dialogVisible = true\">显示弹窗</button>\n<teleport to=\"body\">\n  <div class=\"dialog\" v-if=\"dialogVisible\">\n    我是弹窗，我直接移动到了body标签下\n  </div>\n</teleport>\n```\n\n##### 响应式原理\n\nVue2 响应式原理基础是 Object.defineProperty；Vue3 响应式原理基础是 Proxy\n\n- Vue2 响应式原理基础是 Object.defineProperty；Vue3 响应式原理基础是 Proxy\n\n```vue\nlet obj = {};\nlet name = 'leo';\nObject.defineProperty(obj, 'name', {\n  enumerable: true,   // 可枚举（是否可通过 for...in 或 Object.keys() 进行访问）\n  configurable: true,   // 可配置（是否可使用 delete 删除，是否可再次设置属性）\n  // value: '',   // 任意类型的值，默认undefined\n  // writable: true,   // 可重写\n  get() {\n    return name;\n  },\n  set(value) {\n    name = value;\n  }\n});\n```\n\n##### 虚拟DOM\n\nVue3 相比于 Vue2，虚拟DOM上增加 patchFlag 字段。我们借助Vue3 Template Explorer来看\n\n```vue\n<div id=\"app\">\n  <h1>vue3虚拟DOM讲解</h1>\n  <p>今天天气真不错</p>\n  <div>{{name}}</div>\n</div>\n```\n\n渲染函数如下所示\n\n```vue\nimport { createElementVNode as _createElementVNode, toDisplayString as _toDisplayString, openBlock as _openBlock, createElementBlock as _createElementBlock, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from vue\n \nconst _withScopeId = n => (_pushScopeId(scope-id),n=n(),_popScopeId(),n)\nconst _hoisted_1 = { id: app }\nconst _hoisted_2 = /*#__PURE__*/ _withScopeId(() => /*#__PURE__*/_createElementVNode(h1, null, vue3虚拟DOM讲解, -1 /* HOISTED */))\nconst _hoisted_3 = /*#__PURE__*/ _withScopeId(() => /*#__PURE__*/_createElementVNode(p, null, 今天天气真不错, -1 /* HOISTED */))\n \nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return (_openBlock(), _createElementBlock(div, _hoisted_1, [\n    _hoisted_2,\n    _hoisted_3,\n    _createElementVNode(div, null, _toDisplayString(_ctx.name), 1 /* TEXT */)\n  ]))\n}\n```\n\n注意第3个_createElementVNode的第4个参数即 patchFlag 字段类型。\n\n字段类型情况：1 代表节点为动态文本节点，那在 diff 过程中，只需比对文本对容，无需关注 class、style等。除此之外，发现所有的静态节点（HOISTED 为 -1），都保存为一个变量进行静态提升，可在重新渲染时直接引用，无需重新创建。\n\n```vue\n// patchFlags 字段类型列举\nexport const enum PatchFlags { \n  TEXT = 1,   // 动态文本内容\n  CLASS = 1 << 1,   // 动态类名\n  STYLE = 1 << 2,   // 动态样式\n  PROPS = 1 << 3,   // 动态属性，不包含类名和样式\n  FULL_PROPS = 1 << 4,   // 具有动态 key 属性，当 key 改变，需要进行完整的 diff 比较\n  HYDRATE_EVENTS = 1 << 5,   // 带有监听事件的节点\n  STABLE_FRAGMENT = 1 << 6,   // 不会改变子节点顺序的 fragment\n  KEYED_FRAGMENT = 1 << 7,   // 带有 key 属性的 fragment 或部分子节点\n  UNKEYED_FRAGMENT = 1 << 8,   // 子节点没有 key 的fragment\n  NEED_PATCH = 1 << 9,   // 只会进行非 props 的比较\n  DYNAMIC_SLOTS = 1 << 10,   // 动态的插槽\n  HOISTED = -1,   // 静态节点，diff阶段忽略其子节点\n  BAIL = -2   // 代表 diff 应该结束\n}\n```\n\n##### 事件缓存\n\nVue3 的`cacheHandler`可在第一次渲染后缓存我们的事件。相比于 Vue2 无需每次渲染都传递一个新函数。加一个 click 事件\n\n```vue\n<div id=\"app\">\n  <h1>vue3事件缓存讲解</h1>\n  <p>今天天气真不错</p>\n  <div>{{name}}</div>\n  <span onCLick=() => {}><span>\n</div>\n```\n\n渲染函数如下所示。\n\n```js\njs复制代码import { createElementVNode as _createElementVNode, toDisplayString as _toDisplayString, openBlock as _openBlock, createElementBlock as _createElementBlock, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from vue\n \nconst _withScopeId = n => (_pushScopeId(scope-id),n=n(),_popScopeId(),n)\nconst _hoisted_1 = { id: app }\nconst _hoisted_2 = /*#__PURE__*/ _withScopeId(() => /*#__PURE__*/_createElementVNode(h1, null, vue3事件缓存讲解, -1 /* HOISTED */))\nconst _hoisted_3 = /*#__PURE__*/ _withScopeId(() => /*#__PURE__*/_createElementVNode(p, null, 今天天气真不错, -1 /* HOISTED */))\nconst _hoisted_4 = /*#__PURE__*/ _withScopeId(() => /*#__PURE__*/_createElementVNode(span, { onCLick: () => {} }, [\n  /*#__PURE__*/_createElementVNode(span)\n], -1 /* HOISTED */))\n \nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return (_openBlock(), _createElementBlock(div, _hoisted_1, [\n    _hoisted_2,\n    _hoisted_3,\n    _createElementVNode(div, null, _toDisplayString(_ctx.name), 1 /* TEXT */),\n    _hoisted_4\n  ]))\n}\n```\n\n观察以上渲染函数，你会发现 click 事件节点为静态节点（HOISTED 为 -1），即不需要每次重新渲染。\n\n##### Diff算法优化\n\n搬运 Vue3 patchChildren 源码。结合上文与源码，patchFlag 帮助 diff 时区分静态节点，以及不同类型的动态节点。一定程度地减少节点本身及其属性的比对\n\n```js\nfunction patchChildren(n1, n2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) {\n  // 获取新老孩子节点\n  const c1 = n1 && n1.children\n  const c2 = n2.children\n  const prevShapeFlag = n1 ? n1.shapeFlag : 0\n  const { patchFlag, shapeFlag } = n2\n  \n  // 处理 patchFlag 大于 0 \n  if(patchFlag > 0) {\n    if(patchFlag && PatchFlags.KEYED_FRAGMENT) {\n      // 存在 key\n      patchKeyedChildren()\n      return\n    } els if(patchFlag && PatchFlags.UNKEYED_FRAGMENT) {\n      // 不存在 key\n      patchUnkeyedChildren()\n      return\n    }\n  }\n  \n  // 匹配是文本节点（静态）：移除老节点，设置文本节点\n  if(shapeFlag && ShapeFlags.TEXT_CHILDREN) {\n    if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n      unmountChildren(c1 as VNode[], parentComponent, parentSuspense)\n    }\n    if (c2 !== c1) {\n      hostSetElementText(container, c2 as string)\n    }\n  } else {\n    // 匹配新老 Vnode 是数组，则全量比较；否则移除当前所有的节点\n    if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n      if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n        patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense,...)\n      } else {\n        unmountChildren(c1 as VNode[], parentComponent, parentSuspense, true)\n      }\n    } else {\n      \n      if(prevShapeFlag & ShapeFlags.TEXT_CHILDREN) {\n        hostSetElementText(container, '')\n      } \n      if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n        mountChildren(c2 as VNodeArrayChildren, container,anchor,parentComponent,...)\n      }\n    }\n  }\n}\n```\n\npatchUnkeyedChildren 源码如下所示。\n\n```js\njs复制代码function patchUnkeyedChildren(c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) {\n  c1 = c1 || EMPTY_ARR\n  c2 = c2 || EMPTY_ARR\n  const oldLength = c1.length\n  const newLength = c2.length\n  const commonLength = Math.min(oldLength, newLength)\n  let i\n  for(i = 0; i < commonLength; i++) {\n    // 如果新 Vnode 已经挂载，则直接 clone 一份，否则新建一个节点\n    const nextChild = (c2[i] = optimized ? cloneIfMounted(c2[i] as Vnode)) : normalizeVnode(c2[i])\n    patch()\n  }\n  if(oldLength > newLength) {\n    // 移除多余的节点\n    unmountedChildren()\n  } else {\n    // 创建新的节点\n    mountChildren()\n  }\n}\n```\n\n##### 打包优化\n\nTree-shaking：模块打包 webpack、rollup 等中的概念。移除 JavaScript 上下文中未引用的代码。主要依赖于 import 和 export 语句，用来检测代码模块是否被导出、导入，且被 JavaScript 文件使用。\n\n以 nextTick 为例子，在 Vue2 中，全局API暴露在Vue实例上，即使未使用，也无法通过 tree-shaking 进行消除\n\n```vue\nimport Vue from 'vue';\n \nVue.nextTick(() => {\n  // 一些和DOM有关的东西\n});\n```\n\nVue3 中针对全局和内部的API进行了重构，并考虑到 tree-shaking 的支持。因此，全局API现在只能作为ES模块构建的命名导出进行访问。\n\n```js\njs复制代码import { nextTick } from 'vue';   // 显式导入\n \nnextTick(() => {\n  // 一些和DOM有关的东西\n});\n```\n\n通过这一更改，只要模块绑定器支持 tree-shaking，则Vue应用程序中未使用的 api 将从最终的捆绑包中消除，获得最佳文件大小\n\n受此更改影响的全局API如下所示。\n\n- Vue.nextTick\n- Vue.observable （用 Vue.reactive 替换）\n- Vue.version\n- Vue.compile （仅全构建）\n- Vue.set （仅兼容构建）\n- Vue.delete （仅兼容构建）\n\n内部API也有诸如 transition、v-model 等标签或者指令被命名导出。只有在程序真正使用才会被捆绑打包。Vue3 将所有运行功能打包也只有约22.5kb，比 Vue2 轻量很多\n\n##### TypeScript支持\n\nVue3 由 TypeScript 重写，相对于 Vue2 有更好的 TypeScript 支持。\n\n- Vue2 Options API 中 option 是个简单对象，而 TypeScript 是一种类型系统，面向对象的语法，不是特别匹配。\n- Vue2 需要vue-class-component强化vue原生组件，也需要vue-property-decorator增加更多结合Vue特性的装饰器，写法比较繁琐\n\n##### Options API\n\n使用 Options API，我们使用选项对象定义组件的逻辑，例如data、methods和mounted。由选项定义的属性在 this 内部函数中公开，指向组件实例，如下所示\n\n```vue\n<template>\n  <button @click=\"increment\">count is: {{ count }}</button>\n</template>\n \n<script>\nexport default {\n  data() {\n    return {\n      count: 0\n    }\n  },\n  methods: {\n    increment() {\n      this.count++;\n    }\n  },\n  mounted() {\n    console.log(`The initial count is ${this.count}.`);\n  }\n}\n</script>\n```\n\n##### Composition API\n\n使用 Composition API，我们使用导入的 API 函数定义组件的逻辑。在 SFC 中，Composition API 通常使用\n\n```vue\n<template>\n  <button @click=\"increment\">Count is: {{ count }}</button>\n</template>\n \n<script setup>\nimport { ref, onMounted } from 'vue';\n \nconst count = ref(0);\n \nfunction increment() {\n  count.value++;\n}\n \nonMounted(() => {\n  console.log(`The initial count is ${count.value}.`);\n})\n</script>\n```\n\n\n\n\n\n\n\n\n\n\n\n#### HTML页面加载完成后,会触发那个事件？onready还是onload \n\nonready在dom元素结构完成就会执行，onload会在图片等资源完全加载完之后才执行；onready有多少执行多少，onload只会执行最后一个\n\n#### 页面刷新后store中的数据是否存在\n\n不会存在\n\n#### 本地存储\n\n共同点:都是保存在浏览器端,并且是同源的\n\n##### cookie\n\n不适合存储大量的数据。\n\ncookie数据始终在同源的http请求中携带，即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下,存储的大小很小只有4K左右。 （key：可以在浏览器和服务器端来回传递，存储容量小，只有大约4K左右）\n\n- **保存用户登录状态。** 例如将用户id存储于一个cookie内，这样当用户下次访问该页面时就不需要重新登录了，现在很多论坛和社区都提供这样的功能。 cookie还可以设置过期时间，当超过时间期限后，cookie就会自动消失。因此，系统往往可以提示用户保持登录状态的时间：常见选项有一个月、三个 月、一年等。\n\n- **跟踪用户行为。** 例如一个天气预报网站，能够根据用户选择的地区显示当地的天气情况。如果每次都需要选择所在地是烦琐的，当利用了 cookie后就会显得很人性化了，系统能够记住上一次访问的地区，当下次再打开该页面时，它就会自动显示上次用户所在地区的天气情况。因为一切都是在后 台完成，所以这样的页面就像为某个用户所定制的一样，使用起来非常方便。\n\n- **定制页面。** 如果网站提供了换肤或更换布局的功能，那么可以使用cookie来记录用户的选项，例如：背景色、分辨率等。当用户下次访问时，仍然可以保存上一次访问的界面风格。\n\n##### sessionStorage\n\n**sessionStorage**：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持，localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。（key：本身就是一个回话过程，关闭浏览器后消失，session为一个回话，当页面不同即使是同一页面打开两次，也被视为同一次回话）\n\n##### localStorage\n\n**localStorage**:localStorage 在所有同源窗口中都是共享的;cookie也是在所有同源窗口中都是共享的.(key:同源窗口都会共享，并且不会失效，不管窗口或者浏览器关闭与否都会始终生效)\n\n- localStorage::是永久存储，浏览器关闭后数据不会丢失，除非主动删除数据。当关闭页面后重新打开，会读取上一次打开的页面数据\n- sessionStorage: 在当前浏览器窗口关闭后自动删除。所以，sessionStorage 最合适\n\n#### 深入理解JS闭包\n\n> 闭包是函数和声明该函数的词法环境的组合。\n\n闭包让你可以在一个内层函数中访问到其外层函数的作用域.在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来.\n如:\n\n```javascript\nfunction block() {\n  let name = 'RiverLi'\n  function displayName() {\n    document.getElementById('root').innerText = name\n  }\n  displayName()\n}\nblock()\n```\n\n\n#### rem是怎么计算的\n\n> **「rem」是指根元素（root element，html）的字体大小，从遥远的 IE6 到版本到 Chrome 他们都约好了，**根元素默认的 font-size 都是 16px。****\n\nrem是通过根元素进行适配的，网页中的根元素指的是html我们通过设置html的字体大小就可以控制rem的大小；****\n\n`所以1rem*16(这个是html的fontsize)=16px;`\n\n#### Vue3的组合式API优点\n\n- 有更高效的灵活性\n\n处理相同逻辑关注点的代码被强制拆分在了不同的选项中，位于文件的不同部分。而组合式api里可以把功能相联系的代码放在一部分，维护起来也比较方便。\n\n\n\n\n\n\n\n\n\n\n#### 鸣谢:\n\n作者：百年孤独html\n链接：https://juejin.cn/post/7001345953105969160\n来源：稀土掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n作者:Tz\n链接:https://juejin.cn/post/6912030758404259854\n来源:稀土掘金\n著作权归作者所有商业转载请联系作者获得授权,非商业转载请注明出处\n\n作者:前端小工\n链接:https://juejin.cn/post/7174003943976992776\n来源:稀土掘金\n著作权归作者所有商业转载请联系作者获得授权,非商业转载请注明出处\n\nhttps://zhuanlan.zhihu.com/p/94601709\n\n\n作者：cv搬砖工\n链接：https://juejin.cn/post/7067413380922867725\n来源：稀土掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n作者：CoderBin\n链接：https://juejin.cn/post/7152041813358936094\n来源：稀土掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n版权声明：本文为CSDN博主「@Demi」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/qq_38128179/article/details/104916746\n\n[小猪冒泡](https://www.cnblogs.com/xiaozhumaopao/p/8260447.html#:~:text=rem%E6%98%AF%E6%80%8E%E4%B9%88%E8%AE%A1%E7%AE%97%E7%9A%84%20%E3%80%8Crem%E3%80%8D%E6%98%AF%E6%8C%87%E6%A0%B9%E5%85%83%E7%B4%A0%EF%BC%88root%20element%EF%BC%8Chtml%EF%BC%89%E7%9A%84%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F%EF%BC%8C%E4%BB%8E%E9%81%A5%E8%BF%9C%E7%9A%84%20IE6%20%E5%88%B0%E7%89%88%E6%9C%AC%E5%88%B0%20Chrome,%E4%BB%96%E4%BB%AC%E9%83%BD%E7%BA%A6%E5%A5%BD%E4%BA%86%EF%BC%8C%E6%A0%B9%E5%85%83%E7%B4%A0%E9%BB%98%E8%AE%A4%E7%9A%84%20font-size%20%E9%83%BD%E6%98%AF%2016px%E3%80%82%20rem%E6%98%AF%E9%80%9A%E8%BF%87%E6%A0%B9%E5%85%83%E7%B4%A0%E8%BF%9B%E8%A1%8C%E9%80%82%E9%85%8D%E7%9A%84%EF%BC%8C%E7%BD%91%E9%A1%B5%E4%B8%AD%E7%9A%84%E6%A0%B9%E5%85%83%E7%B4%A0%E6%8C%87%E7%9A%84%E6%98%AFhtml%E6%88%91%E4%BB%AC%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AEhtml%E7%9A%84%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%8E%A7%E5%88%B6rem%E7%9A%84%E5%A4%A7%E5%B0%8F%EF%BC%9B%20%E6%89%80%E4%BB%A51rem%2A16%28%E8%BF%99%E4%B8%AA%E6%98%AFhtml%E7%9A%84fontsize%29%3D16px%3B)",
        "states": "1",
        "description": "> 一些面试题目:  ##### vue中watch和computed的区别",
        "praise": null,
        "view": "23",
        "audit": "1",
        "tag1": "前端",
        "tag2": "vue",
        "tag3": "面试",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "2",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "2",
        "createdAt": "2023-05-16T12:27:14.000Z",
        "updatedAt": "2023-05-30T03:17:05.000Z",
        "destroyTime": null
    },
    {
        "id": 317,
        "email": "2714351312@qq.com",
        "title": "说一说优先级的规则",
        "content": "!important > 内联样式（style） > ID选择器（id） > 类选择器(class) > 标签选择器.",
        "states": "1",
        "description": null,
        "praise": null,
        "view": "25",
        "audit": "1",
        "tag1": "css",
        "tag2": "html",
        "tag3": "面试",
        "source": null,
        "url": null,
        "headImg": "/images/headImg/defaultHeadImg.png",
        "type": "blog",
        "hasOriginal": "2",
        "diggCount": "0",
        "articleType": "blog",
        "recommendLevel": "2",
        "createdAt": "2023-05-18T11:18:06.000Z",
        "updatedAt": "2023-07-05T01:14:34.000Z",
        "destroyTime": null
    }
]